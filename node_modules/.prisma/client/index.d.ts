
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model Campaign
 * 
 */
export type Campaign = $Result.DefaultSelection<Prisma.$CampaignPayload>
/**
 * Model Type
 * 
 */
export type Type = $Result.DefaultSelection<Prisma.$TypePayload>
/**
 * Model SubType
 * 
 */
export type SubType = $Result.DefaultSelection<Prisma.$SubTypePayload>
/**
 * Model ContactCampaign
 * 
 */
export type ContactCampaign = $Result.DefaultSelection<Prisma.$ContactCampaignPayload>
/**
 * Model ContactType
 * 
 */
export type ContactType = $Result.DefaultSelection<Prisma.$ContactTypePayload>
/**
 * Model City
 * 
 */
export type City = $Result.DefaultSelection<Prisma.$CityPayload>
/**
 * Model Location
 * 
 */
export type Location = $Result.DefaultSelection<Prisma.$LocationPayload>
/**
 * Model Facility
 * 
 */
export type Facility = $Result.DefaultSelection<Prisma.$FacilityPayload>
/**
 * Model Amenity
 * 
 */
export type Amenity = $Result.DefaultSelection<Prisma.$AmenityPayload>
/**
 * Model FunctionalArea
 * 
 */
export type FunctionalArea = $Result.DefaultSelection<Prisma.$FunctionalAreaPayload>
/**
 * Model Industry
 * 
 */
export type Industry = $Result.DefaultSelection<Prisma.$IndustryPayload>
/**
 * Model Reference
 * 
 */
export type Reference = $Result.DefaultSelection<Prisma.$ReferencePayload>
/**
 * Model Expense
 * 
 */
export type Expense = $Result.DefaultSelection<Prisma.$ExpensePayload>
/**
 * Model Income
 * 
 */
export type Income = $Result.DefaultSelection<Prisma.$IncomePayload>
/**
 * Model StatusType
 * 
 */
export type StatusType = $Result.DefaultSelection<Prisma.$StatusTypePayload>
/**
 * Model ContactStatusType
 * 
 */
export type ContactStatusType = $Result.DefaultSelection<Prisma.$ContactStatusTypePayload>
/**
 * Model PaymentMethod
 * 
 */
export type PaymentMethod = $Result.DefaultSelection<Prisma.$PaymentMethodPayload>
/**
 * Model Template
 * 
 */
export type Template = $Result.DefaultSelection<Prisma.$TemplatePayload>
/**
 * Model IncomeMarketing
 * 
 */
export type IncomeMarketing = $Result.DefaultSelection<Prisma.$IncomeMarketingPayload>
/**
 * Model ExpenseMarketing
 * 
 */
export type ExpenseMarketing = $Result.DefaultSelection<Prisma.$ExpenseMarketingPayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model Schedule
 * 
 */
export type Schedule = $Result.DefaultSelection<Prisma.$SchedulePayload>
/**
 * Model CompanyProject
 * 
 */
export type CompanyProject = $Result.DefaultSelection<Prisma.$CompanyProjectPayload>
/**
 * Model BuilderSlider
 * 
 */
export type BuilderSlider = $Result.DefaultSelection<Prisma.$BuilderSliderPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model Followup
 * 
 */
export type Followup = $Result.DefaultSelection<Prisma.$FollowupPayload>
/**
 * Model Contact
 * 
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>
/**
 * Model ContactFollowup
 * 
 */
export type ContactFollowup = $Result.DefaultSelection<Prisma.$ContactFollowupPayload>
/**
 * Model RequestUser
 * 
 */
export type RequestUser = $Result.DefaultSelection<Prisma.$RequestUserPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  administrator: 'administrator',
  city_admin: 'city_admin',
  user: 'user'
};

export type Role = (typeof Role)[keyof typeof Role]


export const AdminStatus: {
  active: 'active',
  inactive: 'inactive'
};

export type AdminStatus = (typeof AdminStatus)[keyof typeof AdminStatus]


export const Status: {
  Active: 'Active',
  Inactive: 'Inactive'
};

export type Status = (typeof Status)[keyof typeof Status]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type AdminStatus = $Enums.AdminStatus

export const AdminStatus: typeof $Enums.AdminStatus

export type Status = $Enums.Status

export const Status: typeof $Enums.Status

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Admins
 * const admins = await prisma.admin.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Admins
   * const admins = await prisma.admin.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.campaign`: Exposes CRUD operations for the **Campaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaigns
    * const campaigns = await prisma.campaign.findMany()
    * ```
    */
  get campaign(): Prisma.CampaignDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.type`: Exposes CRUD operations for the **Type** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Types
    * const types = await prisma.type.findMany()
    * ```
    */
  get type(): Prisma.TypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subType`: Exposes CRUD operations for the **SubType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubTypes
    * const subTypes = await prisma.subType.findMany()
    * ```
    */
  get subType(): Prisma.SubTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactCampaign`: Exposes CRUD operations for the **ContactCampaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactCampaigns
    * const contactCampaigns = await prisma.contactCampaign.findMany()
    * ```
    */
  get contactCampaign(): Prisma.ContactCampaignDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactType`: Exposes CRUD operations for the **ContactType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactTypes
    * const contactTypes = await prisma.contactType.findMany()
    * ```
    */
  get contactType(): Prisma.ContactTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.city`: Exposes CRUD operations for the **City** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities
    * const cities = await prisma.city.findMany()
    * ```
    */
  get city(): Prisma.CityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.LocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.facility`: Exposes CRUD operations for the **Facility** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Facilities
    * const facilities = await prisma.facility.findMany()
    * ```
    */
  get facility(): Prisma.FacilityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.amenity`: Exposes CRUD operations for the **Amenity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Amenities
    * const amenities = await prisma.amenity.findMany()
    * ```
    */
  get amenity(): Prisma.AmenityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.functionalArea`: Exposes CRUD operations for the **FunctionalArea** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FunctionalAreas
    * const functionalAreas = await prisma.functionalArea.findMany()
    * ```
    */
  get functionalArea(): Prisma.FunctionalAreaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.industry`: Exposes CRUD operations for the **Industry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Industries
    * const industries = await prisma.industry.findMany()
    * ```
    */
  get industry(): Prisma.IndustryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reference`: Exposes CRUD operations for the **Reference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more References
    * const references = await prisma.reference.findMany()
    * ```
    */
  get reference(): Prisma.ReferenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.expense`: Exposes CRUD operations for the **Expense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Expenses
    * const expenses = await prisma.expense.findMany()
    * ```
    */
  get expense(): Prisma.ExpenseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.income`: Exposes CRUD operations for the **Income** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Incomes
    * const incomes = await prisma.income.findMany()
    * ```
    */
  get income(): Prisma.IncomeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.statusType`: Exposes CRUD operations for the **StatusType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StatusTypes
    * const statusTypes = await prisma.statusType.findMany()
    * ```
    */
  get statusType(): Prisma.StatusTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactStatusType`: Exposes CRUD operations for the **ContactStatusType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactStatusTypes
    * const contactStatusTypes = await prisma.contactStatusType.findMany()
    * ```
    */
  get contactStatusType(): Prisma.ContactStatusTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentMethod`: Exposes CRUD operations for the **PaymentMethod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentMethods
    * const paymentMethods = await prisma.paymentMethod.findMany()
    * ```
    */
  get paymentMethod(): Prisma.PaymentMethodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.template`: Exposes CRUD operations for the **Template** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Templates
    * const templates = await prisma.template.findMany()
    * ```
    */
  get template(): Prisma.TemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.incomeMarketing`: Exposes CRUD operations for the **IncomeMarketing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IncomeMarketings
    * const incomeMarketings = await prisma.incomeMarketing.findMany()
    * ```
    */
  get incomeMarketing(): Prisma.IncomeMarketingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.expenseMarketing`: Exposes CRUD operations for the **ExpenseMarketing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExpenseMarketings
    * const expenseMarketings = await prisma.expenseMarketing.findMany()
    * ```
    */
  get expenseMarketing(): Prisma.ExpenseMarketingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.schedule`: Exposes CRUD operations for the **Schedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schedules
    * const schedules = await prisma.schedule.findMany()
    * ```
    */
  get schedule(): Prisma.ScheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companyProject`: Exposes CRUD operations for the **CompanyProject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyProjects
    * const companyProjects = await prisma.companyProject.findMany()
    * ```
    */
  get companyProject(): Prisma.CompanyProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.builderSlider`: Exposes CRUD operations for the **BuilderSlider** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BuilderSliders
    * const builderSliders = await prisma.builderSlider.findMany()
    * ```
    */
  get builderSlider(): Prisma.BuilderSliderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.followup`: Exposes CRUD operations for the **Followup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Followups
    * const followups = await prisma.followup.findMany()
    * ```
    */
  get followup(): Prisma.FollowupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactFollowup`: Exposes CRUD operations for the **ContactFollowup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactFollowups
    * const contactFollowups = await prisma.contactFollowup.findMany()
    * ```
    */
  get contactFollowup(): Prisma.ContactFollowupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.requestUser`: Exposes CRUD operations for the **RequestUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequestUsers
    * const requestUsers = await prisma.requestUser.findMany()
    * ```
    */
  get requestUser(): Prisma.RequestUserDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Admin: 'Admin',
    Campaign: 'Campaign',
    Type: 'Type',
    SubType: 'SubType',
    ContactCampaign: 'ContactCampaign',
    ContactType: 'ContactType',
    City: 'City',
    Location: 'Location',
    Facility: 'Facility',
    Amenity: 'Amenity',
    FunctionalArea: 'FunctionalArea',
    Industry: 'Industry',
    Reference: 'Reference',
    Expense: 'Expense',
    Income: 'Income',
    StatusType: 'StatusType',
    ContactStatusType: 'ContactStatusType',
    PaymentMethod: 'PaymentMethod',
    Template: 'Template',
    IncomeMarketing: 'IncomeMarketing',
    ExpenseMarketing: 'ExpenseMarketing',
    Task: 'Task',
    Schedule: 'Schedule',
    CompanyProject: 'CompanyProject',
    BuilderSlider: 'BuilderSlider',
    Customer: 'Customer',
    Followup: 'Followup',
    Contact: 'Contact',
    ContactFollowup: 'ContactFollowup',
    RequestUser: 'RequestUser'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "admin" | "campaign" | "type" | "subType" | "contactCampaign" | "contactType" | "city" | "location" | "facility" | "amenity" | "functionalArea" | "industry" | "reference" | "expense" | "income" | "statusType" | "contactStatusType" | "paymentMethod" | "template" | "incomeMarketing" | "expenseMarketing" | "task" | "schedule" | "companyProject" | "builderSlider" | "customer" | "followup" | "contact" | "contactFollowup" | "requestUser"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      Campaign: {
        payload: Prisma.$CampaignPayload<ExtArgs>
        fields: Prisma.CampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findFirst: {
            args: Prisma.CampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findMany: {
            args: Prisma.CampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          create: {
            args: Prisma.CampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          createMany: {
            args: Prisma.CampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          update: {
            args: Prisma.CampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          deleteMany: {
            args: Prisma.CampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          aggregate: {
            args: Prisma.CampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaign>
          }
          groupBy: {
            args: Prisma.CampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignCountAggregateOutputType> | number
          }
        }
      }
      Type: {
        payload: Prisma.$TypePayload<ExtArgs>
        fields: Prisma.TypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload>
          }
          findFirst: {
            args: Prisma.TypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload>
          }
          findMany: {
            args: Prisma.TypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload>[]
          }
          create: {
            args: Prisma.TypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload>
          }
          createMany: {
            args: Prisma.TypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload>
          }
          update: {
            args: Prisma.TypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload>
          }
          deleteMany: {
            args: Prisma.TypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload>
          }
          aggregate: {
            args: Prisma.TypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateType>
          }
          groupBy: {
            args: Prisma.TypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<TypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.TypeCountArgs<ExtArgs>
            result: $Utils.Optional<TypeCountAggregateOutputType> | number
          }
        }
      }
      SubType: {
        payload: Prisma.$SubTypePayload<ExtArgs>
        fields: Prisma.SubTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubTypePayload>
          }
          findFirst: {
            args: Prisma.SubTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubTypePayload>
          }
          findMany: {
            args: Prisma.SubTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubTypePayload>[]
          }
          create: {
            args: Prisma.SubTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubTypePayload>
          }
          createMany: {
            args: Prisma.SubTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SubTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubTypePayload>
          }
          update: {
            args: Prisma.SubTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubTypePayload>
          }
          deleteMany: {
            args: Prisma.SubTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubTypePayload>
          }
          aggregate: {
            args: Prisma.SubTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubType>
          }
          groupBy: {
            args: Prisma.SubTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubTypeCountArgs<ExtArgs>
            result: $Utils.Optional<SubTypeCountAggregateOutputType> | number
          }
        }
      }
      ContactCampaign: {
        payload: Prisma.$ContactCampaignPayload<ExtArgs>
        fields: Prisma.ContactCampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactCampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactCampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactCampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactCampaignPayload>
          }
          findFirst: {
            args: Prisma.ContactCampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactCampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactCampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactCampaignPayload>
          }
          findMany: {
            args: Prisma.ContactCampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactCampaignPayload>[]
          }
          create: {
            args: Prisma.ContactCampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactCampaignPayload>
          }
          createMany: {
            args: Prisma.ContactCampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContactCampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactCampaignPayload>
          }
          update: {
            args: Prisma.ContactCampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactCampaignPayload>
          }
          deleteMany: {
            args: Prisma.ContactCampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactCampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContactCampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactCampaignPayload>
          }
          aggregate: {
            args: Prisma.ContactCampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactCampaign>
          }
          groupBy: {
            args: Prisma.ContactCampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactCampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCampaignCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCampaignCountAggregateOutputType> | number
          }
        }
      }
      ContactType: {
        payload: Prisma.$ContactTypePayload<ExtArgs>
        fields: Prisma.ContactTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTypePayload>
          }
          findFirst: {
            args: Prisma.ContactTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTypePayload>
          }
          findMany: {
            args: Prisma.ContactTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTypePayload>[]
          }
          create: {
            args: Prisma.ContactTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTypePayload>
          }
          createMany: {
            args: Prisma.ContactTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContactTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTypePayload>
          }
          update: {
            args: Prisma.ContactTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTypePayload>
          }
          deleteMany: {
            args: Prisma.ContactTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContactTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTypePayload>
          }
          aggregate: {
            args: Prisma.ContactTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactType>
          }
          groupBy: {
            args: Prisma.ContactTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactTypeCountArgs<ExtArgs>
            result: $Utils.Optional<ContactTypeCountAggregateOutputType> | number
          }
        }
      }
      City: {
        payload: Prisma.$CityPayload<ExtArgs>
        fields: Prisma.CityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findFirst: {
            args: Prisma.CityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findMany: {
            args: Prisma.CityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          create: {
            args: Prisma.CityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          createMany: {
            args: Prisma.CityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          update: {
            args: Prisma.CityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          deleteMany: {
            args: Prisma.CityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          aggregate: {
            args: Prisma.CityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCity>
          }
          groupBy: {
            args: Prisma.CityGroupByArgs<ExtArgs>
            result: $Utils.Optional<CityGroupByOutputType>[]
          }
          count: {
            args: Prisma.CityCountArgs<ExtArgs>
            result: $Utils.Optional<CityCountAggregateOutputType> | number
          }
        }
      }
      Location: {
        payload: Prisma.$LocationPayload<ExtArgs>
        fields: Prisma.LocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findFirst: {
            args: Prisma.LocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findMany: {
            args: Prisma.LocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          create: {
            args: Prisma.LocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          createMany: {
            args: Prisma.LocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          update: {
            args: Prisma.LocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          deleteMany: {
            args: Prisma.LocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.LocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationCountArgs<ExtArgs>
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      Facility: {
        payload: Prisma.$FacilityPayload<ExtArgs>
        fields: Prisma.FacilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FacilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FacilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          findFirst: {
            args: Prisma.FacilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FacilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          findMany: {
            args: Prisma.FacilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>[]
          }
          create: {
            args: Prisma.FacilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          createMany: {
            args: Prisma.FacilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FacilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          update: {
            args: Prisma.FacilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          deleteMany: {
            args: Prisma.FacilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FacilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FacilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>
          }
          aggregate: {
            args: Prisma.FacilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFacility>
          }
          groupBy: {
            args: Prisma.FacilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<FacilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.FacilityCountArgs<ExtArgs>
            result: $Utils.Optional<FacilityCountAggregateOutputType> | number
          }
        }
      }
      Amenity: {
        payload: Prisma.$AmenityPayload<ExtArgs>
        fields: Prisma.AmenityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AmenityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AmenityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          findFirst: {
            args: Prisma.AmenityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AmenityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          findMany: {
            args: Prisma.AmenityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>[]
          }
          create: {
            args: Prisma.AmenityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          createMany: {
            args: Prisma.AmenityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AmenityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          update: {
            args: Prisma.AmenityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          deleteMany: {
            args: Prisma.AmenityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AmenityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AmenityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          aggregate: {
            args: Prisma.AmenityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAmenity>
          }
          groupBy: {
            args: Prisma.AmenityGroupByArgs<ExtArgs>
            result: $Utils.Optional<AmenityGroupByOutputType>[]
          }
          count: {
            args: Prisma.AmenityCountArgs<ExtArgs>
            result: $Utils.Optional<AmenityCountAggregateOutputType> | number
          }
        }
      }
      FunctionalArea: {
        payload: Prisma.$FunctionalAreaPayload<ExtArgs>
        fields: Prisma.FunctionalAreaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FunctionalAreaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunctionalAreaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FunctionalAreaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunctionalAreaPayload>
          }
          findFirst: {
            args: Prisma.FunctionalAreaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunctionalAreaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FunctionalAreaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunctionalAreaPayload>
          }
          findMany: {
            args: Prisma.FunctionalAreaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunctionalAreaPayload>[]
          }
          create: {
            args: Prisma.FunctionalAreaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunctionalAreaPayload>
          }
          createMany: {
            args: Prisma.FunctionalAreaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FunctionalAreaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunctionalAreaPayload>
          }
          update: {
            args: Prisma.FunctionalAreaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunctionalAreaPayload>
          }
          deleteMany: {
            args: Prisma.FunctionalAreaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FunctionalAreaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FunctionalAreaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunctionalAreaPayload>
          }
          aggregate: {
            args: Prisma.FunctionalAreaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFunctionalArea>
          }
          groupBy: {
            args: Prisma.FunctionalAreaGroupByArgs<ExtArgs>
            result: $Utils.Optional<FunctionalAreaGroupByOutputType>[]
          }
          count: {
            args: Prisma.FunctionalAreaCountArgs<ExtArgs>
            result: $Utils.Optional<FunctionalAreaCountAggregateOutputType> | number
          }
        }
      }
      Industry: {
        payload: Prisma.$IndustryPayload<ExtArgs>
        fields: Prisma.IndustryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IndustryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndustryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IndustryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndustryPayload>
          }
          findFirst: {
            args: Prisma.IndustryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndustryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IndustryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndustryPayload>
          }
          findMany: {
            args: Prisma.IndustryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndustryPayload>[]
          }
          create: {
            args: Prisma.IndustryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndustryPayload>
          }
          createMany: {
            args: Prisma.IndustryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.IndustryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndustryPayload>
          }
          update: {
            args: Prisma.IndustryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndustryPayload>
          }
          deleteMany: {
            args: Prisma.IndustryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IndustryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IndustryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndustryPayload>
          }
          aggregate: {
            args: Prisma.IndustryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIndustry>
          }
          groupBy: {
            args: Prisma.IndustryGroupByArgs<ExtArgs>
            result: $Utils.Optional<IndustryGroupByOutputType>[]
          }
          count: {
            args: Prisma.IndustryCountArgs<ExtArgs>
            result: $Utils.Optional<IndustryCountAggregateOutputType> | number
          }
        }
      }
      Reference: {
        payload: Prisma.$ReferencePayload<ExtArgs>
        fields: Prisma.ReferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferencePayload>
          }
          findFirst: {
            args: Prisma.ReferenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferencePayload>
          }
          findMany: {
            args: Prisma.ReferenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferencePayload>[]
          }
          create: {
            args: Prisma.ReferenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferencePayload>
          }
          createMany: {
            args: Prisma.ReferenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReferenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferencePayload>
          }
          update: {
            args: Prisma.ReferenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferencePayload>
          }
          deleteMany: {
            args: Prisma.ReferenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReferenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReferenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferencePayload>
          }
          aggregate: {
            args: Prisma.ReferenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReference>
          }
          groupBy: {
            args: Prisma.ReferenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReferenceCountArgs<ExtArgs>
            result: $Utils.Optional<ReferenceCountAggregateOutputType> | number
          }
        }
      }
      Expense: {
        payload: Prisma.$ExpensePayload<ExtArgs>
        fields: Prisma.ExpenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findFirst: {
            args: Prisma.ExpenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findMany: {
            args: Prisma.ExpenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          create: {
            args: Prisma.ExpenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          createMany: {
            args: Prisma.ExpenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ExpenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          update: {
            args: Prisma.ExpenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          deleteMany: {
            args: Prisma.ExpenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExpenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          aggregate: {
            args: Prisma.ExpenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpense>
          }
          groupBy: {
            args: Prisma.ExpenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseCountAggregateOutputType> | number
          }
        }
      }
      Income: {
        payload: Prisma.$IncomePayload<ExtArgs>
        fields: Prisma.IncomeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IncomeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IncomeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomePayload>
          }
          findFirst: {
            args: Prisma.IncomeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IncomeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomePayload>
          }
          findMany: {
            args: Prisma.IncomeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomePayload>[]
          }
          create: {
            args: Prisma.IncomeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomePayload>
          }
          createMany: {
            args: Prisma.IncomeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.IncomeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomePayload>
          }
          update: {
            args: Prisma.IncomeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomePayload>
          }
          deleteMany: {
            args: Prisma.IncomeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IncomeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IncomeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomePayload>
          }
          aggregate: {
            args: Prisma.IncomeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIncome>
          }
          groupBy: {
            args: Prisma.IncomeGroupByArgs<ExtArgs>
            result: $Utils.Optional<IncomeGroupByOutputType>[]
          }
          count: {
            args: Prisma.IncomeCountArgs<ExtArgs>
            result: $Utils.Optional<IncomeCountAggregateOutputType> | number
          }
        }
      }
      StatusType: {
        payload: Prisma.$StatusTypePayload<ExtArgs>
        fields: Prisma.StatusTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StatusTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StatusTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusTypePayload>
          }
          findFirst: {
            args: Prisma.StatusTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StatusTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusTypePayload>
          }
          findMany: {
            args: Prisma.StatusTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusTypePayload>[]
          }
          create: {
            args: Prisma.StatusTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusTypePayload>
          }
          createMany: {
            args: Prisma.StatusTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StatusTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusTypePayload>
          }
          update: {
            args: Prisma.StatusTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusTypePayload>
          }
          deleteMany: {
            args: Prisma.StatusTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StatusTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StatusTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusTypePayload>
          }
          aggregate: {
            args: Prisma.StatusTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStatusType>
          }
          groupBy: {
            args: Prisma.StatusTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<StatusTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.StatusTypeCountArgs<ExtArgs>
            result: $Utils.Optional<StatusTypeCountAggregateOutputType> | number
          }
        }
      }
      ContactStatusType: {
        payload: Prisma.$ContactStatusTypePayload<ExtArgs>
        fields: Prisma.ContactStatusTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactStatusTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactStatusTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactStatusTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactStatusTypePayload>
          }
          findFirst: {
            args: Prisma.ContactStatusTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactStatusTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactStatusTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactStatusTypePayload>
          }
          findMany: {
            args: Prisma.ContactStatusTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactStatusTypePayload>[]
          }
          create: {
            args: Prisma.ContactStatusTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactStatusTypePayload>
          }
          createMany: {
            args: Prisma.ContactStatusTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContactStatusTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactStatusTypePayload>
          }
          update: {
            args: Prisma.ContactStatusTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactStatusTypePayload>
          }
          deleteMany: {
            args: Prisma.ContactStatusTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactStatusTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContactStatusTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactStatusTypePayload>
          }
          aggregate: {
            args: Prisma.ContactStatusTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactStatusType>
          }
          groupBy: {
            args: Prisma.ContactStatusTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactStatusTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactStatusTypeCountArgs<ExtArgs>
            result: $Utils.Optional<ContactStatusTypeCountAggregateOutputType> | number
          }
        }
      }
      PaymentMethod: {
        payload: Prisma.$PaymentMethodPayload<ExtArgs>
        fields: Prisma.PaymentMethodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentMethodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentMethodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          findFirst: {
            args: Prisma.PaymentMethodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentMethodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          findMany: {
            args: Prisma.PaymentMethodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          create: {
            args: Prisma.PaymentMethodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          createMany: {
            args: Prisma.PaymentMethodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PaymentMethodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          update: {
            args: Prisma.PaymentMethodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          deleteMany: {
            args: Prisma.PaymentMethodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentMethodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentMethodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          aggregate: {
            args: Prisma.PaymentMethodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentMethod>
          }
          groupBy: {
            args: Prisma.PaymentMethodGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentMethodCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodCountAggregateOutputType> | number
          }
        }
      }
      Template: {
        payload: Prisma.$TemplatePayload<ExtArgs>
        fields: Prisma.TemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          findFirst: {
            args: Prisma.TemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          findMany: {
            args: Prisma.TemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>[]
          }
          create: {
            args: Prisma.TemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          createMany: {
            args: Prisma.TemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          update: {
            args: Prisma.TemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          deleteMany: {
            args: Prisma.TemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          aggregate: {
            args: Prisma.TemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTemplate>
          }
          groupBy: {
            args: Prisma.TemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<TemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.TemplateCountArgs<ExtArgs>
            result: $Utils.Optional<TemplateCountAggregateOutputType> | number
          }
        }
      }
      IncomeMarketing: {
        payload: Prisma.$IncomeMarketingPayload<ExtArgs>
        fields: Prisma.IncomeMarketingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IncomeMarketingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeMarketingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IncomeMarketingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeMarketingPayload>
          }
          findFirst: {
            args: Prisma.IncomeMarketingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeMarketingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IncomeMarketingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeMarketingPayload>
          }
          findMany: {
            args: Prisma.IncomeMarketingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeMarketingPayload>[]
          }
          create: {
            args: Prisma.IncomeMarketingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeMarketingPayload>
          }
          createMany: {
            args: Prisma.IncomeMarketingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.IncomeMarketingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeMarketingPayload>
          }
          update: {
            args: Prisma.IncomeMarketingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeMarketingPayload>
          }
          deleteMany: {
            args: Prisma.IncomeMarketingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IncomeMarketingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IncomeMarketingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomeMarketingPayload>
          }
          aggregate: {
            args: Prisma.IncomeMarketingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIncomeMarketing>
          }
          groupBy: {
            args: Prisma.IncomeMarketingGroupByArgs<ExtArgs>
            result: $Utils.Optional<IncomeMarketingGroupByOutputType>[]
          }
          count: {
            args: Prisma.IncomeMarketingCountArgs<ExtArgs>
            result: $Utils.Optional<IncomeMarketingCountAggregateOutputType> | number
          }
        }
      }
      ExpenseMarketing: {
        payload: Prisma.$ExpenseMarketingPayload<ExtArgs>
        fields: Prisma.ExpenseMarketingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseMarketingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseMarketingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseMarketingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseMarketingPayload>
          }
          findFirst: {
            args: Prisma.ExpenseMarketingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseMarketingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseMarketingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseMarketingPayload>
          }
          findMany: {
            args: Prisma.ExpenseMarketingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseMarketingPayload>[]
          }
          create: {
            args: Prisma.ExpenseMarketingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseMarketingPayload>
          }
          createMany: {
            args: Prisma.ExpenseMarketingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ExpenseMarketingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseMarketingPayload>
          }
          update: {
            args: Prisma.ExpenseMarketingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseMarketingPayload>
          }
          deleteMany: {
            args: Prisma.ExpenseMarketingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseMarketingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExpenseMarketingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseMarketingPayload>
          }
          aggregate: {
            args: Prisma.ExpenseMarketingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpenseMarketing>
          }
          groupBy: {
            args: Prisma.ExpenseMarketingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseMarketingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseMarketingCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseMarketingCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      Schedule: {
        payload: Prisma.$SchedulePayload<ExtArgs>
        fields: Prisma.ScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          findFirst: {
            args: Prisma.ScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          findMany: {
            args: Prisma.ScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>[]
          }
          create: {
            args: Prisma.ScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          createMany: {
            args: Prisma.ScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          update: {
            args: Prisma.ScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          deleteMany: {
            args: Prisma.ScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          aggregate: {
            args: Prisma.ScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchedule>
          }
          groupBy: {
            args: Prisma.ScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduleCountAggregateOutputType> | number
          }
        }
      }
      CompanyProject: {
        payload: Prisma.$CompanyProjectPayload<ExtArgs>
        fields: Prisma.CompanyProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyProjectPayload>
          }
          findFirst: {
            args: Prisma.CompanyProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyProjectPayload>
          }
          findMany: {
            args: Prisma.CompanyProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyProjectPayload>[]
          }
          create: {
            args: Prisma.CompanyProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyProjectPayload>
          }
          createMany: {
            args: Prisma.CompanyProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CompanyProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyProjectPayload>
          }
          update: {
            args: Prisma.CompanyProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyProjectPayload>
          }
          deleteMany: {
            args: Prisma.CompanyProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompanyProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyProjectPayload>
          }
          aggregate: {
            args: Prisma.CompanyProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyProject>
          }
          groupBy: {
            args: Prisma.CompanyProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyProjectCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyProjectCountAggregateOutputType> | number
          }
        }
      }
      BuilderSlider: {
        payload: Prisma.$BuilderSliderPayload<ExtArgs>
        fields: Prisma.BuilderSliderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BuilderSliderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuilderSliderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BuilderSliderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuilderSliderPayload>
          }
          findFirst: {
            args: Prisma.BuilderSliderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuilderSliderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BuilderSliderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuilderSliderPayload>
          }
          findMany: {
            args: Prisma.BuilderSliderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuilderSliderPayload>[]
          }
          create: {
            args: Prisma.BuilderSliderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuilderSliderPayload>
          }
          createMany: {
            args: Prisma.BuilderSliderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BuilderSliderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuilderSliderPayload>
          }
          update: {
            args: Prisma.BuilderSliderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuilderSliderPayload>
          }
          deleteMany: {
            args: Prisma.BuilderSliderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BuilderSliderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BuilderSliderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuilderSliderPayload>
          }
          aggregate: {
            args: Prisma.BuilderSliderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBuilderSlider>
          }
          groupBy: {
            args: Prisma.BuilderSliderGroupByArgs<ExtArgs>
            result: $Utils.Optional<BuilderSliderGroupByOutputType>[]
          }
          count: {
            args: Prisma.BuilderSliderCountArgs<ExtArgs>
            result: $Utils.Optional<BuilderSliderCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      Followup: {
        payload: Prisma.$FollowupPayload<ExtArgs>
        fields: Prisma.FollowupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FollowupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FollowupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowupPayload>
          }
          findFirst: {
            args: Prisma.FollowupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FollowupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowupPayload>
          }
          findMany: {
            args: Prisma.FollowupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowupPayload>[]
          }
          create: {
            args: Prisma.FollowupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowupPayload>
          }
          createMany: {
            args: Prisma.FollowupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FollowupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowupPayload>
          }
          update: {
            args: Prisma.FollowupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowupPayload>
          }
          deleteMany: {
            args: Prisma.FollowupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FollowupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FollowupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowupPayload>
          }
          aggregate: {
            args: Prisma.FollowupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFollowup>
          }
          groupBy: {
            args: Prisma.FollowupGroupByArgs<ExtArgs>
            result: $Utils.Optional<FollowupGroupByOutputType>[]
          }
          count: {
            args: Prisma.FollowupCountArgs<ExtArgs>
            result: $Utils.Optional<FollowupCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      ContactFollowup: {
        payload: Prisma.$ContactFollowupPayload<ExtArgs>
        fields: Prisma.ContactFollowupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFollowupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFollowupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFollowupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFollowupPayload>
          }
          findFirst: {
            args: Prisma.ContactFollowupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFollowupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFollowupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFollowupPayload>
          }
          findMany: {
            args: Prisma.ContactFollowupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFollowupPayload>[]
          }
          create: {
            args: Prisma.ContactFollowupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFollowupPayload>
          }
          createMany: {
            args: Prisma.ContactFollowupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContactFollowupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFollowupPayload>
          }
          update: {
            args: Prisma.ContactFollowupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFollowupPayload>
          }
          deleteMany: {
            args: Prisma.ContactFollowupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactFollowupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContactFollowupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFollowupPayload>
          }
          aggregate: {
            args: Prisma.ContactFollowupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactFollowup>
          }
          groupBy: {
            args: Prisma.ContactFollowupGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactFollowupGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactFollowupCountArgs<ExtArgs>
            result: $Utils.Optional<ContactFollowupCountAggregateOutputType> | number
          }
        }
      }
      RequestUser: {
        payload: Prisma.$RequestUserPayload<ExtArgs>
        fields: Prisma.RequestUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RequestUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RequestUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestUserPayload>
          }
          findFirst: {
            args: Prisma.RequestUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RequestUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestUserPayload>
          }
          findMany: {
            args: Prisma.RequestUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestUserPayload>[]
          }
          create: {
            args: Prisma.RequestUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestUserPayload>
          }
          createMany: {
            args: Prisma.RequestUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RequestUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestUserPayload>
          }
          update: {
            args: Prisma.RequestUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestUserPayload>
          }
          deleteMany: {
            args: Prisma.RequestUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RequestUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RequestUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequestUserPayload>
          }
          aggregate: {
            args: Prisma.RequestUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRequestUser>
          }
          groupBy: {
            args: Prisma.RequestUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<RequestUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.RequestUserCountArgs<ExtArgs>
            result: $Utils.Optional<RequestUserCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    admin?: AdminOmit
    campaign?: CampaignOmit
    type?: TypeOmit
    subType?: SubTypeOmit
    contactCampaign?: ContactCampaignOmit
    contactType?: ContactTypeOmit
    city?: CityOmit
    location?: LocationOmit
    facility?: FacilityOmit
    amenity?: AmenityOmit
    functionalArea?: FunctionalAreaOmit
    industry?: IndustryOmit
    reference?: ReferenceOmit
    expense?: ExpenseOmit
    income?: IncomeOmit
    statusType?: StatusTypeOmit
    contactStatusType?: ContactStatusTypeOmit
    paymentMethod?: PaymentMethodOmit
    template?: TemplateOmit
    incomeMarketing?: IncomeMarketingOmit
    expenseMarketing?: ExpenseMarketingOmit
    task?: TaskOmit
    schedule?: ScheduleOmit
    companyProject?: CompanyProjectOmit
    builderSlider?: BuilderSliderOmit
    customer?: CustomerOmit
    followup?: FollowupOmit
    contact?: ContactOmit
    contactFollowup?: ContactFollowupOmit
    requestUser?: RequestUserOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AdminCountOutputType
   */

  export type AdminCountOutputType = {
    createdAdmins: number
    assignedCustomers: number
    createdCustomers: number
    assignedContact: number
  }

  export type AdminCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdAdmins?: boolean | AdminCountOutputTypeCountCreatedAdminsArgs
    assignedCustomers?: boolean | AdminCountOutputTypeCountAssignedCustomersArgs
    createdCustomers?: boolean | AdminCountOutputTypeCountCreatedCustomersArgs
    assignedContact?: boolean | AdminCountOutputTypeCountAssignedContactArgs
  }

  // Custom InputTypes
  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCountOutputType
     */
    select?: AdminCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountCreatedAdminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountAssignedCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountCreatedCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountAssignedContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }


  /**
   * Count Type CampaignCountOutputType
   */

  export type CampaignCountOutputType = {
    types: number
    subTypes: number
  }

  export type CampaignCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    types?: boolean | CampaignCountOutputTypeCountTypesArgs
    subTypes?: boolean | CampaignCountOutputTypeCountSubTypesArgs
  }

  // Custom InputTypes
  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignCountOutputType
     */
    select?: CampaignCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TypeWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountSubTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubTypeWhereInput
  }


  /**
   * Count Type TypeCountOutputType
   */

  export type TypeCountOutputType = {
    subTypes: number
  }

  export type TypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subTypes?: boolean | TypeCountOutputTypeCountSubTypesArgs
  }

  // Custom InputTypes
  /**
   * TypeCountOutputType without action
   */
  export type TypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeCountOutputType
     */
    select?: TypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TypeCountOutputType without action
   */
  export type TypeCountOutputTypeCountSubTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubTypeWhereInput
  }


  /**
   * Count Type ContactCampaignCountOutputType
   */

  export type ContactCampaignCountOutputType = {
    contactTypes: number
  }

  export type ContactCampaignCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contactTypes?: boolean | ContactCampaignCountOutputTypeCountContactTypesArgs
  }

  // Custom InputTypes
  /**
   * ContactCampaignCountOutputType without action
   */
  export type ContactCampaignCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCampaignCountOutputType
     */
    select?: ContactCampaignCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContactCampaignCountOutputType without action
   */
  export type ContactCampaignCountOutputTypeCountContactTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactTypeWhereInput
  }


  /**
   * Count Type CityCountOutputType
   */

  export type CityCountOutputType = {
    locations: number
  }

  export type CityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locations?: boolean | CityCountOutputTypeCountLocationsArgs
  }

  // Custom InputTypes
  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CityCountOutputType
     */
    select?: CityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    followups: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    followups?: boolean | CustomerCountOutputTypeCountFollowupsArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountFollowupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowupWhereInput
  }


  /**
   * Count Type ContactCountOutputType
   */

  export type ContactCountOutputType = {
    followups: number
    contactFollowups: number
  }

  export type ContactCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    followups?: boolean | ContactCountOutputTypeCountFollowupsArgs
    contactFollowups?: boolean | ContactCountOutputTypeCountContactFollowupsArgs
  }

  // Custom InputTypes
  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCountOutputType
     */
    select?: ContactCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountFollowupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowupWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountContactFollowupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactFollowupWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    role: $Enums.Role | null
    city: string | null
    phone: string | null
    status: $Enums.AdminStatus | null
    AddressLine1: string | null
    AddressLine2: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    role: $Enums.Role | null
    city: string | null
    phone: string | null
    status: $Enums.AdminStatus | null
    AddressLine1: string | null
    AddressLine2: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    role: number
    city: number
    phone: number
    status: number
    AddressLine1: number
    AddressLine2: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    city?: true
    phone?: true
    status?: true
    AddressLine1?: true
    AddressLine2?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    city?: true
    phone?: true
    status?: true
    AddressLine1?: true
    AddressLine2?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    city?: true
    phone?: true
    status?: true
    AddressLine1?: true
    AddressLine2?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: string
    name: string
    email: string
    password: string
    role: $Enums.Role
    city: string | null
    phone: string | null
    status: $Enums.AdminStatus
    AddressLine1: string | null
    AddressLine2: string | null
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    city?: boolean
    phone?: boolean
    status?: boolean
    AddressLine1?: boolean
    AddressLine2?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdByRef?: boolean | Admin$createdByRefArgs<ExtArgs>
    createdAdmins?: boolean | Admin$createdAdminsArgs<ExtArgs>
    assignedCustomers?: boolean | Admin$assignedCustomersArgs<ExtArgs>
    createdCustomers?: boolean | Admin$createdCustomersArgs<ExtArgs>
    assignedContact?: boolean | Admin$assignedContactArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>



  export type AdminSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    city?: boolean
    phone?: boolean
    status?: boolean
    AddressLine1?: boolean
    AddressLine2?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "password" | "role" | "city" | "phone" | "status" | "AddressLine1" | "AddressLine2" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["admin"]>
  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByRef?: boolean | Admin$createdByRefArgs<ExtArgs>
    createdAdmins?: boolean | Admin$createdAdminsArgs<ExtArgs>
    assignedCustomers?: boolean | Admin$assignedCustomersArgs<ExtArgs>
    createdCustomers?: boolean | Admin$createdCustomersArgs<ExtArgs>
    assignedContact?: boolean | Admin$assignedContactArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      createdByRef: Prisma.$AdminPayload<ExtArgs> | null
      createdAdmins: Prisma.$AdminPayload<ExtArgs>[]
      assignedCustomers: Prisma.$CustomerPayload<ExtArgs>[]
      createdCustomers: Prisma.$CustomerPayload<ExtArgs>[]
      assignedContact: Prisma.$ContactPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      password: string
      role: $Enums.Role
      city: string | null
      phone: string | null
      status: $Enums.AdminStatus
      AddressLine1: string | null
      AddressLine2: string | null
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdByRef<T extends Admin$createdByRefArgs<ExtArgs> = {}>(args?: Subset<T, Admin$createdByRefArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdAdmins<T extends Admin$createdAdminsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$createdAdminsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedCustomers<T extends Admin$assignedCustomersArgs<ExtArgs> = {}>(args?: Subset<T, Admin$assignedCustomersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdCustomers<T extends Admin$createdCustomersArgs<ExtArgs> = {}>(args?: Subset<T, Admin$createdCustomersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedContact<T extends Admin$assignedContactArgs<ExtArgs> = {}>(args?: Subset<T, Admin$assignedContactArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'String'>
    readonly name: FieldRef<"Admin", 'String'>
    readonly email: FieldRef<"Admin", 'String'>
    readonly password: FieldRef<"Admin", 'String'>
    readonly role: FieldRef<"Admin", 'Role'>
    readonly city: FieldRef<"Admin", 'String'>
    readonly phone: FieldRef<"Admin", 'String'>
    readonly status: FieldRef<"Admin", 'AdminStatus'>
    readonly AddressLine1: FieldRef<"Admin", 'String'>
    readonly AddressLine2: FieldRef<"Admin", 'String'>
    readonly createdBy: FieldRef<"Admin", 'String'>
    readonly createdAt: FieldRef<"Admin", 'DateTime'>
    readonly updatedAt: FieldRef<"Admin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to delete.
     */
    limit?: number
  }

  /**
   * Admin.createdByRef
   */
  export type Admin$createdByRefArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * Admin.createdAdmins
   */
  export type Admin$createdAdminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    cursor?: AdminWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin.assignedCustomers
   */
  export type Admin$assignedCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Admin.createdCustomers
   */
  export type Admin$createdCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Admin.assignedContact
   */
  export type Admin$assignedContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
  }


  /**
   * Model Campaign
   */

  export type AggregateCampaign = {
    _count: CampaignCountAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  export type CampaignMinAggregateOutputType = {
    id: string | null
    Name: string | null
    Status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignMaxAggregateOutputType = {
    id: string | null
    Name: string | null
    Status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignCountAggregateOutputType = {
    id: number
    Name: number
    Status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CampaignMinAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignMaxAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignCountAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaign to aggregate.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Campaigns
    **/
    _count?: true | CampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMaxAggregateInputType
  }

  export type GetCampaignAggregateType<T extends CampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign[P]>
      : GetScalarType<T[P], AggregateCampaign[P]>
  }




  export type CampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithAggregationInput | CampaignOrderByWithAggregationInput[]
    by: CampaignScalarFieldEnum[] | CampaignScalarFieldEnum
    having?: CampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignCountAggregateInputType | true
    _min?: CampaignMinAggregateInputType
    _max?: CampaignMaxAggregateInputType
  }

  export type CampaignGroupByOutputType = {
    id: string
    Name: string
    Status: $Enums.Status
    createdAt: Date
    updatedAt: Date
    _count: CampaignCountAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  type GetCampaignGroupByPayload<T extends CampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignGroupByOutputType[P]>
        }
      >
    >


  export type CampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Name?: boolean
    Status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    types?: boolean | Campaign$typesArgs<ExtArgs>
    subTypes?: boolean | Campaign$subTypesArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>



  export type CampaignSelectScalar = {
    id?: boolean
    Name?: boolean
    Status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CampaignOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "Name" | "Status" | "createdAt" | "updatedAt", ExtArgs["result"]["campaign"]>
  export type CampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    types?: boolean | Campaign$typesArgs<ExtArgs>
    subTypes?: boolean | Campaign$subTypesArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Campaign"
    objects: {
      types: Prisma.$TypePayload<ExtArgs>[]
      subTypes: Prisma.$SubTypePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      Name: string
      Status: $Enums.Status
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["campaign"]>
    composites: {}
  }

  type CampaignGetPayload<S extends boolean | null | undefined | CampaignDefaultArgs> = $Result.GetResult<Prisma.$CampaignPayload, S>

  type CampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CampaignFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CampaignCountAggregateInputType | true
    }

  export interface CampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Campaign'], meta: { name: 'Campaign' } }
    /**
     * Find zero or one Campaign that matches the filter.
     * @param {CampaignFindUniqueArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignFindUniqueArgs>(args: SelectSubset<T, CampaignFindUniqueArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Campaign that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CampaignFindUniqueOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Campaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignFindFirstArgs>(args?: SelectSubset<T, CampaignFindFirstArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Campaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaigns
     * const campaigns = await prisma.campaign.findMany()
     * 
     * // Get first 10 Campaigns
     * const campaigns = await prisma.campaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignWithIdOnly = await prisma.campaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignFindManyArgs>(args?: SelectSubset<T, CampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Campaign.
     * @param {CampaignCreateArgs} args - Arguments to create a Campaign.
     * @example
     * // Create one Campaign
     * const Campaign = await prisma.campaign.create({
     *   data: {
     *     // ... data to create a Campaign
     *   }
     * })
     * 
     */
    create<T extends CampaignCreateArgs>(args: SelectSubset<T, CampaignCreateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Campaigns.
     * @param {CampaignCreateManyArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignCreateManyArgs>(args?: SelectSubset<T, CampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Campaign.
     * @param {CampaignDeleteArgs} args - Arguments to delete one Campaign.
     * @example
     * // Delete one Campaign
     * const Campaign = await prisma.campaign.delete({
     *   where: {
     *     // ... filter to delete one Campaign
     *   }
     * })
     * 
     */
    delete<T extends CampaignDeleteArgs>(args: SelectSubset<T, CampaignDeleteArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Campaign.
     * @param {CampaignUpdateArgs} args - Arguments to update one Campaign.
     * @example
     * // Update one Campaign
     * const campaign = await prisma.campaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignUpdateArgs>(args: SelectSubset<T, CampaignUpdateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Campaigns.
     * @param {CampaignDeleteManyArgs} args - Arguments to filter Campaigns to delete.
     * @example
     * // Delete a few Campaigns
     * const { count } = await prisma.campaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignDeleteManyArgs>(args?: SelectSubset<T, CampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignUpdateManyArgs>(args: SelectSubset<T, CampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Campaign.
     * @param {CampaignUpsertArgs} args - Arguments to update or create a Campaign.
     * @example
     * // Update or create a Campaign
     * const campaign = await prisma.campaign.upsert({
     *   create: {
     *     // ... data to create a Campaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign we want to update
     *   }
     * })
     */
    upsert<T extends CampaignUpsertArgs>(args: SelectSubset<T, CampaignUpsertArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCountArgs} args - Arguments to filter Campaigns to count.
     * @example
     * // Count the number of Campaigns
     * const count = await prisma.campaign.count({
     *   where: {
     *     // ... the filter for the Campaigns we want to count
     *   }
     * })
    **/
    count<T extends CampaignCountArgs>(
      args?: Subset<T, CampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignAggregateArgs>(args: Subset<T, CampaignAggregateArgs>): Prisma.PrismaPromise<GetCampaignAggregateType<T>>

    /**
     * Group by Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignGroupByArgs['orderBy'] }
        : { orderBy?: CampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Campaign model
   */
  readonly fields: CampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Campaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    types<T extends Campaign$typesArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$typesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subTypes<T extends Campaign$subTypesArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$subTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Campaign model
   */
  interface CampaignFieldRefs {
    readonly id: FieldRef<"Campaign", 'String'>
    readonly Name: FieldRef<"Campaign", 'String'>
    readonly Status: FieldRef<"Campaign", 'Status'>
    readonly createdAt: FieldRef<"Campaign", 'DateTime'>
    readonly updatedAt: FieldRef<"Campaign", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Campaign findUnique
   */
  export type CampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findUniqueOrThrow
   */
  export type CampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findFirst
   */
  export type CampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findFirstOrThrow
   */
  export type CampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findMany
   */
  export type CampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaigns to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign create
   */
  export type CampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a Campaign.
     */
    data: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
  }

  /**
   * Campaign createMany
   */
  export type CampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Campaign update
   */
  export type CampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a Campaign.
     */
    data: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
    /**
     * Choose, which Campaign to update.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign updateMany
   */
  export type CampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
    /**
     * Limit how many Campaigns to update.
     */
    limit?: number
  }

  /**
   * Campaign upsert
   */
  export type CampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the Campaign to update in case it exists.
     */
    where: CampaignWhereUniqueInput
    /**
     * In case the Campaign found by the `where` argument doesn't exist, create a new Campaign with this data.
     */
    create: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
    /**
     * In case the Campaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
  }

  /**
   * Campaign delete
   */
  export type CampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter which Campaign to delete.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign deleteMany
   */
  export type CampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaigns to delete
     */
    where?: CampaignWhereInput
    /**
     * Limit how many Campaigns to delete.
     */
    limit?: number
  }

  /**
   * Campaign.types
   */
  export type Campaign$typesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
    where?: TypeWhereInput
    orderBy?: TypeOrderByWithRelationInput | TypeOrderByWithRelationInput[]
    cursor?: TypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TypeScalarFieldEnum | TypeScalarFieldEnum[]
  }

  /**
   * Campaign.subTypes
   */
  export type Campaign$subTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubType
     */
    select?: SubTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubType
     */
    omit?: SubTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubTypeInclude<ExtArgs> | null
    where?: SubTypeWhereInput
    orderBy?: SubTypeOrderByWithRelationInput | SubTypeOrderByWithRelationInput[]
    cursor?: SubTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubTypeScalarFieldEnum | SubTypeScalarFieldEnum[]
  }

  /**
   * Campaign without action
   */
  export type CampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
  }


  /**
   * Model Type
   */

  export type AggregateType = {
    _count: TypeCountAggregateOutputType | null
    _min: TypeMinAggregateOutputType | null
    _max: TypeMaxAggregateOutputType | null
  }

  export type TypeMinAggregateOutputType = {
    id: string | null
    Name: string | null
    Status: $Enums.Status | null
    campaignId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TypeMaxAggregateOutputType = {
    id: string | null
    Name: string | null
    Status: $Enums.Status | null
    campaignId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TypeCountAggregateOutputType = {
    id: number
    Name: number
    Status: number
    campaignId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TypeMinAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    campaignId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TypeMaxAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    campaignId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TypeCountAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    campaignId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Type to aggregate.
     */
    where?: TypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Types to fetch.
     */
    orderBy?: TypeOrderByWithRelationInput | TypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Types
    **/
    _count?: true | TypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TypeMaxAggregateInputType
  }

  export type GetTypeAggregateType<T extends TypeAggregateArgs> = {
        [P in keyof T & keyof AggregateType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateType[P]>
      : GetScalarType<T[P], AggregateType[P]>
  }




  export type TypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TypeWhereInput
    orderBy?: TypeOrderByWithAggregationInput | TypeOrderByWithAggregationInput[]
    by: TypeScalarFieldEnum[] | TypeScalarFieldEnum
    having?: TypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TypeCountAggregateInputType | true
    _min?: TypeMinAggregateInputType
    _max?: TypeMaxAggregateInputType
  }

  export type TypeGroupByOutputType = {
    id: string
    Name: string
    Status: $Enums.Status
    campaignId: string
    createdAt: Date
    updatedAt: Date
    _count: TypeCountAggregateOutputType | null
    _min: TypeMinAggregateOutputType | null
    _max: TypeMaxAggregateOutputType | null
  }

  type GetTypeGroupByPayload<T extends TypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TypeGroupByOutputType[P]>
            : GetScalarType<T[P], TypeGroupByOutputType[P]>
        }
      >
    >


  export type TypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Name?: boolean
    Status?: boolean
    campaignId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    subTypes?: boolean | Type$subTypesArgs<ExtArgs>
    _count?: boolean | TypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["type"]>



  export type TypeSelectScalar = {
    id?: boolean
    Name?: boolean
    Status?: boolean
    campaignId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "Name" | "Status" | "campaignId" | "createdAt" | "updatedAt", ExtArgs["result"]["type"]>
  export type TypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    subTypes?: boolean | Type$subTypesArgs<ExtArgs>
    _count?: boolean | TypeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Type"
    objects: {
      Campaign: Prisma.$CampaignPayload<ExtArgs>
      subTypes: Prisma.$SubTypePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      Name: string
      Status: $Enums.Status
      campaignId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["type"]>
    composites: {}
  }

  type TypeGetPayload<S extends boolean | null | undefined | TypeDefaultArgs> = $Result.GetResult<Prisma.$TypePayload, S>

  type TypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TypeCountAggregateInputType | true
    }

  export interface TypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Type'], meta: { name: 'Type' } }
    /**
     * Find zero or one Type that matches the filter.
     * @param {TypeFindUniqueArgs} args - Arguments to find a Type
     * @example
     * // Get one Type
     * const type = await prisma.type.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TypeFindUniqueArgs>(args: SelectSubset<T, TypeFindUniqueArgs<ExtArgs>>): Prisma__TypeClient<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Type that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TypeFindUniqueOrThrowArgs} args - Arguments to find a Type
     * @example
     * // Get one Type
     * const type = await prisma.type.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TypeFindUniqueOrThrowArgs>(args: SelectSubset<T, TypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TypeClient<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Type that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeFindFirstArgs} args - Arguments to find a Type
     * @example
     * // Get one Type
     * const type = await prisma.type.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TypeFindFirstArgs>(args?: SelectSubset<T, TypeFindFirstArgs<ExtArgs>>): Prisma__TypeClient<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Type that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeFindFirstOrThrowArgs} args - Arguments to find a Type
     * @example
     * // Get one Type
     * const type = await prisma.type.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TypeFindFirstOrThrowArgs>(args?: SelectSubset<T, TypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__TypeClient<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Types
     * const types = await prisma.type.findMany()
     * 
     * // Get first 10 Types
     * const types = await prisma.type.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const typeWithIdOnly = await prisma.type.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TypeFindManyArgs>(args?: SelectSubset<T, TypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Type.
     * @param {TypeCreateArgs} args - Arguments to create a Type.
     * @example
     * // Create one Type
     * const Type = await prisma.type.create({
     *   data: {
     *     // ... data to create a Type
     *   }
     * })
     * 
     */
    create<T extends TypeCreateArgs>(args: SelectSubset<T, TypeCreateArgs<ExtArgs>>): Prisma__TypeClient<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Types.
     * @param {TypeCreateManyArgs} args - Arguments to create many Types.
     * @example
     * // Create many Types
     * const type = await prisma.type.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TypeCreateManyArgs>(args?: SelectSubset<T, TypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Type.
     * @param {TypeDeleteArgs} args - Arguments to delete one Type.
     * @example
     * // Delete one Type
     * const Type = await prisma.type.delete({
     *   where: {
     *     // ... filter to delete one Type
     *   }
     * })
     * 
     */
    delete<T extends TypeDeleteArgs>(args: SelectSubset<T, TypeDeleteArgs<ExtArgs>>): Prisma__TypeClient<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Type.
     * @param {TypeUpdateArgs} args - Arguments to update one Type.
     * @example
     * // Update one Type
     * const type = await prisma.type.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TypeUpdateArgs>(args: SelectSubset<T, TypeUpdateArgs<ExtArgs>>): Prisma__TypeClient<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Types.
     * @param {TypeDeleteManyArgs} args - Arguments to filter Types to delete.
     * @example
     * // Delete a few Types
     * const { count } = await prisma.type.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TypeDeleteManyArgs>(args?: SelectSubset<T, TypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Types
     * const type = await prisma.type.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TypeUpdateManyArgs>(args: SelectSubset<T, TypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Type.
     * @param {TypeUpsertArgs} args - Arguments to update or create a Type.
     * @example
     * // Update or create a Type
     * const type = await prisma.type.upsert({
     *   create: {
     *     // ... data to create a Type
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Type we want to update
     *   }
     * })
     */
    upsert<T extends TypeUpsertArgs>(args: SelectSubset<T, TypeUpsertArgs<ExtArgs>>): Prisma__TypeClient<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeCountArgs} args - Arguments to filter Types to count.
     * @example
     * // Count the number of Types
     * const count = await prisma.type.count({
     *   where: {
     *     // ... the filter for the Types we want to count
     *   }
     * })
    **/
    count<T extends TypeCountArgs>(
      args?: Subset<T, TypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TypeAggregateArgs>(args: Subset<T, TypeAggregateArgs>): Prisma.PrismaPromise<GetTypeAggregateType<T>>

    /**
     * Group by Type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TypeGroupByArgs['orderBy'] }
        : { orderBy?: TypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Type model
   */
  readonly fields: TypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Type.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subTypes<T extends Type$subTypesArgs<ExtArgs> = {}>(args?: Subset<T, Type$subTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Type model
   */
  interface TypeFieldRefs {
    readonly id: FieldRef<"Type", 'String'>
    readonly Name: FieldRef<"Type", 'String'>
    readonly Status: FieldRef<"Type", 'Status'>
    readonly campaignId: FieldRef<"Type", 'String'>
    readonly createdAt: FieldRef<"Type", 'DateTime'>
    readonly updatedAt: FieldRef<"Type", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Type findUnique
   */
  export type TypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
    /**
     * Filter, which Type to fetch.
     */
    where: TypeWhereUniqueInput
  }

  /**
   * Type findUniqueOrThrow
   */
  export type TypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
    /**
     * Filter, which Type to fetch.
     */
    where: TypeWhereUniqueInput
  }

  /**
   * Type findFirst
   */
  export type TypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
    /**
     * Filter, which Type to fetch.
     */
    where?: TypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Types to fetch.
     */
    orderBy?: TypeOrderByWithRelationInput | TypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Types.
     */
    cursor?: TypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Types.
     */
    distinct?: TypeScalarFieldEnum | TypeScalarFieldEnum[]
  }

  /**
   * Type findFirstOrThrow
   */
  export type TypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
    /**
     * Filter, which Type to fetch.
     */
    where?: TypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Types to fetch.
     */
    orderBy?: TypeOrderByWithRelationInput | TypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Types.
     */
    cursor?: TypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Types.
     */
    distinct?: TypeScalarFieldEnum | TypeScalarFieldEnum[]
  }

  /**
   * Type findMany
   */
  export type TypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
    /**
     * Filter, which Types to fetch.
     */
    where?: TypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Types to fetch.
     */
    orderBy?: TypeOrderByWithRelationInput | TypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Types.
     */
    cursor?: TypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Types.
     */
    skip?: number
    distinct?: TypeScalarFieldEnum | TypeScalarFieldEnum[]
  }

  /**
   * Type create
   */
  export type TypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
    /**
     * The data needed to create a Type.
     */
    data: XOR<TypeCreateInput, TypeUncheckedCreateInput>
  }

  /**
   * Type createMany
   */
  export type TypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Types.
     */
    data: TypeCreateManyInput | TypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Type update
   */
  export type TypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
    /**
     * The data needed to update a Type.
     */
    data: XOR<TypeUpdateInput, TypeUncheckedUpdateInput>
    /**
     * Choose, which Type to update.
     */
    where: TypeWhereUniqueInput
  }

  /**
   * Type updateMany
   */
  export type TypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Types.
     */
    data: XOR<TypeUpdateManyMutationInput, TypeUncheckedUpdateManyInput>
    /**
     * Filter which Types to update
     */
    where?: TypeWhereInput
    /**
     * Limit how many Types to update.
     */
    limit?: number
  }

  /**
   * Type upsert
   */
  export type TypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
    /**
     * The filter to search for the Type to update in case it exists.
     */
    where: TypeWhereUniqueInput
    /**
     * In case the Type found by the `where` argument doesn't exist, create a new Type with this data.
     */
    create: XOR<TypeCreateInput, TypeUncheckedCreateInput>
    /**
     * In case the Type was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TypeUpdateInput, TypeUncheckedUpdateInput>
  }

  /**
   * Type delete
   */
  export type TypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
    /**
     * Filter which Type to delete.
     */
    where: TypeWhereUniqueInput
  }

  /**
   * Type deleteMany
   */
  export type TypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Types to delete
     */
    where?: TypeWhereInput
    /**
     * Limit how many Types to delete.
     */
    limit?: number
  }

  /**
   * Type.subTypes
   */
  export type Type$subTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubType
     */
    select?: SubTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubType
     */
    omit?: SubTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubTypeInclude<ExtArgs> | null
    where?: SubTypeWhereInput
    orderBy?: SubTypeOrderByWithRelationInput | SubTypeOrderByWithRelationInput[]
    cursor?: SubTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubTypeScalarFieldEnum | SubTypeScalarFieldEnum[]
  }

  /**
   * Type without action
   */
  export type TypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
  }


  /**
   * Model SubType
   */

  export type AggregateSubType = {
    _count: SubTypeCountAggregateOutputType | null
    _min: SubTypeMinAggregateOutputType | null
    _max: SubTypeMaxAggregateOutputType | null
  }

  export type SubTypeMinAggregateOutputType = {
    id: string | null
    Name: string | null
    Status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    campaignId: string | null
    customerTypeId: string | null
  }

  export type SubTypeMaxAggregateOutputType = {
    id: string | null
    Name: string | null
    Status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    campaignId: string | null
    customerTypeId: string | null
  }

  export type SubTypeCountAggregateOutputType = {
    id: number
    Name: number
    Status: number
    createdAt: number
    updatedAt: number
    campaignId: number
    customerTypeId: number
    _all: number
  }


  export type SubTypeMinAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
    campaignId?: true
    customerTypeId?: true
  }

  export type SubTypeMaxAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
    campaignId?: true
    customerTypeId?: true
  }

  export type SubTypeCountAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
    campaignId?: true
    customerTypeId?: true
    _all?: true
  }

  export type SubTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubType to aggregate.
     */
    where?: SubTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubTypes to fetch.
     */
    orderBy?: SubTypeOrderByWithRelationInput | SubTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubTypes
    **/
    _count?: true | SubTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubTypeMaxAggregateInputType
  }

  export type GetSubTypeAggregateType<T extends SubTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateSubType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubType[P]>
      : GetScalarType<T[P], AggregateSubType[P]>
  }




  export type SubTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubTypeWhereInput
    orderBy?: SubTypeOrderByWithAggregationInput | SubTypeOrderByWithAggregationInput[]
    by: SubTypeScalarFieldEnum[] | SubTypeScalarFieldEnum
    having?: SubTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubTypeCountAggregateInputType | true
    _min?: SubTypeMinAggregateInputType
    _max?: SubTypeMaxAggregateInputType
  }

  export type SubTypeGroupByOutputType = {
    id: string
    Name: string
    Status: string
    createdAt: Date
    updatedAt: Date
    campaignId: string
    customerTypeId: string
    _count: SubTypeCountAggregateOutputType | null
    _min: SubTypeMinAggregateOutputType | null
    _max: SubTypeMaxAggregateOutputType | null
  }

  type GetSubTypeGroupByPayload<T extends SubTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubTypeGroupByOutputType[P]>
            : GetScalarType<T[P], SubTypeGroupByOutputType[P]>
        }
      >
    >


  export type SubTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Name?: boolean
    Status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaignId?: boolean
    customerTypeId?: boolean
    Campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    CustomerType?: boolean | TypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subType"]>



  export type SubTypeSelectScalar = {
    id?: boolean
    Name?: boolean
    Status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaignId?: boolean
    customerTypeId?: boolean
  }

  export type SubTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "Name" | "Status" | "createdAt" | "updatedAt" | "campaignId" | "customerTypeId", ExtArgs["result"]["subType"]>
  export type SubTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    CustomerType?: boolean | TypeDefaultArgs<ExtArgs>
  }

  export type $SubTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubType"
    objects: {
      Campaign: Prisma.$CampaignPayload<ExtArgs>
      CustomerType: Prisma.$TypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      Name: string
      Status: string
      createdAt: Date
      updatedAt: Date
      campaignId: string
      customerTypeId: string
    }, ExtArgs["result"]["subType"]>
    composites: {}
  }

  type SubTypeGetPayload<S extends boolean | null | undefined | SubTypeDefaultArgs> = $Result.GetResult<Prisma.$SubTypePayload, S>

  type SubTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubTypeCountAggregateInputType | true
    }

  export interface SubTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubType'], meta: { name: 'SubType' } }
    /**
     * Find zero or one SubType that matches the filter.
     * @param {SubTypeFindUniqueArgs} args - Arguments to find a SubType
     * @example
     * // Get one SubType
     * const subType = await prisma.subType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubTypeFindUniqueArgs>(args: SelectSubset<T, SubTypeFindUniqueArgs<ExtArgs>>): Prisma__SubTypeClient<$Result.GetResult<Prisma.$SubTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubTypeFindUniqueOrThrowArgs} args - Arguments to find a SubType
     * @example
     * // Get one SubType
     * const subType = await prisma.subType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, SubTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubTypeClient<$Result.GetResult<Prisma.$SubTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubTypeFindFirstArgs} args - Arguments to find a SubType
     * @example
     * // Get one SubType
     * const subType = await prisma.subType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubTypeFindFirstArgs>(args?: SelectSubset<T, SubTypeFindFirstArgs<ExtArgs>>): Prisma__SubTypeClient<$Result.GetResult<Prisma.$SubTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubTypeFindFirstOrThrowArgs} args - Arguments to find a SubType
     * @example
     * // Get one SubType
     * const subType = await prisma.subType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, SubTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubTypeClient<$Result.GetResult<Prisma.$SubTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubTypes
     * const subTypes = await prisma.subType.findMany()
     * 
     * // Get first 10 SubTypes
     * const subTypes = await prisma.subType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subTypeWithIdOnly = await prisma.subType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubTypeFindManyArgs>(args?: SelectSubset<T, SubTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubType.
     * @param {SubTypeCreateArgs} args - Arguments to create a SubType.
     * @example
     * // Create one SubType
     * const SubType = await prisma.subType.create({
     *   data: {
     *     // ... data to create a SubType
     *   }
     * })
     * 
     */
    create<T extends SubTypeCreateArgs>(args: SelectSubset<T, SubTypeCreateArgs<ExtArgs>>): Prisma__SubTypeClient<$Result.GetResult<Prisma.$SubTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubTypes.
     * @param {SubTypeCreateManyArgs} args - Arguments to create many SubTypes.
     * @example
     * // Create many SubTypes
     * const subType = await prisma.subType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubTypeCreateManyArgs>(args?: SelectSubset<T, SubTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SubType.
     * @param {SubTypeDeleteArgs} args - Arguments to delete one SubType.
     * @example
     * // Delete one SubType
     * const SubType = await prisma.subType.delete({
     *   where: {
     *     // ... filter to delete one SubType
     *   }
     * })
     * 
     */
    delete<T extends SubTypeDeleteArgs>(args: SelectSubset<T, SubTypeDeleteArgs<ExtArgs>>): Prisma__SubTypeClient<$Result.GetResult<Prisma.$SubTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubType.
     * @param {SubTypeUpdateArgs} args - Arguments to update one SubType.
     * @example
     * // Update one SubType
     * const subType = await prisma.subType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubTypeUpdateArgs>(args: SelectSubset<T, SubTypeUpdateArgs<ExtArgs>>): Prisma__SubTypeClient<$Result.GetResult<Prisma.$SubTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubTypes.
     * @param {SubTypeDeleteManyArgs} args - Arguments to filter SubTypes to delete.
     * @example
     * // Delete a few SubTypes
     * const { count } = await prisma.subType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubTypeDeleteManyArgs>(args?: SelectSubset<T, SubTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubTypes
     * const subType = await prisma.subType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubTypeUpdateManyArgs>(args: SelectSubset<T, SubTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SubType.
     * @param {SubTypeUpsertArgs} args - Arguments to update or create a SubType.
     * @example
     * // Update or create a SubType
     * const subType = await prisma.subType.upsert({
     *   create: {
     *     // ... data to create a SubType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubType we want to update
     *   }
     * })
     */
    upsert<T extends SubTypeUpsertArgs>(args: SelectSubset<T, SubTypeUpsertArgs<ExtArgs>>): Prisma__SubTypeClient<$Result.GetResult<Prisma.$SubTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubTypeCountArgs} args - Arguments to filter SubTypes to count.
     * @example
     * // Count the number of SubTypes
     * const count = await prisma.subType.count({
     *   where: {
     *     // ... the filter for the SubTypes we want to count
     *   }
     * })
    **/
    count<T extends SubTypeCountArgs>(
      args?: Subset<T, SubTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubTypeAggregateArgs>(args: Subset<T, SubTypeAggregateArgs>): Prisma.PrismaPromise<GetSubTypeAggregateType<T>>

    /**
     * Group by SubType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubTypeGroupByArgs['orderBy'] }
        : { orderBy?: SubTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubType model
   */
  readonly fields: SubTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    CustomerType<T extends TypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TypeDefaultArgs<ExtArgs>>): Prisma__TypeClient<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubType model
   */
  interface SubTypeFieldRefs {
    readonly id: FieldRef<"SubType", 'String'>
    readonly Name: FieldRef<"SubType", 'String'>
    readonly Status: FieldRef<"SubType", 'String'>
    readonly createdAt: FieldRef<"SubType", 'DateTime'>
    readonly updatedAt: FieldRef<"SubType", 'DateTime'>
    readonly campaignId: FieldRef<"SubType", 'String'>
    readonly customerTypeId: FieldRef<"SubType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SubType findUnique
   */
  export type SubTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubType
     */
    select?: SubTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubType
     */
    omit?: SubTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubTypeInclude<ExtArgs> | null
    /**
     * Filter, which SubType to fetch.
     */
    where: SubTypeWhereUniqueInput
  }

  /**
   * SubType findUniqueOrThrow
   */
  export type SubTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubType
     */
    select?: SubTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubType
     */
    omit?: SubTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubTypeInclude<ExtArgs> | null
    /**
     * Filter, which SubType to fetch.
     */
    where: SubTypeWhereUniqueInput
  }

  /**
   * SubType findFirst
   */
  export type SubTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubType
     */
    select?: SubTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubType
     */
    omit?: SubTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubTypeInclude<ExtArgs> | null
    /**
     * Filter, which SubType to fetch.
     */
    where?: SubTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubTypes to fetch.
     */
    orderBy?: SubTypeOrderByWithRelationInput | SubTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubTypes.
     */
    cursor?: SubTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubTypes.
     */
    distinct?: SubTypeScalarFieldEnum | SubTypeScalarFieldEnum[]
  }

  /**
   * SubType findFirstOrThrow
   */
  export type SubTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubType
     */
    select?: SubTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubType
     */
    omit?: SubTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubTypeInclude<ExtArgs> | null
    /**
     * Filter, which SubType to fetch.
     */
    where?: SubTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubTypes to fetch.
     */
    orderBy?: SubTypeOrderByWithRelationInput | SubTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubTypes.
     */
    cursor?: SubTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubTypes.
     */
    distinct?: SubTypeScalarFieldEnum | SubTypeScalarFieldEnum[]
  }

  /**
   * SubType findMany
   */
  export type SubTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubType
     */
    select?: SubTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubType
     */
    omit?: SubTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubTypeInclude<ExtArgs> | null
    /**
     * Filter, which SubTypes to fetch.
     */
    where?: SubTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubTypes to fetch.
     */
    orderBy?: SubTypeOrderByWithRelationInput | SubTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubTypes.
     */
    cursor?: SubTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubTypes.
     */
    skip?: number
    distinct?: SubTypeScalarFieldEnum | SubTypeScalarFieldEnum[]
  }

  /**
   * SubType create
   */
  export type SubTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubType
     */
    select?: SubTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubType
     */
    omit?: SubTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a SubType.
     */
    data: XOR<SubTypeCreateInput, SubTypeUncheckedCreateInput>
  }

  /**
   * SubType createMany
   */
  export type SubTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubTypes.
     */
    data: SubTypeCreateManyInput | SubTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubType update
   */
  export type SubTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubType
     */
    select?: SubTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubType
     */
    omit?: SubTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a SubType.
     */
    data: XOR<SubTypeUpdateInput, SubTypeUncheckedUpdateInput>
    /**
     * Choose, which SubType to update.
     */
    where: SubTypeWhereUniqueInput
  }

  /**
   * SubType updateMany
   */
  export type SubTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubTypes.
     */
    data: XOR<SubTypeUpdateManyMutationInput, SubTypeUncheckedUpdateManyInput>
    /**
     * Filter which SubTypes to update
     */
    where?: SubTypeWhereInput
    /**
     * Limit how many SubTypes to update.
     */
    limit?: number
  }

  /**
   * SubType upsert
   */
  export type SubTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubType
     */
    select?: SubTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubType
     */
    omit?: SubTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the SubType to update in case it exists.
     */
    where: SubTypeWhereUniqueInput
    /**
     * In case the SubType found by the `where` argument doesn't exist, create a new SubType with this data.
     */
    create: XOR<SubTypeCreateInput, SubTypeUncheckedCreateInput>
    /**
     * In case the SubType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubTypeUpdateInput, SubTypeUncheckedUpdateInput>
  }

  /**
   * SubType delete
   */
  export type SubTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubType
     */
    select?: SubTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubType
     */
    omit?: SubTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubTypeInclude<ExtArgs> | null
    /**
     * Filter which SubType to delete.
     */
    where: SubTypeWhereUniqueInput
  }

  /**
   * SubType deleteMany
   */
  export type SubTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubTypes to delete
     */
    where?: SubTypeWhereInput
    /**
     * Limit how many SubTypes to delete.
     */
    limit?: number
  }

  /**
   * SubType without action
   */
  export type SubTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubType
     */
    select?: SubTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubType
     */
    omit?: SubTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubTypeInclude<ExtArgs> | null
  }


  /**
   * Model ContactCampaign
   */

  export type AggregateContactCampaign = {
    _count: ContactCampaignCountAggregateOutputType | null
    _min: ContactCampaignMinAggregateOutputType | null
    _max: ContactCampaignMaxAggregateOutputType | null
  }

  export type ContactCampaignMinAggregateOutputType = {
    id: string | null
    Name: string | null
    Status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactCampaignMaxAggregateOutputType = {
    id: string | null
    Name: string | null
    Status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactCampaignCountAggregateOutputType = {
    id: number
    Name: number
    Status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactCampaignMinAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactCampaignMaxAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactCampaignCountAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactCampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactCampaign to aggregate.
     */
    where?: ContactCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactCampaigns to fetch.
     */
    orderBy?: ContactCampaignOrderByWithRelationInput | ContactCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactCampaigns
    **/
    _count?: true | ContactCampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactCampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactCampaignMaxAggregateInputType
  }

  export type GetContactCampaignAggregateType<T extends ContactCampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateContactCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactCampaign[P]>
      : GetScalarType<T[P], AggregateContactCampaign[P]>
  }




  export type ContactCampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactCampaignWhereInput
    orderBy?: ContactCampaignOrderByWithAggregationInput | ContactCampaignOrderByWithAggregationInput[]
    by: ContactCampaignScalarFieldEnum[] | ContactCampaignScalarFieldEnum
    having?: ContactCampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCampaignCountAggregateInputType | true
    _min?: ContactCampaignMinAggregateInputType
    _max?: ContactCampaignMaxAggregateInputType
  }

  export type ContactCampaignGroupByOutputType = {
    id: string
    Name: string
    Status: $Enums.Status
    createdAt: Date
    updatedAt: Date
    _count: ContactCampaignCountAggregateOutputType | null
    _min: ContactCampaignMinAggregateOutputType | null
    _max: ContactCampaignMaxAggregateOutputType | null
  }

  type GetContactCampaignGroupByPayload<T extends ContactCampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactCampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactCampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactCampaignGroupByOutputType[P]>
            : GetScalarType<T[P], ContactCampaignGroupByOutputType[P]>
        }
      >
    >


  export type ContactCampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Name?: boolean
    Status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contactTypes?: boolean | ContactCampaign$contactTypesArgs<ExtArgs>
    _count?: boolean | ContactCampaignCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactCampaign"]>



  export type ContactCampaignSelectScalar = {
    id?: boolean
    Name?: boolean
    Status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactCampaignOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "Name" | "Status" | "createdAt" | "updatedAt", ExtArgs["result"]["contactCampaign"]>
  export type ContactCampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contactTypes?: boolean | ContactCampaign$contactTypesArgs<ExtArgs>
    _count?: boolean | ContactCampaignCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ContactCampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactCampaign"
    objects: {
      contactTypes: Prisma.$ContactTypePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      Name: string
      Status: $Enums.Status
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contactCampaign"]>
    composites: {}
  }

  type ContactCampaignGetPayload<S extends boolean | null | undefined | ContactCampaignDefaultArgs> = $Result.GetResult<Prisma.$ContactCampaignPayload, S>

  type ContactCampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactCampaignFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactCampaignCountAggregateInputType | true
    }

  export interface ContactCampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactCampaign'], meta: { name: 'ContactCampaign' } }
    /**
     * Find zero or one ContactCampaign that matches the filter.
     * @param {ContactCampaignFindUniqueArgs} args - Arguments to find a ContactCampaign
     * @example
     * // Get one ContactCampaign
     * const contactCampaign = await prisma.contactCampaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactCampaignFindUniqueArgs>(args: SelectSubset<T, ContactCampaignFindUniqueArgs<ExtArgs>>): Prisma__ContactCampaignClient<$Result.GetResult<Prisma.$ContactCampaignPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContactCampaign that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactCampaignFindUniqueOrThrowArgs} args - Arguments to find a ContactCampaign
     * @example
     * // Get one ContactCampaign
     * const contactCampaign = await prisma.contactCampaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactCampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactCampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactCampaignClient<$Result.GetResult<Prisma.$ContactCampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactCampaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCampaignFindFirstArgs} args - Arguments to find a ContactCampaign
     * @example
     * // Get one ContactCampaign
     * const contactCampaign = await prisma.contactCampaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactCampaignFindFirstArgs>(args?: SelectSubset<T, ContactCampaignFindFirstArgs<ExtArgs>>): Prisma__ContactCampaignClient<$Result.GetResult<Prisma.$ContactCampaignPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactCampaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCampaignFindFirstOrThrowArgs} args - Arguments to find a ContactCampaign
     * @example
     * // Get one ContactCampaign
     * const contactCampaign = await prisma.contactCampaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactCampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactCampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactCampaignClient<$Result.GetResult<Prisma.$ContactCampaignPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContactCampaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactCampaigns
     * const contactCampaigns = await prisma.contactCampaign.findMany()
     * 
     * // Get first 10 ContactCampaigns
     * const contactCampaigns = await prisma.contactCampaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactCampaignWithIdOnly = await prisma.contactCampaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactCampaignFindManyArgs>(args?: SelectSubset<T, ContactCampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactCampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContactCampaign.
     * @param {ContactCampaignCreateArgs} args - Arguments to create a ContactCampaign.
     * @example
     * // Create one ContactCampaign
     * const ContactCampaign = await prisma.contactCampaign.create({
     *   data: {
     *     // ... data to create a ContactCampaign
     *   }
     * })
     * 
     */
    create<T extends ContactCampaignCreateArgs>(args: SelectSubset<T, ContactCampaignCreateArgs<ExtArgs>>): Prisma__ContactCampaignClient<$Result.GetResult<Prisma.$ContactCampaignPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContactCampaigns.
     * @param {ContactCampaignCreateManyArgs} args - Arguments to create many ContactCampaigns.
     * @example
     * // Create many ContactCampaigns
     * const contactCampaign = await prisma.contactCampaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactCampaignCreateManyArgs>(args?: SelectSubset<T, ContactCampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContactCampaign.
     * @param {ContactCampaignDeleteArgs} args - Arguments to delete one ContactCampaign.
     * @example
     * // Delete one ContactCampaign
     * const ContactCampaign = await prisma.contactCampaign.delete({
     *   where: {
     *     // ... filter to delete one ContactCampaign
     *   }
     * })
     * 
     */
    delete<T extends ContactCampaignDeleteArgs>(args: SelectSubset<T, ContactCampaignDeleteArgs<ExtArgs>>): Prisma__ContactCampaignClient<$Result.GetResult<Prisma.$ContactCampaignPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContactCampaign.
     * @param {ContactCampaignUpdateArgs} args - Arguments to update one ContactCampaign.
     * @example
     * // Update one ContactCampaign
     * const contactCampaign = await prisma.contactCampaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactCampaignUpdateArgs>(args: SelectSubset<T, ContactCampaignUpdateArgs<ExtArgs>>): Prisma__ContactCampaignClient<$Result.GetResult<Prisma.$ContactCampaignPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContactCampaigns.
     * @param {ContactCampaignDeleteManyArgs} args - Arguments to filter ContactCampaigns to delete.
     * @example
     * // Delete a few ContactCampaigns
     * const { count } = await prisma.contactCampaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactCampaignDeleteManyArgs>(args?: SelectSubset<T, ContactCampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactCampaigns
     * const contactCampaign = await prisma.contactCampaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactCampaignUpdateManyArgs>(args: SelectSubset<T, ContactCampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContactCampaign.
     * @param {ContactCampaignUpsertArgs} args - Arguments to update or create a ContactCampaign.
     * @example
     * // Update or create a ContactCampaign
     * const contactCampaign = await prisma.contactCampaign.upsert({
     *   create: {
     *     // ... data to create a ContactCampaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactCampaign we want to update
     *   }
     * })
     */
    upsert<T extends ContactCampaignUpsertArgs>(args: SelectSubset<T, ContactCampaignUpsertArgs<ExtArgs>>): Prisma__ContactCampaignClient<$Result.GetResult<Prisma.$ContactCampaignPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContactCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCampaignCountArgs} args - Arguments to filter ContactCampaigns to count.
     * @example
     * // Count the number of ContactCampaigns
     * const count = await prisma.contactCampaign.count({
     *   where: {
     *     // ... the filter for the ContactCampaigns we want to count
     *   }
     * })
    **/
    count<T extends ContactCampaignCountArgs>(
      args?: Subset<T, ContactCampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactCampaignAggregateArgs>(args: Subset<T, ContactCampaignAggregateArgs>): Prisma.PrismaPromise<GetContactCampaignAggregateType<T>>

    /**
     * Group by ContactCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactCampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactCampaignGroupByArgs['orderBy'] }
        : { orderBy?: ContactCampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactCampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactCampaign model
   */
  readonly fields: ContactCampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactCampaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactCampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contactTypes<T extends ContactCampaign$contactTypesArgs<ExtArgs> = {}>(args?: Subset<T, ContactCampaign$contactTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactCampaign model
   */
  interface ContactCampaignFieldRefs {
    readonly id: FieldRef<"ContactCampaign", 'String'>
    readonly Name: FieldRef<"ContactCampaign", 'String'>
    readonly Status: FieldRef<"ContactCampaign", 'Status'>
    readonly createdAt: FieldRef<"ContactCampaign", 'DateTime'>
    readonly updatedAt: FieldRef<"ContactCampaign", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContactCampaign findUnique
   */
  export type ContactCampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCampaign
     */
    select?: ContactCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactCampaign
     */
    omit?: ContactCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactCampaignInclude<ExtArgs> | null
    /**
     * Filter, which ContactCampaign to fetch.
     */
    where: ContactCampaignWhereUniqueInput
  }

  /**
   * ContactCampaign findUniqueOrThrow
   */
  export type ContactCampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCampaign
     */
    select?: ContactCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactCampaign
     */
    omit?: ContactCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactCampaignInclude<ExtArgs> | null
    /**
     * Filter, which ContactCampaign to fetch.
     */
    where: ContactCampaignWhereUniqueInput
  }

  /**
   * ContactCampaign findFirst
   */
  export type ContactCampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCampaign
     */
    select?: ContactCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactCampaign
     */
    omit?: ContactCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactCampaignInclude<ExtArgs> | null
    /**
     * Filter, which ContactCampaign to fetch.
     */
    where?: ContactCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactCampaigns to fetch.
     */
    orderBy?: ContactCampaignOrderByWithRelationInput | ContactCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactCampaigns.
     */
    cursor?: ContactCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactCampaigns.
     */
    distinct?: ContactCampaignScalarFieldEnum | ContactCampaignScalarFieldEnum[]
  }

  /**
   * ContactCampaign findFirstOrThrow
   */
  export type ContactCampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCampaign
     */
    select?: ContactCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactCampaign
     */
    omit?: ContactCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactCampaignInclude<ExtArgs> | null
    /**
     * Filter, which ContactCampaign to fetch.
     */
    where?: ContactCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactCampaigns to fetch.
     */
    orderBy?: ContactCampaignOrderByWithRelationInput | ContactCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactCampaigns.
     */
    cursor?: ContactCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactCampaigns.
     */
    distinct?: ContactCampaignScalarFieldEnum | ContactCampaignScalarFieldEnum[]
  }

  /**
   * ContactCampaign findMany
   */
  export type ContactCampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCampaign
     */
    select?: ContactCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactCampaign
     */
    omit?: ContactCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactCampaignInclude<ExtArgs> | null
    /**
     * Filter, which ContactCampaigns to fetch.
     */
    where?: ContactCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactCampaigns to fetch.
     */
    orderBy?: ContactCampaignOrderByWithRelationInput | ContactCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactCampaigns.
     */
    cursor?: ContactCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactCampaigns.
     */
    skip?: number
    distinct?: ContactCampaignScalarFieldEnum | ContactCampaignScalarFieldEnum[]
  }

  /**
   * ContactCampaign create
   */
  export type ContactCampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCampaign
     */
    select?: ContactCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactCampaign
     */
    omit?: ContactCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactCampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a ContactCampaign.
     */
    data: XOR<ContactCampaignCreateInput, ContactCampaignUncheckedCreateInput>
  }

  /**
   * ContactCampaign createMany
   */
  export type ContactCampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactCampaigns.
     */
    data: ContactCampaignCreateManyInput | ContactCampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactCampaign update
   */
  export type ContactCampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCampaign
     */
    select?: ContactCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactCampaign
     */
    omit?: ContactCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactCampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a ContactCampaign.
     */
    data: XOR<ContactCampaignUpdateInput, ContactCampaignUncheckedUpdateInput>
    /**
     * Choose, which ContactCampaign to update.
     */
    where: ContactCampaignWhereUniqueInput
  }

  /**
   * ContactCampaign updateMany
   */
  export type ContactCampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactCampaigns.
     */
    data: XOR<ContactCampaignUpdateManyMutationInput, ContactCampaignUncheckedUpdateManyInput>
    /**
     * Filter which ContactCampaigns to update
     */
    where?: ContactCampaignWhereInput
    /**
     * Limit how many ContactCampaigns to update.
     */
    limit?: number
  }

  /**
   * ContactCampaign upsert
   */
  export type ContactCampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCampaign
     */
    select?: ContactCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactCampaign
     */
    omit?: ContactCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactCampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the ContactCampaign to update in case it exists.
     */
    where: ContactCampaignWhereUniqueInput
    /**
     * In case the ContactCampaign found by the `where` argument doesn't exist, create a new ContactCampaign with this data.
     */
    create: XOR<ContactCampaignCreateInput, ContactCampaignUncheckedCreateInput>
    /**
     * In case the ContactCampaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactCampaignUpdateInput, ContactCampaignUncheckedUpdateInput>
  }

  /**
   * ContactCampaign delete
   */
  export type ContactCampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCampaign
     */
    select?: ContactCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactCampaign
     */
    omit?: ContactCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactCampaignInclude<ExtArgs> | null
    /**
     * Filter which ContactCampaign to delete.
     */
    where: ContactCampaignWhereUniqueInput
  }

  /**
   * ContactCampaign deleteMany
   */
  export type ContactCampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactCampaigns to delete
     */
    where?: ContactCampaignWhereInput
    /**
     * Limit how many ContactCampaigns to delete.
     */
    limit?: number
  }

  /**
   * ContactCampaign.contactTypes
   */
  export type ContactCampaign$contactTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactType
     */
    select?: ContactTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactType
     */
    omit?: ContactTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTypeInclude<ExtArgs> | null
    where?: ContactTypeWhereInput
    orderBy?: ContactTypeOrderByWithRelationInput | ContactTypeOrderByWithRelationInput[]
    cursor?: ContactTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactTypeScalarFieldEnum | ContactTypeScalarFieldEnum[]
  }

  /**
   * ContactCampaign without action
   */
  export type ContactCampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCampaign
     */
    select?: ContactCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactCampaign
     */
    omit?: ContactCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactCampaignInclude<ExtArgs> | null
  }


  /**
   * Model ContactType
   */

  export type AggregateContactType = {
    _count: ContactTypeCountAggregateOutputType | null
    _min: ContactTypeMinAggregateOutputType | null
    _max: ContactTypeMaxAggregateOutputType | null
  }

  export type ContactTypeMinAggregateOutputType = {
    id: string | null
    Name: string | null
    Status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
    campaignId: string | null
  }

  export type ContactTypeMaxAggregateOutputType = {
    id: string | null
    Name: string | null
    Status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
    campaignId: string | null
  }

  export type ContactTypeCountAggregateOutputType = {
    id: number
    Name: number
    Status: number
    createdAt: number
    updatedAt: number
    campaignId: number
    _all: number
  }


  export type ContactTypeMinAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
    campaignId?: true
  }

  export type ContactTypeMaxAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
    campaignId?: true
  }

  export type ContactTypeCountAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
    campaignId?: true
    _all?: true
  }

  export type ContactTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactType to aggregate.
     */
    where?: ContactTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactTypes to fetch.
     */
    orderBy?: ContactTypeOrderByWithRelationInput | ContactTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactTypes
    **/
    _count?: true | ContactTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactTypeMaxAggregateInputType
  }

  export type GetContactTypeAggregateType<T extends ContactTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateContactType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactType[P]>
      : GetScalarType<T[P], AggregateContactType[P]>
  }




  export type ContactTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactTypeWhereInput
    orderBy?: ContactTypeOrderByWithAggregationInput | ContactTypeOrderByWithAggregationInput[]
    by: ContactTypeScalarFieldEnum[] | ContactTypeScalarFieldEnum
    having?: ContactTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactTypeCountAggregateInputType | true
    _min?: ContactTypeMinAggregateInputType
    _max?: ContactTypeMaxAggregateInputType
  }

  export type ContactTypeGroupByOutputType = {
    id: string
    Name: string
    Status: $Enums.Status
    createdAt: Date
    updatedAt: Date
    campaignId: string
    _count: ContactTypeCountAggregateOutputType | null
    _min: ContactTypeMinAggregateOutputType | null
    _max: ContactTypeMaxAggregateOutputType | null
  }

  type GetContactTypeGroupByPayload<T extends ContactTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ContactTypeGroupByOutputType[P]>
        }
      >
    >


  export type ContactTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Name?: boolean
    Status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaignId?: boolean
    Campaign?: boolean | ContactCampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactType"]>



  export type ContactTypeSelectScalar = {
    id?: boolean
    Name?: boolean
    Status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaignId?: boolean
  }

  export type ContactTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "Name" | "Status" | "createdAt" | "updatedAt" | "campaignId", ExtArgs["result"]["contactType"]>
  export type ContactTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Campaign?: boolean | ContactCampaignDefaultArgs<ExtArgs>
  }

  export type $ContactTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactType"
    objects: {
      Campaign: Prisma.$ContactCampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      Name: string
      Status: $Enums.Status
      createdAt: Date
      updatedAt: Date
      campaignId: string
    }, ExtArgs["result"]["contactType"]>
    composites: {}
  }

  type ContactTypeGetPayload<S extends boolean | null | undefined | ContactTypeDefaultArgs> = $Result.GetResult<Prisma.$ContactTypePayload, S>

  type ContactTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactTypeCountAggregateInputType | true
    }

  export interface ContactTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactType'], meta: { name: 'ContactType' } }
    /**
     * Find zero or one ContactType that matches the filter.
     * @param {ContactTypeFindUniqueArgs} args - Arguments to find a ContactType
     * @example
     * // Get one ContactType
     * const contactType = await prisma.contactType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactTypeFindUniqueArgs>(args: SelectSubset<T, ContactTypeFindUniqueArgs<ExtArgs>>): Prisma__ContactTypeClient<$Result.GetResult<Prisma.$ContactTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContactType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactTypeFindUniqueOrThrowArgs} args - Arguments to find a ContactType
     * @example
     * // Get one ContactType
     * const contactType = await prisma.contactType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactTypeClient<$Result.GetResult<Prisma.$ContactTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTypeFindFirstArgs} args - Arguments to find a ContactType
     * @example
     * // Get one ContactType
     * const contactType = await prisma.contactType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactTypeFindFirstArgs>(args?: SelectSubset<T, ContactTypeFindFirstArgs<ExtArgs>>): Prisma__ContactTypeClient<$Result.GetResult<Prisma.$ContactTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTypeFindFirstOrThrowArgs} args - Arguments to find a ContactType
     * @example
     * // Get one ContactType
     * const contactType = await prisma.contactType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactTypeClient<$Result.GetResult<Prisma.$ContactTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContactTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactTypes
     * const contactTypes = await prisma.contactType.findMany()
     * 
     * // Get first 10 ContactTypes
     * const contactTypes = await prisma.contactType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactTypeWithIdOnly = await prisma.contactType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactTypeFindManyArgs>(args?: SelectSubset<T, ContactTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContactType.
     * @param {ContactTypeCreateArgs} args - Arguments to create a ContactType.
     * @example
     * // Create one ContactType
     * const ContactType = await prisma.contactType.create({
     *   data: {
     *     // ... data to create a ContactType
     *   }
     * })
     * 
     */
    create<T extends ContactTypeCreateArgs>(args: SelectSubset<T, ContactTypeCreateArgs<ExtArgs>>): Prisma__ContactTypeClient<$Result.GetResult<Prisma.$ContactTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContactTypes.
     * @param {ContactTypeCreateManyArgs} args - Arguments to create many ContactTypes.
     * @example
     * // Create many ContactTypes
     * const contactType = await prisma.contactType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactTypeCreateManyArgs>(args?: SelectSubset<T, ContactTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContactType.
     * @param {ContactTypeDeleteArgs} args - Arguments to delete one ContactType.
     * @example
     * // Delete one ContactType
     * const ContactType = await prisma.contactType.delete({
     *   where: {
     *     // ... filter to delete one ContactType
     *   }
     * })
     * 
     */
    delete<T extends ContactTypeDeleteArgs>(args: SelectSubset<T, ContactTypeDeleteArgs<ExtArgs>>): Prisma__ContactTypeClient<$Result.GetResult<Prisma.$ContactTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContactType.
     * @param {ContactTypeUpdateArgs} args - Arguments to update one ContactType.
     * @example
     * // Update one ContactType
     * const contactType = await prisma.contactType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactTypeUpdateArgs>(args: SelectSubset<T, ContactTypeUpdateArgs<ExtArgs>>): Prisma__ContactTypeClient<$Result.GetResult<Prisma.$ContactTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContactTypes.
     * @param {ContactTypeDeleteManyArgs} args - Arguments to filter ContactTypes to delete.
     * @example
     * // Delete a few ContactTypes
     * const { count } = await prisma.contactType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactTypeDeleteManyArgs>(args?: SelectSubset<T, ContactTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactTypes
     * const contactType = await prisma.contactType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactTypeUpdateManyArgs>(args: SelectSubset<T, ContactTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContactType.
     * @param {ContactTypeUpsertArgs} args - Arguments to update or create a ContactType.
     * @example
     * // Update or create a ContactType
     * const contactType = await prisma.contactType.upsert({
     *   create: {
     *     // ... data to create a ContactType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactType we want to update
     *   }
     * })
     */
    upsert<T extends ContactTypeUpsertArgs>(args: SelectSubset<T, ContactTypeUpsertArgs<ExtArgs>>): Prisma__ContactTypeClient<$Result.GetResult<Prisma.$ContactTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContactTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTypeCountArgs} args - Arguments to filter ContactTypes to count.
     * @example
     * // Count the number of ContactTypes
     * const count = await prisma.contactType.count({
     *   where: {
     *     // ... the filter for the ContactTypes we want to count
     *   }
     * })
    **/
    count<T extends ContactTypeCountArgs>(
      args?: Subset<T, ContactTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactTypeAggregateArgs>(args: Subset<T, ContactTypeAggregateArgs>): Prisma.PrismaPromise<GetContactTypeAggregateType<T>>

    /**
     * Group by ContactType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactTypeGroupByArgs['orderBy'] }
        : { orderBy?: ContactTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactType model
   */
  readonly fields: ContactTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Campaign<T extends ContactCampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactCampaignDefaultArgs<ExtArgs>>): Prisma__ContactCampaignClient<$Result.GetResult<Prisma.$ContactCampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactType model
   */
  interface ContactTypeFieldRefs {
    readonly id: FieldRef<"ContactType", 'String'>
    readonly Name: FieldRef<"ContactType", 'String'>
    readonly Status: FieldRef<"ContactType", 'Status'>
    readonly createdAt: FieldRef<"ContactType", 'DateTime'>
    readonly updatedAt: FieldRef<"ContactType", 'DateTime'>
    readonly campaignId: FieldRef<"ContactType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ContactType findUnique
   */
  export type ContactTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactType
     */
    select?: ContactTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactType
     */
    omit?: ContactTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTypeInclude<ExtArgs> | null
    /**
     * Filter, which ContactType to fetch.
     */
    where: ContactTypeWhereUniqueInput
  }

  /**
   * ContactType findUniqueOrThrow
   */
  export type ContactTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactType
     */
    select?: ContactTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactType
     */
    omit?: ContactTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTypeInclude<ExtArgs> | null
    /**
     * Filter, which ContactType to fetch.
     */
    where: ContactTypeWhereUniqueInput
  }

  /**
   * ContactType findFirst
   */
  export type ContactTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactType
     */
    select?: ContactTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactType
     */
    omit?: ContactTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTypeInclude<ExtArgs> | null
    /**
     * Filter, which ContactType to fetch.
     */
    where?: ContactTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactTypes to fetch.
     */
    orderBy?: ContactTypeOrderByWithRelationInput | ContactTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactTypes.
     */
    cursor?: ContactTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactTypes.
     */
    distinct?: ContactTypeScalarFieldEnum | ContactTypeScalarFieldEnum[]
  }

  /**
   * ContactType findFirstOrThrow
   */
  export type ContactTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactType
     */
    select?: ContactTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactType
     */
    omit?: ContactTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTypeInclude<ExtArgs> | null
    /**
     * Filter, which ContactType to fetch.
     */
    where?: ContactTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactTypes to fetch.
     */
    orderBy?: ContactTypeOrderByWithRelationInput | ContactTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactTypes.
     */
    cursor?: ContactTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactTypes.
     */
    distinct?: ContactTypeScalarFieldEnum | ContactTypeScalarFieldEnum[]
  }

  /**
   * ContactType findMany
   */
  export type ContactTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactType
     */
    select?: ContactTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactType
     */
    omit?: ContactTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTypeInclude<ExtArgs> | null
    /**
     * Filter, which ContactTypes to fetch.
     */
    where?: ContactTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactTypes to fetch.
     */
    orderBy?: ContactTypeOrderByWithRelationInput | ContactTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactTypes.
     */
    cursor?: ContactTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactTypes.
     */
    skip?: number
    distinct?: ContactTypeScalarFieldEnum | ContactTypeScalarFieldEnum[]
  }

  /**
   * ContactType create
   */
  export type ContactTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactType
     */
    select?: ContactTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactType
     */
    omit?: ContactTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a ContactType.
     */
    data: XOR<ContactTypeCreateInput, ContactTypeUncheckedCreateInput>
  }

  /**
   * ContactType createMany
   */
  export type ContactTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactTypes.
     */
    data: ContactTypeCreateManyInput | ContactTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactType update
   */
  export type ContactTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactType
     */
    select?: ContactTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactType
     */
    omit?: ContactTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a ContactType.
     */
    data: XOR<ContactTypeUpdateInput, ContactTypeUncheckedUpdateInput>
    /**
     * Choose, which ContactType to update.
     */
    where: ContactTypeWhereUniqueInput
  }

  /**
   * ContactType updateMany
   */
  export type ContactTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactTypes.
     */
    data: XOR<ContactTypeUpdateManyMutationInput, ContactTypeUncheckedUpdateManyInput>
    /**
     * Filter which ContactTypes to update
     */
    where?: ContactTypeWhereInput
    /**
     * Limit how many ContactTypes to update.
     */
    limit?: number
  }

  /**
   * ContactType upsert
   */
  export type ContactTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactType
     */
    select?: ContactTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactType
     */
    omit?: ContactTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the ContactType to update in case it exists.
     */
    where: ContactTypeWhereUniqueInput
    /**
     * In case the ContactType found by the `where` argument doesn't exist, create a new ContactType with this data.
     */
    create: XOR<ContactTypeCreateInput, ContactTypeUncheckedCreateInput>
    /**
     * In case the ContactType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactTypeUpdateInput, ContactTypeUncheckedUpdateInput>
  }

  /**
   * ContactType delete
   */
  export type ContactTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactType
     */
    select?: ContactTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactType
     */
    omit?: ContactTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTypeInclude<ExtArgs> | null
    /**
     * Filter which ContactType to delete.
     */
    where: ContactTypeWhereUniqueInput
  }

  /**
   * ContactType deleteMany
   */
  export type ContactTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactTypes to delete
     */
    where?: ContactTypeWhereInput
    /**
     * Limit how many ContactTypes to delete.
     */
    limit?: number
  }

  /**
   * ContactType without action
   */
  export type ContactTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactType
     */
    select?: ContactTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactType
     */
    omit?: ContactTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTypeInclude<ExtArgs> | null
  }


  /**
   * Model City
   */

  export type AggregateCity = {
    _count: CityCountAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  export type CityMinAggregateOutputType = {
    id: string | null
    Name: string | null
    Status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CityMaxAggregateOutputType = {
    id: string | null
    Name: string | null
    Status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CityCountAggregateOutputType = {
    id: number
    Name: number
    Status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CityMinAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CityMaxAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CityCountAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which City to aggregate.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cities
    **/
    _count?: true | CityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CityMaxAggregateInputType
  }

  export type GetCityAggregateType<T extends CityAggregateArgs> = {
        [P in keyof T & keyof AggregateCity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCity[P]>
      : GetScalarType<T[P], AggregateCity[P]>
  }




  export type CityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
    orderBy?: CityOrderByWithAggregationInput | CityOrderByWithAggregationInput[]
    by: CityScalarFieldEnum[] | CityScalarFieldEnum
    having?: CityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CityCountAggregateInputType | true
    _min?: CityMinAggregateInputType
    _max?: CityMaxAggregateInputType
  }

  export type CityGroupByOutputType = {
    id: string
    Name: string
    Status: string
    createdAt: Date
    updatedAt: Date
    _count: CityCountAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  type GetCityGroupByPayload<T extends CityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CityGroupByOutputType[P]>
            : GetScalarType<T[P], CityGroupByOutputType[P]>
        }
      >
    >


  export type CitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Name?: boolean
    Status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    locations?: boolean | City$locationsArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>



  export type CitySelectScalar = {
    id?: boolean
    Name?: boolean
    Status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "Name" | "Status" | "createdAt" | "updatedAt", ExtArgs["result"]["city"]>
  export type CityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locations?: boolean | City$locationsArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "City"
    objects: {
      locations: Prisma.$LocationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      Name: string
      Status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["city"]>
    composites: {}
  }

  type CityGetPayload<S extends boolean | null | undefined | CityDefaultArgs> = $Result.GetResult<Prisma.$CityPayload, S>

  type CityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CityCountAggregateInputType | true
    }

  export interface CityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['City'], meta: { name: 'City' } }
    /**
     * Find zero or one City that matches the filter.
     * @param {CityFindUniqueArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CityFindUniqueArgs>(args: SelectSubset<T, CityFindUniqueArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one City that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CityFindUniqueOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CityFindUniqueOrThrowArgs>(args: SelectSubset<T, CityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first City that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CityFindFirstArgs>(args?: SelectSubset<T, CityFindFirstArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first City that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CityFindFirstOrThrowArgs>(args?: SelectSubset<T, CityFindFirstOrThrowArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities
     * const cities = await prisma.city.findMany()
     * 
     * // Get first 10 Cities
     * const cities = await prisma.city.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cityWithIdOnly = await prisma.city.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CityFindManyArgs>(args?: SelectSubset<T, CityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a City.
     * @param {CityCreateArgs} args - Arguments to create a City.
     * @example
     * // Create one City
     * const City = await prisma.city.create({
     *   data: {
     *     // ... data to create a City
     *   }
     * })
     * 
     */
    create<T extends CityCreateArgs>(args: SelectSubset<T, CityCreateArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cities.
     * @param {CityCreateManyArgs} args - Arguments to create many Cities.
     * @example
     * // Create many Cities
     * const city = await prisma.city.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CityCreateManyArgs>(args?: SelectSubset<T, CityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a City.
     * @param {CityDeleteArgs} args - Arguments to delete one City.
     * @example
     * // Delete one City
     * const City = await prisma.city.delete({
     *   where: {
     *     // ... filter to delete one City
     *   }
     * })
     * 
     */
    delete<T extends CityDeleteArgs>(args: SelectSubset<T, CityDeleteArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one City.
     * @param {CityUpdateArgs} args - Arguments to update one City.
     * @example
     * // Update one City
     * const city = await prisma.city.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CityUpdateArgs>(args: SelectSubset<T, CityUpdateArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cities.
     * @param {CityDeleteManyArgs} args - Arguments to filter Cities to delete.
     * @example
     * // Delete a few Cities
     * const { count } = await prisma.city.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CityDeleteManyArgs>(args?: SelectSubset<T, CityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CityUpdateManyArgs>(args: SelectSubset<T, CityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one City.
     * @param {CityUpsertArgs} args - Arguments to update or create a City.
     * @example
     * // Update or create a City
     * const city = await prisma.city.upsert({
     *   create: {
     *     // ... data to create a City
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the City we want to update
     *   }
     * })
     */
    upsert<T extends CityUpsertArgs>(args: SelectSubset<T, CityUpsertArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityCountArgs} args - Arguments to filter Cities to count.
     * @example
     * // Count the number of Cities
     * const count = await prisma.city.count({
     *   where: {
     *     // ... the filter for the Cities we want to count
     *   }
     * })
    **/
    count<T extends CityCountArgs>(
      args?: Subset<T, CityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CityAggregateArgs>(args: Subset<T, CityAggregateArgs>): Prisma.PrismaPromise<GetCityAggregateType<T>>

    /**
     * Group by City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CityGroupByArgs['orderBy'] }
        : { orderBy?: CityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the City model
   */
  readonly fields: CityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for City.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    locations<T extends City$locationsArgs<ExtArgs> = {}>(args?: Subset<T, City$locationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the City model
   */
  interface CityFieldRefs {
    readonly id: FieldRef<"City", 'String'>
    readonly Name: FieldRef<"City", 'String'>
    readonly Status: FieldRef<"City", 'String'>
    readonly createdAt: FieldRef<"City", 'DateTime'>
    readonly updatedAt: FieldRef<"City", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * City findUnique
   */
  export type CityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City findUniqueOrThrow
   */
  export type CityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City findFirst
   */
  export type CityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City findFirstOrThrow
   */
  export type CityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City findMany
   */
  export type CityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which Cities to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }

  /**
   * City create
   */
  export type CityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to create a City.
     */
    data: XOR<CityCreateInput, CityUncheckedCreateInput>
  }

  /**
   * City createMany
   */
  export type CityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cities.
     */
    data: CityCreateManyInput | CityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * City update
   */
  export type CityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to update a City.
     */
    data: XOR<CityUpdateInput, CityUncheckedUpdateInput>
    /**
     * Choose, which City to update.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City updateMany
   */
  export type CityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cities.
     */
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    /**
     * Filter which Cities to update
     */
    where?: CityWhereInput
    /**
     * Limit how many Cities to update.
     */
    limit?: number
  }

  /**
   * City upsert
   */
  export type CityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The filter to search for the City to update in case it exists.
     */
    where: CityWhereUniqueInput
    /**
     * In case the City found by the `where` argument doesn't exist, create a new City with this data.
     */
    create: XOR<CityCreateInput, CityUncheckedCreateInput>
    /**
     * In case the City was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CityUpdateInput, CityUncheckedUpdateInput>
  }

  /**
   * City delete
   */
  export type CityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter which City to delete.
     */
    where: CityWhereUniqueInput
  }

  /**
   * City deleteMany
   */
  export type CityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cities to delete
     */
    where?: CityWhereInput
    /**
     * Limit how many Cities to delete.
     */
    limit?: number
  }

  /**
   * City.locations
   */
  export type City$locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    cursor?: LocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * City without action
   */
  export type CityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the City
     */
    omit?: CityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CityInclude<ExtArgs> | null
  }


  /**
   * Model Location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationMinAggregateOutputType = {
    id: string | null
    Name: string | null
    Status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    cityId: string | null
  }

  export type LocationMaxAggregateOutputType = {
    id: string | null
    Name: string | null
    Status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    cityId: string | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    Name: number
    Status: number
    createdAt: number
    updatedAt: number
    cityId: number
    _all: number
  }


  export type LocationMinAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
    cityId?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
    cityId?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
    cityId?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Location to aggregate.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithAggregationInput | LocationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: LocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    id: string
    Name: string
    Status: string
    createdAt: Date
    updatedAt: Date
    cityId: string
    _count: LocationCountAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type LocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Name?: boolean
    Status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cityId?: boolean
    City?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>



  export type LocationSelectScalar = {
    id?: boolean
    Name?: boolean
    Status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cityId?: boolean
  }

  export type LocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "Name" | "Status" | "createdAt" | "updatedAt" | "cityId", ExtArgs["result"]["location"]>
  export type LocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    City?: boolean | CityDefaultArgs<ExtArgs>
  }

  export type $LocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Location"
    objects: {
      City: Prisma.$CityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      Name: string
      Status: string
      createdAt: Date
      updatedAt: Date
      cityId: string
    }, ExtArgs["result"]["location"]>
    composites: {}
  }

  type LocationGetPayload<S extends boolean | null | undefined | LocationDefaultArgs> = $Result.GetResult<Prisma.$LocationPayload, S>

  type LocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface LocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Location'], meta: { name: 'Location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {LocationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationFindUniqueArgs>(args: SelectSubset<T, LocationFindUniqueArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Location that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationFindFirstArgs>(args?: SelectSubset<T, LocationFindFirstArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationFindManyArgs>(args?: SelectSubset<T, LocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Location.
     * @param {LocationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
     */
    create<T extends LocationCreateArgs>(args: SelectSubset<T, LocationCreateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Locations.
     * @param {LocationCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationCreateManyArgs>(args?: SelectSubset<T, LocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Location.
     * @param {LocationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
     */
    delete<T extends LocationDeleteArgs>(args: SelectSubset<T, LocationDeleteArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Location.
     * @param {LocationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationUpdateArgs>(args: SelectSubset<T, LocationUpdateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Locations.
     * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationDeleteManyArgs>(args?: SelectSubset<T, LocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationUpdateManyArgs>(args: SelectSubset<T, LocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Location.
     * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
     */
    upsert<T extends LocationUpsertArgs>(args: SelectSubset<T, LocationUpsertArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationCountArgs>(
      args?: Subset<T, LocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Location model
   */
  readonly fields: LocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    City<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Location model
   */
  interface LocationFieldRefs {
    readonly id: FieldRef<"Location", 'String'>
    readonly Name: FieldRef<"Location", 'String'>
    readonly Status: FieldRef<"Location", 'String'>
    readonly createdAt: FieldRef<"Location", 'DateTime'>
    readonly updatedAt: FieldRef<"Location", 'DateTime'>
    readonly cityId: FieldRef<"Location", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Location findUnique
   */
  export type LocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findUniqueOrThrow
   */
  export type LocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findFirst
   */
  export type LocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findFirstOrThrow
   */
  export type LocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findMany
   */
  export type LocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location create
   */
  export type LocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Location.
     */
    data: XOR<LocationCreateInput, LocationUncheckedCreateInput>
  }

  /**
   * Location createMany
   */
  export type LocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location update
   */
  export type LocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Location.
     */
    data: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
    /**
     * Choose, which Location to update.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location updateMany
   */
  export type LocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
  }

  /**
   * Location upsert
   */
  export type LocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Location to update in case it exists.
     */
    where: LocationWhereUniqueInput
    /**
     * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
     */
    create: XOR<LocationCreateInput, LocationUncheckedCreateInput>
    /**
     * In case the Location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
  }

  /**
   * Location delete
   */
  export type LocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter which Location to delete.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location deleteMany
   */
  export type LocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to delete.
     */
    limit?: number
  }

  /**
   * Location without action
   */
  export type LocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
  }


  /**
   * Model Facility
   */

  export type AggregateFacility = {
    _count: FacilityCountAggregateOutputType | null
    _min: FacilityMinAggregateOutputType | null
    _max: FacilityMaxAggregateOutputType | null
  }

  export type FacilityMinAggregateOutputType = {
    id: string | null
    Name: string | null
    Status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacilityMaxAggregateOutputType = {
    id: string | null
    Name: string | null
    Status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FacilityCountAggregateOutputType = {
    id: number
    Name: number
    Status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FacilityMinAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacilityMaxAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FacilityCountAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FacilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Facility to aggregate.
     */
    where?: FacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facilities to fetch.
     */
    orderBy?: FacilityOrderByWithRelationInput | FacilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Facilities
    **/
    _count?: true | FacilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacilityMaxAggregateInputType
  }

  export type GetFacilityAggregateType<T extends FacilityAggregateArgs> = {
        [P in keyof T & keyof AggregateFacility]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacility[P]>
      : GetScalarType<T[P], AggregateFacility[P]>
  }




  export type FacilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacilityWhereInput
    orderBy?: FacilityOrderByWithAggregationInput | FacilityOrderByWithAggregationInput[]
    by: FacilityScalarFieldEnum[] | FacilityScalarFieldEnum
    having?: FacilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacilityCountAggregateInputType | true
    _min?: FacilityMinAggregateInputType
    _max?: FacilityMaxAggregateInputType
  }

  export type FacilityGroupByOutputType = {
    id: string
    Name: string
    Status: string
    createdAt: Date
    updatedAt: Date
    _count: FacilityCountAggregateOutputType | null
    _min: FacilityMinAggregateOutputType | null
    _max: FacilityMaxAggregateOutputType | null
  }

  type GetFacilityGroupByPayload<T extends FacilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FacilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacilityGroupByOutputType[P]>
            : GetScalarType<T[P], FacilityGroupByOutputType[P]>
        }
      >
    >


  export type FacilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Name?: boolean
    Status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["facility"]>



  export type FacilitySelectScalar = {
    id?: boolean
    Name?: boolean
    Status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FacilityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "Name" | "Status" | "createdAt" | "updatedAt", ExtArgs["result"]["facility"]>

  export type $FacilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Facility"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      Name: string
      Status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["facility"]>
    composites: {}
  }

  type FacilityGetPayload<S extends boolean | null | undefined | FacilityDefaultArgs> = $Result.GetResult<Prisma.$FacilityPayload, S>

  type FacilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FacilityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FacilityCountAggregateInputType | true
    }

  export interface FacilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Facility'], meta: { name: 'Facility' } }
    /**
     * Find zero or one Facility that matches the filter.
     * @param {FacilityFindUniqueArgs} args - Arguments to find a Facility
     * @example
     * // Get one Facility
     * const facility = await prisma.facility.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FacilityFindUniqueArgs>(args: SelectSubset<T, FacilityFindUniqueArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Facility that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FacilityFindUniqueOrThrowArgs} args - Arguments to find a Facility
     * @example
     * // Get one Facility
     * const facility = await prisma.facility.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FacilityFindUniqueOrThrowArgs>(args: SelectSubset<T, FacilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Facility that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFindFirstArgs} args - Arguments to find a Facility
     * @example
     * // Get one Facility
     * const facility = await prisma.facility.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FacilityFindFirstArgs>(args?: SelectSubset<T, FacilityFindFirstArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Facility that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFindFirstOrThrowArgs} args - Arguments to find a Facility
     * @example
     * // Get one Facility
     * const facility = await prisma.facility.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FacilityFindFirstOrThrowArgs>(args?: SelectSubset<T, FacilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Facilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Facilities
     * const facilities = await prisma.facility.findMany()
     * 
     * // Get first 10 Facilities
     * const facilities = await prisma.facility.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facilityWithIdOnly = await prisma.facility.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FacilityFindManyArgs>(args?: SelectSubset<T, FacilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Facility.
     * @param {FacilityCreateArgs} args - Arguments to create a Facility.
     * @example
     * // Create one Facility
     * const Facility = await prisma.facility.create({
     *   data: {
     *     // ... data to create a Facility
     *   }
     * })
     * 
     */
    create<T extends FacilityCreateArgs>(args: SelectSubset<T, FacilityCreateArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Facilities.
     * @param {FacilityCreateManyArgs} args - Arguments to create many Facilities.
     * @example
     * // Create many Facilities
     * const facility = await prisma.facility.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FacilityCreateManyArgs>(args?: SelectSubset<T, FacilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Facility.
     * @param {FacilityDeleteArgs} args - Arguments to delete one Facility.
     * @example
     * // Delete one Facility
     * const Facility = await prisma.facility.delete({
     *   where: {
     *     // ... filter to delete one Facility
     *   }
     * })
     * 
     */
    delete<T extends FacilityDeleteArgs>(args: SelectSubset<T, FacilityDeleteArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Facility.
     * @param {FacilityUpdateArgs} args - Arguments to update one Facility.
     * @example
     * // Update one Facility
     * const facility = await prisma.facility.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FacilityUpdateArgs>(args: SelectSubset<T, FacilityUpdateArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Facilities.
     * @param {FacilityDeleteManyArgs} args - Arguments to filter Facilities to delete.
     * @example
     * // Delete a few Facilities
     * const { count } = await prisma.facility.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FacilityDeleteManyArgs>(args?: SelectSubset<T, FacilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Facilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Facilities
     * const facility = await prisma.facility.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FacilityUpdateManyArgs>(args: SelectSubset<T, FacilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Facility.
     * @param {FacilityUpsertArgs} args - Arguments to update or create a Facility.
     * @example
     * // Update or create a Facility
     * const facility = await prisma.facility.upsert({
     *   create: {
     *     // ... data to create a Facility
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Facility we want to update
     *   }
     * })
     */
    upsert<T extends FacilityUpsertArgs>(args: SelectSubset<T, FacilityUpsertArgs<ExtArgs>>): Prisma__FacilityClient<$Result.GetResult<Prisma.$FacilityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Facilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityCountArgs} args - Arguments to filter Facilities to count.
     * @example
     * // Count the number of Facilities
     * const count = await prisma.facility.count({
     *   where: {
     *     // ... the filter for the Facilities we want to count
     *   }
     * })
    **/
    count<T extends FacilityCountArgs>(
      args?: Subset<T, FacilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Facility.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacilityAggregateArgs>(args: Subset<T, FacilityAggregateArgs>): Prisma.PrismaPromise<GetFacilityAggregateType<T>>

    /**
     * Group by Facility.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacilityGroupByArgs['orderBy'] }
        : { orderBy?: FacilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Facility model
   */
  readonly fields: FacilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Facility.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FacilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Facility model
   */
  interface FacilityFieldRefs {
    readonly id: FieldRef<"Facility", 'String'>
    readonly Name: FieldRef<"Facility", 'String'>
    readonly Status: FieldRef<"Facility", 'String'>
    readonly createdAt: FieldRef<"Facility", 'DateTime'>
    readonly updatedAt: FieldRef<"Facility", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Facility findUnique
   */
  export type FacilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * Filter, which Facility to fetch.
     */
    where: FacilityWhereUniqueInput
  }

  /**
   * Facility findUniqueOrThrow
   */
  export type FacilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * Filter, which Facility to fetch.
     */
    where: FacilityWhereUniqueInput
  }

  /**
   * Facility findFirst
   */
  export type FacilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * Filter, which Facility to fetch.
     */
    where?: FacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facilities to fetch.
     */
    orderBy?: FacilityOrderByWithRelationInput | FacilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Facilities.
     */
    cursor?: FacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Facilities.
     */
    distinct?: FacilityScalarFieldEnum | FacilityScalarFieldEnum[]
  }

  /**
   * Facility findFirstOrThrow
   */
  export type FacilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * Filter, which Facility to fetch.
     */
    where?: FacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facilities to fetch.
     */
    orderBy?: FacilityOrderByWithRelationInput | FacilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Facilities.
     */
    cursor?: FacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Facilities.
     */
    distinct?: FacilityScalarFieldEnum | FacilityScalarFieldEnum[]
  }

  /**
   * Facility findMany
   */
  export type FacilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * Filter, which Facilities to fetch.
     */
    where?: FacilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Facilities to fetch.
     */
    orderBy?: FacilityOrderByWithRelationInput | FacilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Facilities.
     */
    cursor?: FacilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Facilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Facilities.
     */
    skip?: number
    distinct?: FacilityScalarFieldEnum | FacilityScalarFieldEnum[]
  }

  /**
   * Facility create
   */
  export type FacilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * The data needed to create a Facility.
     */
    data: XOR<FacilityCreateInput, FacilityUncheckedCreateInput>
  }

  /**
   * Facility createMany
   */
  export type FacilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Facilities.
     */
    data: FacilityCreateManyInput | FacilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Facility update
   */
  export type FacilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * The data needed to update a Facility.
     */
    data: XOR<FacilityUpdateInput, FacilityUncheckedUpdateInput>
    /**
     * Choose, which Facility to update.
     */
    where: FacilityWhereUniqueInput
  }

  /**
   * Facility updateMany
   */
  export type FacilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Facilities.
     */
    data: XOR<FacilityUpdateManyMutationInput, FacilityUncheckedUpdateManyInput>
    /**
     * Filter which Facilities to update
     */
    where?: FacilityWhereInput
    /**
     * Limit how many Facilities to update.
     */
    limit?: number
  }

  /**
   * Facility upsert
   */
  export type FacilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * The filter to search for the Facility to update in case it exists.
     */
    where: FacilityWhereUniqueInput
    /**
     * In case the Facility found by the `where` argument doesn't exist, create a new Facility with this data.
     */
    create: XOR<FacilityCreateInput, FacilityUncheckedCreateInput>
    /**
     * In case the Facility was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacilityUpdateInput, FacilityUncheckedUpdateInput>
  }

  /**
   * Facility delete
   */
  export type FacilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
    /**
     * Filter which Facility to delete.
     */
    where: FacilityWhereUniqueInput
  }

  /**
   * Facility deleteMany
   */
  export type FacilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Facilities to delete
     */
    where?: FacilityWhereInput
    /**
     * Limit how many Facilities to delete.
     */
    limit?: number
  }

  /**
   * Facility without action
   */
  export type FacilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null
  }


  /**
   * Model Amenity
   */

  export type AggregateAmenity = {
    _count: AmenityCountAggregateOutputType | null
    _min: AmenityMinAggregateOutputType | null
    _max: AmenityMaxAggregateOutputType | null
  }

  export type AmenityMinAggregateOutputType = {
    id: string | null
    Name: string | null
    Status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AmenityMaxAggregateOutputType = {
    id: string | null
    Name: string | null
    Status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AmenityCountAggregateOutputType = {
    id: number
    Name: number
    Status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AmenityMinAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AmenityMaxAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AmenityCountAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AmenityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Amenity to aggregate.
     */
    where?: AmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenityOrderByWithRelationInput | AmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Amenities
    **/
    _count?: true | AmenityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AmenityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AmenityMaxAggregateInputType
  }

  export type GetAmenityAggregateType<T extends AmenityAggregateArgs> = {
        [P in keyof T & keyof AggregateAmenity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAmenity[P]>
      : GetScalarType<T[P], AggregateAmenity[P]>
  }




  export type AmenityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmenityWhereInput
    orderBy?: AmenityOrderByWithAggregationInput | AmenityOrderByWithAggregationInput[]
    by: AmenityScalarFieldEnum[] | AmenityScalarFieldEnum
    having?: AmenityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AmenityCountAggregateInputType | true
    _min?: AmenityMinAggregateInputType
    _max?: AmenityMaxAggregateInputType
  }

  export type AmenityGroupByOutputType = {
    id: string
    Name: string
    Status: string
    createdAt: Date
    updatedAt: Date
    _count: AmenityCountAggregateOutputType | null
    _min: AmenityMinAggregateOutputType | null
    _max: AmenityMaxAggregateOutputType | null
  }

  type GetAmenityGroupByPayload<T extends AmenityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AmenityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AmenityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AmenityGroupByOutputType[P]>
            : GetScalarType<T[P], AmenityGroupByOutputType[P]>
        }
      >
    >


  export type AmenitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Name?: boolean
    Status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["amenity"]>



  export type AmenitySelectScalar = {
    id?: boolean
    Name?: boolean
    Status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AmenityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "Name" | "Status" | "createdAt" | "updatedAt", ExtArgs["result"]["amenity"]>

  export type $AmenityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Amenity"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      Name: string
      Status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["amenity"]>
    composites: {}
  }

  type AmenityGetPayload<S extends boolean | null | undefined | AmenityDefaultArgs> = $Result.GetResult<Prisma.$AmenityPayload, S>

  type AmenityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AmenityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AmenityCountAggregateInputType | true
    }

  export interface AmenityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Amenity'], meta: { name: 'Amenity' } }
    /**
     * Find zero or one Amenity that matches the filter.
     * @param {AmenityFindUniqueArgs} args - Arguments to find a Amenity
     * @example
     * // Get one Amenity
     * const amenity = await prisma.amenity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AmenityFindUniqueArgs>(args: SelectSubset<T, AmenityFindUniqueArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Amenity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AmenityFindUniqueOrThrowArgs} args - Arguments to find a Amenity
     * @example
     * // Get one Amenity
     * const amenity = await prisma.amenity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AmenityFindUniqueOrThrowArgs>(args: SelectSubset<T, AmenityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Amenity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityFindFirstArgs} args - Arguments to find a Amenity
     * @example
     * // Get one Amenity
     * const amenity = await prisma.amenity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AmenityFindFirstArgs>(args?: SelectSubset<T, AmenityFindFirstArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Amenity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityFindFirstOrThrowArgs} args - Arguments to find a Amenity
     * @example
     * // Get one Amenity
     * const amenity = await prisma.amenity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AmenityFindFirstOrThrowArgs>(args?: SelectSubset<T, AmenityFindFirstOrThrowArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Amenities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Amenities
     * const amenities = await prisma.amenity.findMany()
     * 
     * // Get first 10 Amenities
     * const amenities = await prisma.amenity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const amenityWithIdOnly = await prisma.amenity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AmenityFindManyArgs>(args?: SelectSubset<T, AmenityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Amenity.
     * @param {AmenityCreateArgs} args - Arguments to create a Amenity.
     * @example
     * // Create one Amenity
     * const Amenity = await prisma.amenity.create({
     *   data: {
     *     // ... data to create a Amenity
     *   }
     * })
     * 
     */
    create<T extends AmenityCreateArgs>(args: SelectSubset<T, AmenityCreateArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Amenities.
     * @param {AmenityCreateManyArgs} args - Arguments to create many Amenities.
     * @example
     * // Create many Amenities
     * const amenity = await prisma.amenity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AmenityCreateManyArgs>(args?: SelectSubset<T, AmenityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Amenity.
     * @param {AmenityDeleteArgs} args - Arguments to delete one Amenity.
     * @example
     * // Delete one Amenity
     * const Amenity = await prisma.amenity.delete({
     *   where: {
     *     // ... filter to delete one Amenity
     *   }
     * })
     * 
     */
    delete<T extends AmenityDeleteArgs>(args: SelectSubset<T, AmenityDeleteArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Amenity.
     * @param {AmenityUpdateArgs} args - Arguments to update one Amenity.
     * @example
     * // Update one Amenity
     * const amenity = await prisma.amenity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AmenityUpdateArgs>(args: SelectSubset<T, AmenityUpdateArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Amenities.
     * @param {AmenityDeleteManyArgs} args - Arguments to filter Amenities to delete.
     * @example
     * // Delete a few Amenities
     * const { count } = await prisma.amenity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AmenityDeleteManyArgs>(args?: SelectSubset<T, AmenityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Amenities
     * const amenity = await prisma.amenity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AmenityUpdateManyArgs>(args: SelectSubset<T, AmenityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Amenity.
     * @param {AmenityUpsertArgs} args - Arguments to update or create a Amenity.
     * @example
     * // Update or create a Amenity
     * const amenity = await prisma.amenity.upsert({
     *   create: {
     *     // ... data to create a Amenity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Amenity we want to update
     *   }
     * })
     */
    upsert<T extends AmenityUpsertArgs>(args: SelectSubset<T, AmenityUpsertArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityCountArgs} args - Arguments to filter Amenities to count.
     * @example
     * // Count the number of Amenities
     * const count = await prisma.amenity.count({
     *   where: {
     *     // ... the filter for the Amenities we want to count
     *   }
     * })
    **/
    count<T extends AmenityCountArgs>(
      args?: Subset<T, AmenityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AmenityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Amenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AmenityAggregateArgs>(args: Subset<T, AmenityAggregateArgs>): Prisma.PrismaPromise<GetAmenityAggregateType<T>>

    /**
     * Group by Amenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AmenityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AmenityGroupByArgs['orderBy'] }
        : { orderBy?: AmenityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AmenityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAmenityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Amenity model
   */
  readonly fields: AmenityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Amenity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AmenityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Amenity model
   */
  interface AmenityFieldRefs {
    readonly id: FieldRef<"Amenity", 'String'>
    readonly Name: FieldRef<"Amenity", 'String'>
    readonly Status: FieldRef<"Amenity", 'String'>
    readonly createdAt: FieldRef<"Amenity", 'DateTime'>
    readonly updatedAt: FieldRef<"Amenity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Amenity findUnique
   */
  export type AmenityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Filter, which Amenity to fetch.
     */
    where: AmenityWhereUniqueInput
  }

  /**
   * Amenity findUniqueOrThrow
   */
  export type AmenityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Filter, which Amenity to fetch.
     */
    where: AmenityWhereUniqueInput
  }

  /**
   * Amenity findFirst
   */
  export type AmenityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Filter, which Amenity to fetch.
     */
    where?: AmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenityOrderByWithRelationInput | AmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Amenities.
     */
    cursor?: AmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Amenities.
     */
    distinct?: AmenityScalarFieldEnum | AmenityScalarFieldEnum[]
  }

  /**
   * Amenity findFirstOrThrow
   */
  export type AmenityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Filter, which Amenity to fetch.
     */
    where?: AmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenityOrderByWithRelationInput | AmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Amenities.
     */
    cursor?: AmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Amenities.
     */
    distinct?: AmenityScalarFieldEnum | AmenityScalarFieldEnum[]
  }

  /**
   * Amenity findMany
   */
  export type AmenityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Filter, which Amenities to fetch.
     */
    where?: AmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenityOrderByWithRelationInput | AmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Amenities.
     */
    cursor?: AmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    distinct?: AmenityScalarFieldEnum | AmenityScalarFieldEnum[]
  }

  /**
   * Amenity create
   */
  export type AmenityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * The data needed to create a Amenity.
     */
    data: XOR<AmenityCreateInput, AmenityUncheckedCreateInput>
  }

  /**
   * Amenity createMany
   */
  export type AmenityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Amenities.
     */
    data: AmenityCreateManyInput | AmenityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Amenity update
   */
  export type AmenityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * The data needed to update a Amenity.
     */
    data: XOR<AmenityUpdateInput, AmenityUncheckedUpdateInput>
    /**
     * Choose, which Amenity to update.
     */
    where: AmenityWhereUniqueInput
  }

  /**
   * Amenity updateMany
   */
  export type AmenityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Amenities.
     */
    data: XOR<AmenityUpdateManyMutationInput, AmenityUncheckedUpdateManyInput>
    /**
     * Filter which Amenities to update
     */
    where?: AmenityWhereInput
    /**
     * Limit how many Amenities to update.
     */
    limit?: number
  }

  /**
   * Amenity upsert
   */
  export type AmenityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * The filter to search for the Amenity to update in case it exists.
     */
    where: AmenityWhereUniqueInput
    /**
     * In case the Amenity found by the `where` argument doesn't exist, create a new Amenity with this data.
     */
    create: XOR<AmenityCreateInput, AmenityUncheckedCreateInput>
    /**
     * In case the Amenity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AmenityUpdateInput, AmenityUncheckedUpdateInput>
  }

  /**
   * Amenity delete
   */
  export type AmenityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Filter which Amenity to delete.
     */
    where: AmenityWhereUniqueInput
  }

  /**
   * Amenity deleteMany
   */
  export type AmenityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Amenities to delete
     */
    where?: AmenityWhereInput
    /**
     * Limit how many Amenities to delete.
     */
    limit?: number
  }

  /**
   * Amenity without action
   */
  export type AmenityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
  }


  /**
   * Model FunctionalArea
   */

  export type AggregateFunctionalArea = {
    _count: FunctionalAreaCountAggregateOutputType | null
    _min: FunctionalAreaMinAggregateOutputType | null
    _max: FunctionalAreaMaxAggregateOutputType | null
  }

  export type FunctionalAreaMinAggregateOutputType = {
    id: string | null
    Name: string | null
    Status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FunctionalAreaMaxAggregateOutputType = {
    id: string | null
    Name: string | null
    Status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FunctionalAreaCountAggregateOutputType = {
    id: number
    Name: number
    Status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FunctionalAreaMinAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FunctionalAreaMaxAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FunctionalAreaCountAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FunctionalAreaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FunctionalArea to aggregate.
     */
    where?: FunctionalAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FunctionalAreas to fetch.
     */
    orderBy?: FunctionalAreaOrderByWithRelationInput | FunctionalAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FunctionalAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FunctionalAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FunctionalAreas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FunctionalAreas
    **/
    _count?: true | FunctionalAreaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FunctionalAreaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FunctionalAreaMaxAggregateInputType
  }

  export type GetFunctionalAreaAggregateType<T extends FunctionalAreaAggregateArgs> = {
        [P in keyof T & keyof AggregateFunctionalArea]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFunctionalArea[P]>
      : GetScalarType<T[P], AggregateFunctionalArea[P]>
  }




  export type FunctionalAreaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FunctionalAreaWhereInput
    orderBy?: FunctionalAreaOrderByWithAggregationInput | FunctionalAreaOrderByWithAggregationInput[]
    by: FunctionalAreaScalarFieldEnum[] | FunctionalAreaScalarFieldEnum
    having?: FunctionalAreaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FunctionalAreaCountAggregateInputType | true
    _min?: FunctionalAreaMinAggregateInputType
    _max?: FunctionalAreaMaxAggregateInputType
  }

  export type FunctionalAreaGroupByOutputType = {
    id: string
    Name: string
    Status: string
    createdAt: Date
    updatedAt: Date
    _count: FunctionalAreaCountAggregateOutputType | null
    _min: FunctionalAreaMinAggregateOutputType | null
    _max: FunctionalAreaMaxAggregateOutputType | null
  }

  type GetFunctionalAreaGroupByPayload<T extends FunctionalAreaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FunctionalAreaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FunctionalAreaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FunctionalAreaGroupByOutputType[P]>
            : GetScalarType<T[P], FunctionalAreaGroupByOutputType[P]>
        }
      >
    >


  export type FunctionalAreaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Name?: boolean
    Status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["functionalArea"]>



  export type FunctionalAreaSelectScalar = {
    id?: boolean
    Name?: boolean
    Status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FunctionalAreaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "Name" | "Status" | "createdAt" | "updatedAt", ExtArgs["result"]["functionalArea"]>

  export type $FunctionalAreaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FunctionalArea"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      Name: string
      Status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["functionalArea"]>
    composites: {}
  }

  type FunctionalAreaGetPayload<S extends boolean | null | undefined | FunctionalAreaDefaultArgs> = $Result.GetResult<Prisma.$FunctionalAreaPayload, S>

  type FunctionalAreaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FunctionalAreaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FunctionalAreaCountAggregateInputType | true
    }

  export interface FunctionalAreaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FunctionalArea'], meta: { name: 'FunctionalArea' } }
    /**
     * Find zero or one FunctionalArea that matches the filter.
     * @param {FunctionalAreaFindUniqueArgs} args - Arguments to find a FunctionalArea
     * @example
     * // Get one FunctionalArea
     * const functionalArea = await prisma.functionalArea.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FunctionalAreaFindUniqueArgs>(args: SelectSubset<T, FunctionalAreaFindUniqueArgs<ExtArgs>>): Prisma__FunctionalAreaClient<$Result.GetResult<Prisma.$FunctionalAreaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FunctionalArea that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FunctionalAreaFindUniqueOrThrowArgs} args - Arguments to find a FunctionalArea
     * @example
     * // Get one FunctionalArea
     * const functionalArea = await prisma.functionalArea.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FunctionalAreaFindUniqueOrThrowArgs>(args: SelectSubset<T, FunctionalAreaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FunctionalAreaClient<$Result.GetResult<Prisma.$FunctionalAreaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FunctionalArea that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunctionalAreaFindFirstArgs} args - Arguments to find a FunctionalArea
     * @example
     * // Get one FunctionalArea
     * const functionalArea = await prisma.functionalArea.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FunctionalAreaFindFirstArgs>(args?: SelectSubset<T, FunctionalAreaFindFirstArgs<ExtArgs>>): Prisma__FunctionalAreaClient<$Result.GetResult<Prisma.$FunctionalAreaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FunctionalArea that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunctionalAreaFindFirstOrThrowArgs} args - Arguments to find a FunctionalArea
     * @example
     * // Get one FunctionalArea
     * const functionalArea = await prisma.functionalArea.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FunctionalAreaFindFirstOrThrowArgs>(args?: SelectSubset<T, FunctionalAreaFindFirstOrThrowArgs<ExtArgs>>): Prisma__FunctionalAreaClient<$Result.GetResult<Prisma.$FunctionalAreaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FunctionalAreas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunctionalAreaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FunctionalAreas
     * const functionalAreas = await prisma.functionalArea.findMany()
     * 
     * // Get first 10 FunctionalAreas
     * const functionalAreas = await prisma.functionalArea.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const functionalAreaWithIdOnly = await prisma.functionalArea.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FunctionalAreaFindManyArgs>(args?: SelectSubset<T, FunctionalAreaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FunctionalAreaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FunctionalArea.
     * @param {FunctionalAreaCreateArgs} args - Arguments to create a FunctionalArea.
     * @example
     * // Create one FunctionalArea
     * const FunctionalArea = await prisma.functionalArea.create({
     *   data: {
     *     // ... data to create a FunctionalArea
     *   }
     * })
     * 
     */
    create<T extends FunctionalAreaCreateArgs>(args: SelectSubset<T, FunctionalAreaCreateArgs<ExtArgs>>): Prisma__FunctionalAreaClient<$Result.GetResult<Prisma.$FunctionalAreaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FunctionalAreas.
     * @param {FunctionalAreaCreateManyArgs} args - Arguments to create many FunctionalAreas.
     * @example
     * // Create many FunctionalAreas
     * const functionalArea = await prisma.functionalArea.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FunctionalAreaCreateManyArgs>(args?: SelectSubset<T, FunctionalAreaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FunctionalArea.
     * @param {FunctionalAreaDeleteArgs} args - Arguments to delete one FunctionalArea.
     * @example
     * // Delete one FunctionalArea
     * const FunctionalArea = await prisma.functionalArea.delete({
     *   where: {
     *     // ... filter to delete one FunctionalArea
     *   }
     * })
     * 
     */
    delete<T extends FunctionalAreaDeleteArgs>(args: SelectSubset<T, FunctionalAreaDeleteArgs<ExtArgs>>): Prisma__FunctionalAreaClient<$Result.GetResult<Prisma.$FunctionalAreaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FunctionalArea.
     * @param {FunctionalAreaUpdateArgs} args - Arguments to update one FunctionalArea.
     * @example
     * // Update one FunctionalArea
     * const functionalArea = await prisma.functionalArea.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FunctionalAreaUpdateArgs>(args: SelectSubset<T, FunctionalAreaUpdateArgs<ExtArgs>>): Prisma__FunctionalAreaClient<$Result.GetResult<Prisma.$FunctionalAreaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FunctionalAreas.
     * @param {FunctionalAreaDeleteManyArgs} args - Arguments to filter FunctionalAreas to delete.
     * @example
     * // Delete a few FunctionalAreas
     * const { count } = await prisma.functionalArea.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FunctionalAreaDeleteManyArgs>(args?: SelectSubset<T, FunctionalAreaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FunctionalAreas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunctionalAreaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FunctionalAreas
     * const functionalArea = await prisma.functionalArea.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FunctionalAreaUpdateManyArgs>(args: SelectSubset<T, FunctionalAreaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FunctionalArea.
     * @param {FunctionalAreaUpsertArgs} args - Arguments to update or create a FunctionalArea.
     * @example
     * // Update or create a FunctionalArea
     * const functionalArea = await prisma.functionalArea.upsert({
     *   create: {
     *     // ... data to create a FunctionalArea
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FunctionalArea we want to update
     *   }
     * })
     */
    upsert<T extends FunctionalAreaUpsertArgs>(args: SelectSubset<T, FunctionalAreaUpsertArgs<ExtArgs>>): Prisma__FunctionalAreaClient<$Result.GetResult<Prisma.$FunctionalAreaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FunctionalAreas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunctionalAreaCountArgs} args - Arguments to filter FunctionalAreas to count.
     * @example
     * // Count the number of FunctionalAreas
     * const count = await prisma.functionalArea.count({
     *   where: {
     *     // ... the filter for the FunctionalAreas we want to count
     *   }
     * })
    **/
    count<T extends FunctionalAreaCountArgs>(
      args?: Subset<T, FunctionalAreaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FunctionalAreaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FunctionalArea.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunctionalAreaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FunctionalAreaAggregateArgs>(args: Subset<T, FunctionalAreaAggregateArgs>): Prisma.PrismaPromise<GetFunctionalAreaAggregateType<T>>

    /**
     * Group by FunctionalArea.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunctionalAreaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FunctionalAreaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FunctionalAreaGroupByArgs['orderBy'] }
        : { orderBy?: FunctionalAreaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FunctionalAreaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFunctionalAreaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FunctionalArea model
   */
  readonly fields: FunctionalAreaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FunctionalArea.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FunctionalAreaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FunctionalArea model
   */
  interface FunctionalAreaFieldRefs {
    readonly id: FieldRef<"FunctionalArea", 'String'>
    readonly Name: FieldRef<"FunctionalArea", 'String'>
    readonly Status: FieldRef<"FunctionalArea", 'String'>
    readonly createdAt: FieldRef<"FunctionalArea", 'DateTime'>
    readonly updatedAt: FieldRef<"FunctionalArea", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FunctionalArea findUnique
   */
  export type FunctionalAreaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunctionalArea
     */
    select?: FunctionalAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunctionalArea
     */
    omit?: FunctionalAreaOmit<ExtArgs> | null
    /**
     * Filter, which FunctionalArea to fetch.
     */
    where: FunctionalAreaWhereUniqueInput
  }

  /**
   * FunctionalArea findUniqueOrThrow
   */
  export type FunctionalAreaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunctionalArea
     */
    select?: FunctionalAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunctionalArea
     */
    omit?: FunctionalAreaOmit<ExtArgs> | null
    /**
     * Filter, which FunctionalArea to fetch.
     */
    where: FunctionalAreaWhereUniqueInput
  }

  /**
   * FunctionalArea findFirst
   */
  export type FunctionalAreaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunctionalArea
     */
    select?: FunctionalAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunctionalArea
     */
    omit?: FunctionalAreaOmit<ExtArgs> | null
    /**
     * Filter, which FunctionalArea to fetch.
     */
    where?: FunctionalAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FunctionalAreas to fetch.
     */
    orderBy?: FunctionalAreaOrderByWithRelationInput | FunctionalAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FunctionalAreas.
     */
    cursor?: FunctionalAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FunctionalAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FunctionalAreas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FunctionalAreas.
     */
    distinct?: FunctionalAreaScalarFieldEnum | FunctionalAreaScalarFieldEnum[]
  }

  /**
   * FunctionalArea findFirstOrThrow
   */
  export type FunctionalAreaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunctionalArea
     */
    select?: FunctionalAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunctionalArea
     */
    omit?: FunctionalAreaOmit<ExtArgs> | null
    /**
     * Filter, which FunctionalArea to fetch.
     */
    where?: FunctionalAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FunctionalAreas to fetch.
     */
    orderBy?: FunctionalAreaOrderByWithRelationInput | FunctionalAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FunctionalAreas.
     */
    cursor?: FunctionalAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FunctionalAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FunctionalAreas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FunctionalAreas.
     */
    distinct?: FunctionalAreaScalarFieldEnum | FunctionalAreaScalarFieldEnum[]
  }

  /**
   * FunctionalArea findMany
   */
  export type FunctionalAreaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunctionalArea
     */
    select?: FunctionalAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunctionalArea
     */
    omit?: FunctionalAreaOmit<ExtArgs> | null
    /**
     * Filter, which FunctionalAreas to fetch.
     */
    where?: FunctionalAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FunctionalAreas to fetch.
     */
    orderBy?: FunctionalAreaOrderByWithRelationInput | FunctionalAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FunctionalAreas.
     */
    cursor?: FunctionalAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FunctionalAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FunctionalAreas.
     */
    skip?: number
    distinct?: FunctionalAreaScalarFieldEnum | FunctionalAreaScalarFieldEnum[]
  }

  /**
   * FunctionalArea create
   */
  export type FunctionalAreaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunctionalArea
     */
    select?: FunctionalAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunctionalArea
     */
    omit?: FunctionalAreaOmit<ExtArgs> | null
    /**
     * The data needed to create a FunctionalArea.
     */
    data: XOR<FunctionalAreaCreateInput, FunctionalAreaUncheckedCreateInput>
  }

  /**
   * FunctionalArea createMany
   */
  export type FunctionalAreaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FunctionalAreas.
     */
    data: FunctionalAreaCreateManyInput | FunctionalAreaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FunctionalArea update
   */
  export type FunctionalAreaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunctionalArea
     */
    select?: FunctionalAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunctionalArea
     */
    omit?: FunctionalAreaOmit<ExtArgs> | null
    /**
     * The data needed to update a FunctionalArea.
     */
    data: XOR<FunctionalAreaUpdateInput, FunctionalAreaUncheckedUpdateInput>
    /**
     * Choose, which FunctionalArea to update.
     */
    where: FunctionalAreaWhereUniqueInput
  }

  /**
   * FunctionalArea updateMany
   */
  export type FunctionalAreaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FunctionalAreas.
     */
    data: XOR<FunctionalAreaUpdateManyMutationInput, FunctionalAreaUncheckedUpdateManyInput>
    /**
     * Filter which FunctionalAreas to update
     */
    where?: FunctionalAreaWhereInput
    /**
     * Limit how many FunctionalAreas to update.
     */
    limit?: number
  }

  /**
   * FunctionalArea upsert
   */
  export type FunctionalAreaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunctionalArea
     */
    select?: FunctionalAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunctionalArea
     */
    omit?: FunctionalAreaOmit<ExtArgs> | null
    /**
     * The filter to search for the FunctionalArea to update in case it exists.
     */
    where: FunctionalAreaWhereUniqueInput
    /**
     * In case the FunctionalArea found by the `where` argument doesn't exist, create a new FunctionalArea with this data.
     */
    create: XOR<FunctionalAreaCreateInput, FunctionalAreaUncheckedCreateInput>
    /**
     * In case the FunctionalArea was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FunctionalAreaUpdateInput, FunctionalAreaUncheckedUpdateInput>
  }

  /**
   * FunctionalArea delete
   */
  export type FunctionalAreaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunctionalArea
     */
    select?: FunctionalAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunctionalArea
     */
    omit?: FunctionalAreaOmit<ExtArgs> | null
    /**
     * Filter which FunctionalArea to delete.
     */
    where: FunctionalAreaWhereUniqueInput
  }

  /**
   * FunctionalArea deleteMany
   */
  export type FunctionalAreaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FunctionalAreas to delete
     */
    where?: FunctionalAreaWhereInput
    /**
     * Limit how many FunctionalAreas to delete.
     */
    limit?: number
  }

  /**
   * FunctionalArea without action
   */
  export type FunctionalAreaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunctionalArea
     */
    select?: FunctionalAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunctionalArea
     */
    omit?: FunctionalAreaOmit<ExtArgs> | null
  }


  /**
   * Model Industry
   */

  export type AggregateIndustry = {
    _count: IndustryCountAggregateOutputType | null
    _min: IndustryMinAggregateOutputType | null
    _max: IndustryMaxAggregateOutputType | null
  }

  export type IndustryMinAggregateOutputType = {
    id: string | null
    Name: string | null
    Status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IndustryMaxAggregateOutputType = {
    id: string | null
    Name: string | null
    Status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IndustryCountAggregateOutputType = {
    id: number
    Name: number
    Status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IndustryMinAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IndustryMaxAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IndustryCountAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IndustryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Industry to aggregate.
     */
    where?: IndustryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Industries to fetch.
     */
    orderBy?: IndustryOrderByWithRelationInput | IndustryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IndustryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Industries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Industries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Industries
    **/
    _count?: true | IndustryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IndustryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IndustryMaxAggregateInputType
  }

  export type GetIndustryAggregateType<T extends IndustryAggregateArgs> = {
        [P in keyof T & keyof AggregateIndustry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIndustry[P]>
      : GetScalarType<T[P], AggregateIndustry[P]>
  }




  export type IndustryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndustryWhereInput
    orderBy?: IndustryOrderByWithAggregationInput | IndustryOrderByWithAggregationInput[]
    by: IndustryScalarFieldEnum[] | IndustryScalarFieldEnum
    having?: IndustryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IndustryCountAggregateInputType | true
    _min?: IndustryMinAggregateInputType
    _max?: IndustryMaxAggregateInputType
  }

  export type IndustryGroupByOutputType = {
    id: string
    Name: string
    Status: string
    createdAt: Date
    updatedAt: Date
    _count: IndustryCountAggregateOutputType | null
    _min: IndustryMinAggregateOutputType | null
    _max: IndustryMaxAggregateOutputType | null
  }

  type GetIndustryGroupByPayload<T extends IndustryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IndustryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IndustryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IndustryGroupByOutputType[P]>
            : GetScalarType<T[P], IndustryGroupByOutputType[P]>
        }
      >
    >


  export type IndustrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Name?: boolean
    Status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["industry"]>



  export type IndustrySelectScalar = {
    id?: boolean
    Name?: boolean
    Status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IndustryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "Name" | "Status" | "createdAt" | "updatedAt", ExtArgs["result"]["industry"]>

  export type $IndustryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Industry"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      Name: string
      Status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["industry"]>
    composites: {}
  }

  type IndustryGetPayload<S extends boolean | null | undefined | IndustryDefaultArgs> = $Result.GetResult<Prisma.$IndustryPayload, S>

  type IndustryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IndustryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IndustryCountAggregateInputType | true
    }

  export interface IndustryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Industry'], meta: { name: 'Industry' } }
    /**
     * Find zero or one Industry that matches the filter.
     * @param {IndustryFindUniqueArgs} args - Arguments to find a Industry
     * @example
     * // Get one Industry
     * const industry = await prisma.industry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IndustryFindUniqueArgs>(args: SelectSubset<T, IndustryFindUniqueArgs<ExtArgs>>): Prisma__IndustryClient<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Industry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IndustryFindUniqueOrThrowArgs} args - Arguments to find a Industry
     * @example
     * // Get one Industry
     * const industry = await prisma.industry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IndustryFindUniqueOrThrowArgs>(args: SelectSubset<T, IndustryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IndustryClient<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Industry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndustryFindFirstArgs} args - Arguments to find a Industry
     * @example
     * // Get one Industry
     * const industry = await prisma.industry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IndustryFindFirstArgs>(args?: SelectSubset<T, IndustryFindFirstArgs<ExtArgs>>): Prisma__IndustryClient<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Industry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndustryFindFirstOrThrowArgs} args - Arguments to find a Industry
     * @example
     * // Get one Industry
     * const industry = await prisma.industry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IndustryFindFirstOrThrowArgs>(args?: SelectSubset<T, IndustryFindFirstOrThrowArgs<ExtArgs>>): Prisma__IndustryClient<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Industries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndustryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Industries
     * const industries = await prisma.industry.findMany()
     * 
     * // Get first 10 Industries
     * const industries = await prisma.industry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const industryWithIdOnly = await prisma.industry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IndustryFindManyArgs>(args?: SelectSubset<T, IndustryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Industry.
     * @param {IndustryCreateArgs} args - Arguments to create a Industry.
     * @example
     * // Create one Industry
     * const Industry = await prisma.industry.create({
     *   data: {
     *     // ... data to create a Industry
     *   }
     * })
     * 
     */
    create<T extends IndustryCreateArgs>(args: SelectSubset<T, IndustryCreateArgs<ExtArgs>>): Prisma__IndustryClient<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Industries.
     * @param {IndustryCreateManyArgs} args - Arguments to create many Industries.
     * @example
     * // Create many Industries
     * const industry = await prisma.industry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IndustryCreateManyArgs>(args?: SelectSubset<T, IndustryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Industry.
     * @param {IndustryDeleteArgs} args - Arguments to delete one Industry.
     * @example
     * // Delete one Industry
     * const Industry = await prisma.industry.delete({
     *   where: {
     *     // ... filter to delete one Industry
     *   }
     * })
     * 
     */
    delete<T extends IndustryDeleteArgs>(args: SelectSubset<T, IndustryDeleteArgs<ExtArgs>>): Prisma__IndustryClient<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Industry.
     * @param {IndustryUpdateArgs} args - Arguments to update one Industry.
     * @example
     * // Update one Industry
     * const industry = await prisma.industry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IndustryUpdateArgs>(args: SelectSubset<T, IndustryUpdateArgs<ExtArgs>>): Prisma__IndustryClient<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Industries.
     * @param {IndustryDeleteManyArgs} args - Arguments to filter Industries to delete.
     * @example
     * // Delete a few Industries
     * const { count } = await prisma.industry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IndustryDeleteManyArgs>(args?: SelectSubset<T, IndustryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Industries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndustryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Industries
     * const industry = await prisma.industry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IndustryUpdateManyArgs>(args: SelectSubset<T, IndustryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Industry.
     * @param {IndustryUpsertArgs} args - Arguments to update or create a Industry.
     * @example
     * // Update or create a Industry
     * const industry = await prisma.industry.upsert({
     *   create: {
     *     // ... data to create a Industry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Industry we want to update
     *   }
     * })
     */
    upsert<T extends IndustryUpsertArgs>(args: SelectSubset<T, IndustryUpsertArgs<ExtArgs>>): Prisma__IndustryClient<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Industries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndustryCountArgs} args - Arguments to filter Industries to count.
     * @example
     * // Count the number of Industries
     * const count = await prisma.industry.count({
     *   where: {
     *     // ... the filter for the Industries we want to count
     *   }
     * })
    **/
    count<T extends IndustryCountArgs>(
      args?: Subset<T, IndustryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IndustryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Industry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndustryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IndustryAggregateArgs>(args: Subset<T, IndustryAggregateArgs>): Prisma.PrismaPromise<GetIndustryAggregateType<T>>

    /**
     * Group by Industry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndustryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IndustryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IndustryGroupByArgs['orderBy'] }
        : { orderBy?: IndustryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IndustryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIndustryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Industry model
   */
  readonly fields: IndustryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Industry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IndustryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Industry model
   */
  interface IndustryFieldRefs {
    readonly id: FieldRef<"Industry", 'String'>
    readonly Name: FieldRef<"Industry", 'String'>
    readonly Status: FieldRef<"Industry", 'String'>
    readonly createdAt: FieldRef<"Industry", 'DateTime'>
    readonly updatedAt: FieldRef<"Industry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Industry findUnique
   */
  export type IndustryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Industry
     */
    select?: IndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Industry
     */
    omit?: IndustryOmit<ExtArgs> | null
    /**
     * Filter, which Industry to fetch.
     */
    where: IndustryWhereUniqueInput
  }

  /**
   * Industry findUniqueOrThrow
   */
  export type IndustryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Industry
     */
    select?: IndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Industry
     */
    omit?: IndustryOmit<ExtArgs> | null
    /**
     * Filter, which Industry to fetch.
     */
    where: IndustryWhereUniqueInput
  }

  /**
   * Industry findFirst
   */
  export type IndustryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Industry
     */
    select?: IndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Industry
     */
    omit?: IndustryOmit<ExtArgs> | null
    /**
     * Filter, which Industry to fetch.
     */
    where?: IndustryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Industries to fetch.
     */
    orderBy?: IndustryOrderByWithRelationInput | IndustryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Industries.
     */
    cursor?: IndustryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Industries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Industries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Industries.
     */
    distinct?: IndustryScalarFieldEnum | IndustryScalarFieldEnum[]
  }

  /**
   * Industry findFirstOrThrow
   */
  export type IndustryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Industry
     */
    select?: IndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Industry
     */
    omit?: IndustryOmit<ExtArgs> | null
    /**
     * Filter, which Industry to fetch.
     */
    where?: IndustryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Industries to fetch.
     */
    orderBy?: IndustryOrderByWithRelationInput | IndustryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Industries.
     */
    cursor?: IndustryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Industries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Industries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Industries.
     */
    distinct?: IndustryScalarFieldEnum | IndustryScalarFieldEnum[]
  }

  /**
   * Industry findMany
   */
  export type IndustryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Industry
     */
    select?: IndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Industry
     */
    omit?: IndustryOmit<ExtArgs> | null
    /**
     * Filter, which Industries to fetch.
     */
    where?: IndustryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Industries to fetch.
     */
    orderBy?: IndustryOrderByWithRelationInput | IndustryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Industries.
     */
    cursor?: IndustryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Industries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Industries.
     */
    skip?: number
    distinct?: IndustryScalarFieldEnum | IndustryScalarFieldEnum[]
  }

  /**
   * Industry create
   */
  export type IndustryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Industry
     */
    select?: IndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Industry
     */
    omit?: IndustryOmit<ExtArgs> | null
    /**
     * The data needed to create a Industry.
     */
    data: XOR<IndustryCreateInput, IndustryUncheckedCreateInput>
  }

  /**
   * Industry createMany
   */
  export type IndustryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Industries.
     */
    data: IndustryCreateManyInput | IndustryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Industry update
   */
  export type IndustryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Industry
     */
    select?: IndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Industry
     */
    omit?: IndustryOmit<ExtArgs> | null
    /**
     * The data needed to update a Industry.
     */
    data: XOR<IndustryUpdateInput, IndustryUncheckedUpdateInput>
    /**
     * Choose, which Industry to update.
     */
    where: IndustryWhereUniqueInput
  }

  /**
   * Industry updateMany
   */
  export type IndustryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Industries.
     */
    data: XOR<IndustryUpdateManyMutationInput, IndustryUncheckedUpdateManyInput>
    /**
     * Filter which Industries to update
     */
    where?: IndustryWhereInput
    /**
     * Limit how many Industries to update.
     */
    limit?: number
  }

  /**
   * Industry upsert
   */
  export type IndustryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Industry
     */
    select?: IndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Industry
     */
    omit?: IndustryOmit<ExtArgs> | null
    /**
     * The filter to search for the Industry to update in case it exists.
     */
    where: IndustryWhereUniqueInput
    /**
     * In case the Industry found by the `where` argument doesn't exist, create a new Industry with this data.
     */
    create: XOR<IndustryCreateInput, IndustryUncheckedCreateInput>
    /**
     * In case the Industry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IndustryUpdateInput, IndustryUncheckedUpdateInput>
  }

  /**
   * Industry delete
   */
  export type IndustryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Industry
     */
    select?: IndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Industry
     */
    omit?: IndustryOmit<ExtArgs> | null
    /**
     * Filter which Industry to delete.
     */
    where: IndustryWhereUniqueInput
  }

  /**
   * Industry deleteMany
   */
  export type IndustryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Industries to delete
     */
    where?: IndustryWhereInput
    /**
     * Limit how many Industries to delete.
     */
    limit?: number
  }

  /**
   * Industry without action
   */
  export type IndustryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Industry
     */
    select?: IndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Industry
     */
    omit?: IndustryOmit<ExtArgs> | null
  }


  /**
   * Model Reference
   */

  export type AggregateReference = {
    _count: ReferenceCountAggregateOutputType | null
    _min: ReferenceMinAggregateOutputType | null
    _max: ReferenceMaxAggregateOutputType | null
  }

  export type ReferenceMinAggregateOutputType = {
    id: string | null
    Name: string | null
    Status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReferenceMaxAggregateOutputType = {
    id: string | null
    Name: string | null
    Status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReferenceCountAggregateOutputType = {
    id: number
    Name: number
    Status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReferenceMinAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReferenceMaxAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReferenceCountAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reference to aggregate.
     */
    where?: ReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of References to fetch.
     */
    orderBy?: ReferenceOrderByWithRelationInput | ReferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` References from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` References.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned References
    **/
    _count?: true | ReferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferenceMaxAggregateInputType
  }

  export type GetReferenceAggregateType<T extends ReferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateReference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReference[P]>
      : GetScalarType<T[P], AggregateReference[P]>
  }




  export type ReferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferenceWhereInput
    orderBy?: ReferenceOrderByWithAggregationInput | ReferenceOrderByWithAggregationInput[]
    by: ReferenceScalarFieldEnum[] | ReferenceScalarFieldEnum
    having?: ReferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferenceCountAggregateInputType | true
    _min?: ReferenceMinAggregateInputType
    _max?: ReferenceMaxAggregateInputType
  }

  export type ReferenceGroupByOutputType = {
    id: string
    Name: string
    Status: string
    createdAt: Date
    updatedAt: Date
    _count: ReferenceCountAggregateOutputType | null
    _min: ReferenceMinAggregateOutputType | null
    _max: ReferenceMaxAggregateOutputType | null
  }

  type GetReferenceGroupByPayload<T extends ReferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferenceGroupByOutputType[P]>
            : GetScalarType<T[P], ReferenceGroupByOutputType[P]>
        }
      >
    >


  export type ReferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Name?: boolean
    Status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["reference"]>



  export type ReferenceSelectScalar = {
    id?: boolean
    Name?: boolean
    Status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReferenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "Name" | "Status" | "createdAt" | "updatedAt", ExtArgs["result"]["reference"]>

  export type $ReferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reference"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      Name: string
      Status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["reference"]>
    composites: {}
  }

  type ReferenceGetPayload<S extends boolean | null | undefined | ReferenceDefaultArgs> = $Result.GetResult<Prisma.$ReferencePayload, S>

  type ReferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReferenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReferenceCountAggregateInputType | true
    }

  export interface ReferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reference'], meta: { name: 'Reference' } }
    /**
     * Find zero or one Reference that matches the filter.
     * @param {ReferenceFindUniqueArgs} args - Arguments to find a Reference
     * @example
     * // Get one Reference
     * const reference = await prisma.reference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReferenceFindUniqueArgs>(args: SelectSubset<T, ReferenceFindUniqueArgs<ExtArgs>>): Prisma__ReferenceClient<$Result.GetResult<Prisma.$ReferencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reference that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReferenceFindUniqueOrThrowArgs} args - Arguments to find a Reference
     * @example
     * // Get one Reference
     * const reference = await prisma.reference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReferenceFindUniqueOrThrowArgs>(args: SelectSubset<T, ReferenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReferenceClient<$Result.GetResult<Prisma.$ReferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceFindFirstArgs} args - Arguments to find a Reference
     * @example
     * // Get one Reference
     * const reference = await prisma.reference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReferenceFindFirstArgs>(args?: SelectSubset<T, ReferenceFindFirstArgs<ExtArgs>>): Prisma__ReferenceClient<$Result.GetResult<Prisma.$ReferencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceFindFirstOrThrowArgs} args - Arguments to find a Reference
     * @example
     * // Get one Reference
     * const reference = await prisma.reference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReferenceFindFirstOrThrowArgs>(args?: SelectSubset<T, ReferenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReferenceClient<$Result.GetResult<Prisma.$ReferencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more References that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all References
     * const references = await prisma.reference.findMany()
     * 
     * // Get first 10 References
     * const references = await prisma.reference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referenceWithIdOnly = await prisma.reference.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReferenceFindManyArgs>(args?: SelectSubset<T, ReferenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reference.
     * @param {ReferenceCreateArgs} args - Arguments to create a Reference.
     * @example
     * // Create one Reference
     * const Reference = await prisma.reference.create({
     *   data: {
     *     // ... data to create a Reference
     *   }
     * })
     * 
     */
    create<T extends ReferenceCreateArgs>(args: SelectSubset<T, ReferenceCreateArgs<ExtArgs>>): Prisma__ReferenceClient<$Result.GetResult<Prisma.$ReferencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many References.
     * @param {ReferenceCreateManyArgs} args - Arguments to create many References.
     * @example
     * // Create many References
     * const reference = await prisma.reference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReferenceCreateManyArgs>(args?: SelectSubset<T, ReferenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Reference.
     * @param {ReferenceDeleteArgs} args - Arguments to delete one Reference.
     * @example
     * // Delete one Reference
     * const Reference = await prisma.reference.delete({
     *   where: {
     *     // ... filter to delete one Reference
     *   }
     * })
     * 
     */
    delete<T extends ReferenceDeleteArgs>(args: SelectSubset<T, ReferenceDeleteArgs<ExtArgs>>): Prisma__ReferenceClient<$Result.GetResult<Prisma.$ReferencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reference.
     * @param {ReferenceUpdateArgs} args - Arguments to update one Reference.
     * @example
     * // Update one Reference
     * const reference = await prisma.reference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReferenceUpdateArgs>(args: SelectSubset<T, ReferenceUpdateArgs<ExtArgs>>): Prisma__ReferenceClient<$Result.GetResult<Prisma.$ReferencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more References.
     * @param {ReferenceDeleteManyArgs} args - Arguments to filter References to delete.
     * @example
     * // Delete a few References
     * const { count } = await prisma.reference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReferenceDeleteManyArgs>(args?: SelectSubset<T, ReferenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more References.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many References
     * const reference = await prisma.reference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReferenceUpdateManyArgs>(args: SelectSubset<T, ReferenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reference.
     * @param {ReferenceUpsertArgs} args - Arguments to update or create a Reference.
     * @example
     * // Update or create a Reference
     * const reference = await prisma.reference.upsert({
     *   create: {
     *     // ... data to create a Reference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reference we want to update
     *   }
     * })
     */
    upsert<T extends ReferenceUpsertArgs>(args: SelectSubset<T, ReferenceUpsertArgs<ExtArgs>>): Prisma__ReferenceClient<$Result.GetResult<Prisma.$ReferencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of References.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceCountArgs} args - Arguments to filter References to count.
     * @example
     * // Count the number of References
     * const count = await prisma.reference.count({
     *   where: {
     *     // ... the filter for the References we want to count
     *   }
     * })
    **/
    count<T extends ReferenceCountArgs>(
      args?: Subset<T, ReferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferenceAggregateArgs>(args: Subset<T, ReferenceAggregateArgs>): Prisma.PrismaPromise<GetReferenceAggregateType<T>>

    /**
     * Group by Reference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferenceGroupByArgs['orderBy'] }
        : { orderBy?: ReferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reference model
   */
  readonly fields: ReferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reference model
   */
  interface ReferenceFieldRefs {
    readonly id: FieldRef<"Reference", 'String'>
    readonly Name: FieldRef<"Reference", 'String'>
    readonly Status: FieldRef<"Reference", 'String'>
    readonly createdAt: FieldRef<"Reference", 'DateTime'>
    readonly updatedAt: FieldRef<"Reference", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Reference findUnique
   */
  export type ReferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reference
     */
    select?: ReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reference
     */
    omit?: ReferenceOmit<ExtArgs> | null
    /**
     * Filter, which Reference to fetch.
     */
    where: ReferenceWhereUniqueInput
  }

  /**
   * Reference findUniqueOrThrow
   */
  export type ReferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reference
     */
    select?: ReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reference
     */
    omit?: ReferenceOmit<ExtArgs> | null
    /**
     * Filter, which Reference to fetch.
     */
    where: ReferenceWhereUniqueInput
  }

  /**
   * Reference findFirst
   */
  export type ReferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reference
     */
    select?: ReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reference
     */
    omit?: ReferenceOmit<ExtArgs> | null
    /**
     * Filter, which Reference to fetch.
     */
    where?: ReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of References to fetch.
     */
    orderBy?: ReferenceOrderByWithRelationInput | ReferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for References.
     */
    cursor?: ReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` References from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` References.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of References.
     */
    distinct?: ReferenceScalarFieldEnum | ReferenceScalarFieldEnum[]
  }

  /**
   * Reference findFirstOrThrow
   */
  export type ReferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reference
     */
    select?: ReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reference
     */
    omit?: ReferenceOmit<ExtArgs> | null
    /**
     * Filter, which Reference to fetch.
     */
    where?: ReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of References to fetch.
     */
    orderBy?: ReferenceOrderByWithRelationInput | ReferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for References.
     */
    cursor?: ReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` References from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` References.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of References.
     */
    distinct?: ReferenceScalarFieldEnum | ReferenceScalarFieldEnum[]
  }

  /**
   * Reference findMany
   */
  export type ReferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reference
     */
    select?: ReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reference
     */
    omit?: ReferenceOmit<ExtArgs> | null
    /**
     * Filter, which References to fetch.
     */
    where?: ReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of References to fetch.
     */
    orderBy?: ReferenceOrderByWithRelationInput | ReferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing References.
     */
    cursor?: ReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` References from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` References.
     */
    skip?: number
    distinct?: ReferenceScalarFieldEnum | ReferenceScalarFieldEnum[]
  }

  /**
   * Reference create
   */
  export type ReferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reference
     */
    select?: ReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reference
     */
    omit?: ReferenceOmit<ExtArgs> | null
    /**
     * The data needed to create a Reference.
     */
    data: XOR<ReferenceCreateInput, ReferenceUncheckedCreateInput>
  }

  /**
   * Reference createMany
   */
  export type ReferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many References.
     */
    data: ReferenceCreateManyInput | ReferenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reference update
   */
  export type ReferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reference
     */
    select?: ReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reference
     */
    omit?: ReferenceOmit<ExtArgs> | null
    /**
     * The data needed to update a Reference.
     */
    data: XOR<ReferenceUpdateInput, ReferenceUncheckedUpdateInput>
    /**
     * Choose, which Reference to update.
     */
    where: ReferenceWhereUniqueInput
  }

  /**
   * Reference updateMany
   */
  export type ReferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update References.
     */
    data: XOR<ReferenceUpdateManyMutationInput, ReferenceUncheckedUpdateManyInput>
    /**
     * Filter which References to update
     */
    where?: ReferenceWhereInput
    /**
     * Limit how many References to update.
     */
    limit?: number
  }

  /**
   * Reference upsert
   */
  export type ReferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reference
     */
    select?: ReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reference
     */
    omit?: ReferenceOmit<ExtArgs> | null
    /**
     * The filter to search for the Reference to update in case it exists.
     */
    where: ReferenceWhereUniqueInput
    /**
     * In case the Reference found by the `where` argument doesn't exist, create a new Reference with this data.
     */
    create: XOR<ReferenceCreateInput, ReferenceUncheckedCreateInput>
    /**
     * In case the Reference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferenceUpdateInput, ReferenceUncheckedUpdateInput>
  }

  /**
   * Reference delete
   */
  export type ReferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reference
     */
    select?: ReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reference
     */
    omit?: ReferenceOmit<ExtArgs> | null
    /**
     * Filter which Reference to delete.
     */
    where: ReferenceWhereUniqueInput
  }

  /**
   * Reference deleteMany
   */
  export type ReferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which References to delete
     */
    where?: ReferenceWhereInput
    /**
     * Limit how many References to delete.
     */
    limit?: number
  }

  /**
   * Reference without action
   */
  export type ReferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reference
     */
    select?: ReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reference
     */
    omit?: ReferenceOmit<ExtArgs> | null
  }


  /**
   * Model Expense
   */

  export type AggregateExpense = {
    _count: ExpenseCountAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  export type ExpenseMinAggregateOutputType = {
    id: string | null
    Name: string | null
    Status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpenseMaxAggregateOutputType = {
    id: string | null
    Name: string | null
    Status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpenseCountAggregateOutputType = {
    id: number
    Name: number
    Status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExpenseMinAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpenseMaxAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpenseCountAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExpenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expense to aggregate.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Expenses
    **/
    _count?: true | ExpenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseMaxAggregateInputType
  }

  export type GetExpenseAggregateType<T extends ExpenseAggregateArgs> = {
        [P in keyof T & keyof AggregateExpense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpense[P]>
      : GetScalarType<T[P], AggregateExpense[P]>
  }




  export type ExpenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithAggregationInput | ExpenseOrderByWithAggregationInput[]
    by: ExpenseScalarFieldEnum[] | ExpenseScalarFieldEnum
    having?: ExpenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseCountAggregateInputType | true
    _min?: ExpenseMinAggregateInputType
    _max?: ExpenseMaxAggregateInputType
  }

  export type ExpenseGroupByOutputType = {
    id: string
    Name: string
    Status: string
    createdAt: Date
    updatedAt: Date
    _count: ExpenseCountAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  type GetExpenseGroupByPayload<T extends ExpenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Name?: boolean
    Status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["expense"]>



  export type ExpenseSelectScalar = {
    id?: boolean
    Name?: boolean
    Status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExpenseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "Name" | "Status" | "createdAt" | "updatedAt", ExtArgs["result"]["expense"]>

  export type $ExpensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Expense"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      Name: string
      Status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["expense"]>
    composites: {}
  }

  type ExpenseGetPayload<S extends boolean | null | undefined | ExpenseDefaultArgs> = $Result.GetResult<Prisma.$ExpensePayload, S>

  type ExpenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExpenseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExpenseCountAggregateInputType | true
    }

  export interface ExpenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Expense'], meta: { name: 'Expense' } }
    /**
     * Find zero or one Expense that matches the filter.
     * @param {ExpenseFindUniqueArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseFindUniqueArgs>(args: SelectSubset<T, ExpenseFindUniqueArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Expense that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExpenseFindUniqueOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseFindFirstArgs>(args?: SelectSubset<T, ExpenseFindFirstArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expense that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Expenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Expenses
     * const expenses = await prisma.expense.findMany()
     * 
     * // Get first 10 Expenses
     * const expenses = await prisma.expense.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseWithIdOnly = await prisma.expense.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseFindManyArgs>(args?: SelectSubset<T, ExpenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Expense.
     * @param {ExpenseCreateArgs} args - Arguments to create a Expense.
     * @example
     * // Create one Expense
     * const Expense = await prisma.expense.create({
     *   data: {
     *     // ... data to create a Expense
     *   }
     * })
     * 
     */
    create<T extends ExpenseCreateArgs>(args: SelectSubset<T, ExpenseCreateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Expenses.
     * @param {ExpenseCreateManyArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseCreateManyArgs>(args?: SelectSubset<T, ExpenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Expense.
     * @param {ExpenseDeleteArgs} args - Arguments to delete one Expense.
     * @example
     * // Delete one Expense
     * const Expense = await prisma.expense.delete({
     *   where: {
     *     // ... filter to delete one Expense
     *   }
     * })
     * 
     */
    delete<T extends ExpenseDeleteArgs>(args: SelectSubset<T, ExpenseDeleteArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Expense.
     * @param {ExpenseUpdateArgs} args - Arguments to update one Expense.
     * @example
     * // Update one Expense
     * const expense = await prisma.expense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseUpdateArgs>(args: SelectSubset<T, ExpenseUpdateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Expenses.
     * @param {ExpenseDeleteManyArgs} args - Arguments to filter Expenses to delete.
     * @example
     * // Delete a few Expenses
     * const { count } = await prisma.expense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseDeleteManyArgs>(args?: SelectSubset<T, ExpenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseUpdateManyArgs>(args: SelectSubset<T, ExpenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Expense.
     * @param {ExpenseUpsertArgs} args - Arguments to update or create a Expense.
     * @example
     * // Update or create a Expense
     * const expense = await prisma.expense.upsert({
     *   create: {
     *     // ... data to create a Expense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Expense we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseUpsertArgs>(args: SelectSubset<T, ExpenseUpsertArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCountArgs} args - Arguments to filter Expenses to count.
     * @example
     * // Count the number of Expenses
     * const count = await prisma.expense.count({
     *   where: {
     *     // ... the filter for the Expenses we want to count
     *   }
     * })
    **/
    count<T extends ExpenseCountArgs>(
      args?: Subset<T, ExpenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseAggregateArgs>(args: Subset<T, ExpenseAggregateArgs>): Prisma.PrismaPromise<GetExpenseAggregateType<T>>

    /**
     * Group by Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Expense model
   */
  readonly fields: ExpenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Expense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Expense model
   */
  interface ExpenseFieldRefs {
    readonly id: FieldRef<"Expense", 'String'>
    readonly Name: FieldRef<"Expense", 'String'>
    readonly Status: FieldRef<"Expense", 'String'>
    readonly createdAt: FieldRef<"Expense", 'DateTime'>
    readonly updatedAt: FieldRef<"Expense", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Expense findUnique
   */
  export type ExpenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findUniqueOrThrow
   */
  export type ExpenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findFirst
   */
  export type ExpenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findFirstOrThrow
   */
  export type ExpenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findMany
   */
  export type ExpenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Filter, which Expenses to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense create
   */
  export type ExpenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The data needed to create a Expense.
     */
    data: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
  }

  /**
   * Expense createMany
   */
  export type ExpenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Expense update
   */
  export type ExpenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The data needed to update a Expense.
     */
    data: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
    /**
     * Choose, which Expense to update.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense updateMany
   */
  export type ExpenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to update.
     */
    limit?: number
  }

  /**
   * Expense upsert
   */
  export type ExpenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The filter to search for the Expense to update in case it exists.
     */
    where: ExpenseWhereUniqueInput
    /**
     * In case the Expense found by the `where` argument doesn't exist, create a new Expense with this data.
     */
    create: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
    /**
     * In case the Expense was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
  }

  /**
   * Expense delete
   */
  export type ExpenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Filter which Expense to delete.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense deleteMany
   */
  export type ExpenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expenses to delete
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to delete.
     */
    limit?: number
  }

  /**
   * Expense without action
   */
  export type ExpenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
  }


  /**
   * Model Income
   */

  export type AggregateIncome = {
    _count: IncomeCountAggregateOutputType | null
    _min: IncomeMinAggregateOutputType | null
    _max: IncomeMaxAggregateOutputType | null
  }

  export type IncomeMinAggregateOutputType = {
    id: string | null
    Name: string | null
    Status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IncomeMaxAggregateOutputType = {
    id: string | null
    Name: string | null
    Status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IncomeCountAggregateOutputType = {
    id: number
    Name: number
    Status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IncomeMinAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IncomeMaxAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IncomeCountAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IncomeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Income to aggregate.
     */
    where?: IncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incomes to fetch.
     */
    orderBy?: IncomeOrderByWithRelationInput | IncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Incomes
    **/
    _count?: true | IncomeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IncomeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IncomeMaxAggregateInputType
  }

  export type GetIncomeAggregateType<T extends IncomeAggregateArgs> = {
        [P in keyof T & keyof AggregateIncome]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncome[P]>
      : GetScalarType<T[P], AggregateIncome[P]>
  }




  export type IncomeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncomeWhereInput
    orderBy?: IncomeOrderByWithAggregationInput | IncomeOrderByWithAggregationInput[]
    by: IncomeScalarFieldEnum[] | IncomeScalarFieldEnum
    having?: IncomeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IncomeCountAggregateInputType | true
    _min?: IncomeMinAggregateInputType
    _max?: IncomeMaxAggregateInputType
  }

  export type IncomeGroupByOutputType = {
    id: string
    Name: string
    Status: string
    createdAt: Date
    updatedAt: Date
    _count: IncomeCountAggregateOutputType | null
    _min: IncomeMinAggregateOutputType | null
    _max: IncomeMaxAggregateOutputType | null
  }

  type GetIncomeGroupByPayload<T extends IncomeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IncomeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IncomeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IncomeGroupByOutputType[P]>
            : GetScalarType<T[P], IncomeGroupByOutputType[P]>
        }
      >
    >


  export type IncomeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Name?: boolean
    Status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["income"]>



  export type IncomeSelectScalar = {
    id?: boolean
    Name?: boolean
    Status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IncomeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "Name" | "Status" | "createdAt" | "updatedAt", ExtArgs["result"]["income"]>

  export type $IncomePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Income"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      Name: string
      Status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["income"]>
    composites: {}
  }

  type IncomeGetPayload<S extends boolean | null | undefined | IncomeDefaultArgs> = $Result.GetResult<Prisma.$IncomePayload, S>

  type IncomeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IncomeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IncomeCountAggregateInputType | true
    }

  export interface IncomeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Income'], meta: { name: 'Income' } }
    /**
     * Find zero or one Income that matches the filter.
     * @param {IncomeFindUniqueArgs} args - Arguments to find a Income
     * @example
     * // Get one Income
     * const income = await prisma.income.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IncomeFindUniqueArgs>(args: SelectSubset<T, IncomeFindUniqueArgs<ExtArgs>>): Prisma__IncomeClient<$Result.GetResult<Prisma.$IncomePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Income that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IncomeFindUniqueOrThrowArgs} args - Arguments to find a Income
     * @example
     * // Get one Income
     * const income = await prisma.income.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IncomeFindUniqueOrThrowArgs>(args: SelectSubset<T, IncomeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IncomeClient<$Result.GetResult<Prisma.$IncomePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Income that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeFindFirstArgs} args - Arguments to find a Income
     * @example
     * // Get one Income
     * const income = await prisma.income.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IncomeFindFirstArgs>(args?: SelectSubset<T, IncomeFindFirstArgs<ExtArgs>>): Prisma__IncomeClient<$Result.GetResult<Prisma.$IncomePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Income that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeFindFirstOrThrowArgs} args - Arguments to find a Income
     * @example
     * // Get one Income
     * const income = await prisma.income.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IncomeFindFirstOrThrowArgs>(args?: SelectSubset<T, IncomeFindFirstOrThrowArgs<ExtArgs>>): Prisma__IncomeClient<$Result.GetResult<Prisma.$IncomePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Incomes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Incomes
     * const incomes = await prisma.income.findMany()
     * 
     * // Get first 10 Incomes
     * const incomes = await prisma.income.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const incomeWithIdOnly = await prisma.income.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IncomeFindManyArgs>(args?: SelectSubset<T, IncomeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncomePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Income.
     * @param {IncomeCreateArgs} args - Arguments to create a Income.
     * @example
     * // Create one Income
     * const Income = await prisma.income.create({
     *   data: {
     *     // ... data to create a Income
     *   }
     * })
     * 
     */
    create<T extends IncomeCreateArgs>(args: SelectSubset<T, IncomeCreateArgs<ExtArgs>>): Prisma__IncomeClient<$Result.GetResult<Prisma.$IncomePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Incomes.
     * @param {IncomeCreateManyArgs} args - Arguments to create many Incomes.
     * @example
     * // Create many Incomes
     * const income = await prisma.income.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IncomeCreateManyArgs>(args?: SelectSubset<T, IncomeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Income.
     * @param {IncomeDeleteArgs} args - Arguments to delete one Income.
     * @example
     * // Delete one Income
     * const Income = await prisma.income.delete({
     *   where: {
     *     // ... filter to delete one Income
     *   }
     * })
     * 
     */
    delete<T extends IncomeDeleteArgs>(args: SelectSubset<T, IncomeDeleteArgs<ExtArgs>>): Prisma__IncomeClient<$Result.GetResult<Prisma.$IncomePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Income.
     * @param {IncomeUpdateArgs} args - Arguments to update one Income.
     * @example
     * // Update one Income
     * const income = await prisma.income.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IncomeUpdateArgs>(args: SelectSubset<T, IncomeUpdateArgs<ExtArgs>>): Prisma__IncomeClient<$Result.GetResult<Prisma.$IncomePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Incomes.
     * @param {IncomeDeleteManyArgs} args - Arguments to filter Incomes to delete.
     * @example
     * // Delete a few Incomes
     * const { count } = await prisma.income.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IncomeDeleteManyArgs>(args?: SelectSubset<T, IncomeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Incomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Incomes
     * const income = await prisma.income.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IncomeUpdateManyArgs>(args: SelectSubset<T, IncomeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Income.
     * @param {IncomeUpsertArgs} args - Arguments to update or create a Income.
     * @example
     * // Update or create a Income
     * const income = await prisma.income.upsert({
     *   create: {
     *     // ... data to create a Income
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Income we want to update
     *   }
     * })
     */
    upsert<T extends IncomeUpsertArgs>(args: SelectSubset<T, IncomeUpsertArgs<ExtArgs>>): Prisma__IncomeClient<$Result.GetResult<Prisma.$IncomePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Incomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeCountArgs} args - Arguments to filter Incomes to count.
     * @example
     * // Count the number of Incomes
     * const count = await prisma.income.count({
     *   where: {
     *     // ... the filter for the Incomes we want to count
     *   }
     * })
    **/
    count<T extends IncomeCountArgs>(
      args?: Subset<T, IncomeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IncomeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Income.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IncomeAggregateArgs>(args: Subset<T, IncomeAggregateArgs>): Prisma.PrismaPromise<GetIncomeAggregateType<T>>

    /**
     * Group by Income.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IncomeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IncomeGroupByArgs['orderBy'] }
        : { orderBy?: IncomeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IncomeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncomeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Income model
   */
  readonly fields: IncomeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Income.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IncomeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Income model
   */
  interface IncomeFieldRefs {
    readonly id: FieldRef<"Income", 'String'>
    readonly Name: FieldRef<"Income", 'String'>
    readonly Status: FieldRef<"Income", 'String'>
    readonly createdAt: FieldRef<"Income", 'DateTime'>
    readonly updatedAt: FieldRef<"Income", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Income findUnique
   */
  export type IncomeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Income
     */
    select?: IncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Income
     */
    omit?: IncomeOmit<ExtArgs> | null
    /**
     * Filter, which Income to fetch.
     */
    where: IncomeWhereUniqueInput
  }

  /**
   * Income findUniqueOrThrow
   */
  export type IncomeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Income
     */
    select?: IncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Income
     */
    omit?: IncomeOmit<ExtArgs> | null
    /**
     * Filter, which Income to fetch.
     */
    where: IncomeWhereUniqueInput
  }

  /**
   * Income findFirst
   */
  export type IncomeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Income
     */
    select?: IncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Income
     */
    omit?: IncomeOmit<ExtArgs> | null
    /**
     * Filter, which Income to fetch.
     */
    where?: IncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incomes to fetch.
     */
    orderBy?: IncomeOrderByWithRelationInput | IncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Incomes.
     */
    cursor?: IncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Incomes.
     */
    distinct?: IncomeScalarFieldEnum | IncomeScalarFieldEnum[]
  }

  /**
   * Income findFirstOrThrow
   */
  export type IncomeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Income
     */
    select?: IncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Income
     */
    omit?: IncomeOmit<ExtArgs> | null
    /**
     * Filter, which Income to fetch.
     */
    where?: IncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incomes to fetch.
     */
    orderBy?: IncomeOrderByWithRelationInput | IncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Incomes.
     */
    cursor?: IncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Incomes.
     */
    distinct?: IncomeScalarFieldEnum | IncomeScalarFieldEnum[]
  }

  /**
   * Income findMany
   */
  export type IncomeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Income
     */
    select?: IncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Income
     */
    omit?: IncomeOmit<ExtArgs> | null
    /**
     * Filter, which Incomes to fetch.
     */
    where?: IncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incomes to fetch.
     */
    orderBy?: IncomeOrderByWithRelationInput | IncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Incomes.
     */
    cursor?: IncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incomes.
     */
    skip?: number
    distinct?: IncomeScalarFieldEnum | IncomeScalarFieldEnum[]
  }

  /**
   * Income create
   */
  export type IncomeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Income
     */
    select?: IncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Income
     */
    omit?: IncomeOmit<ExtArgs> | null
    /**
     * The data needed to create a Income.
     */
    data: XOR<IncomeCreateInput, IncomeUncheckedCreateInput>
  }

  /**
   * Income createMany
   */
  export type IncomeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Incomes.
     */
    data: IncomeCreateManyInput | IncomeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Income update
   */
  export type IncomeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Income
     */
    select?: IncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Income
     */
    omit?: IncomeOmit<ExtArgs> | null
    /**
     * The data needed to update a Income.
     */
    data: XOR<IncomeUpdateInput, IncomeUncheckedUpdateInput>
    /**
     * Choose, which Income to update.
     */
    where: IncomeWhereUniqueInput
  }

  /**
   * Income updateMany
   */
  export type IncomeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Incomes.
     */
    data: XOR<IncomeUpdateManyMutationInput, IncomeUncheckedUpdateManyInput>
    /**
     * Filter which Incomes to update
     */
    where?: IncomeWhereInput
    /**
     * Limit how many Incomes to update.
     */
    limit?: number
  }

  /**
   * Income upsert
   */
  export type IncomeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Income
     */
    select?: IncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Income
     */
    omit?: IncomeOmit<ExtArgs> | null
    /**
     * The filter to search for the Income to update in case it exists.
     */
    where: IncomeWhereUniqueInput
    /**
     * In case the Income found by the `where` argument doesn't exist, create a new Income with this data.
     */
    create: XOR<IncomeCreateInput, IncomeUncheckedCreateInput>
    /**
     * In case the Income was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IncomeUpdateInput, IncomeUncheckedUpdateInput>
  }

  /**
   * Income delete
   */
  export type IncomeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Income
     */
    select?: IncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Income
     */
    omit?: IncomeOmit<ExtArgs> | null
    /**
     * Filter which Income to delete.
     */
    where: IncomeWhereUniqueInput
  }

  /**
   * Income deleteMany
   */
  export type IncomeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Incomes to delete
     */
    where?: IncomeWhereInput
    /**
     * Limit how many Incomes to delete.
     */
    limit?: number
  }

  /**
   * Income without action
   */
  export type IncomeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Income
     */
    select?: IncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Income
     */
    omit?: IncomeOmit<ExtArgs> | null
  }


  /**
   * Model StatusType
   */

  export type AggregateStatusType = {
    _count: StatusTypeCountAggregateOutputType | null
    _min: StatusTypeMinAggregateOutputType | null
    _max: StatusTypeMaxAggregateOutputType | null
  }

  export type StatusTypeMinAggregateOutputType = {
    id: string | null
    Name: string | null
    Status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StatusTypeMaxAggregateOutputType = {
    id: string | null
    Name: string | null
    Status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StatusTypeCountAggregateOutputType = {
    id: number
    Name: number
    Status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StatusTypeMinAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StatusTypeMaxAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StatusTypeCountAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StatusTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StatusType to aggregate.
     */
    where?: StatusTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusTypes to fetch.
     */
    orderBy?: StatusTypeOrderByWithRelationInput | StatusTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StatusTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StatusTypes
    **/
    _count?: true | StatusTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StatusTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StatusTypeMaxAggregateInputType
  }

  export type GetStatusTypeAggregateType<T extends StatusTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateStatusType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStatusType[P]>
      : GetScalarType<T[P], AggregateStatusType[P]>
  }




  export type StatusTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StatusTypeWhereInput
    orderBy?: StatusTypeOrderByWithAggregationInput | StatusTypeOrderByWithAggregationInput[]
    by: StatusTypeScalarFieldEnum[] | StatusTypeScalarFieldEnum
    having?: StatusTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StatusTypeCountAggregateInputType | true
    _min?: StatusTypeMinAggregateInputType
    _max?: StatusTypeMaxAggregateInputType
  }

  export type StatusTypeGroupByOutputType = {
    id: string
    Name: string
    Status: string
    createdAt: Date
    updatedAt: Date
    _count: StatusTypeCountAggregateOutputType | null
    _min: StatusTypeMinAggregateOutputType | null
    _max: StatusTypeMaxAggregateOutputType | null
  }

  type GetStatusTypeGroupByPayload<T extends StatusTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StatusTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StatusTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StatusTypeGroupByOutputType[P]>
            : GetScalarType<T[P], StatusTypeGroupByOutputType[P]>
        }
      >
    >


  export type StatusTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Name?: boolean
    Status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["statusType"]>



  export type StatusTypeSelectScalar = {
    id?: boolean
    Name?: boolean
    Status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StatusTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "Name" | "Status" | "createdAt" | "updatedAt", ExtArgs["result"]["statusType"]>

  export type $StatusTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StatusType"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      Name: string
      Status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["statusType"]>
    composites: {}
  }

  type StatusTypeGetPayload<S extends boolean | null | undefined | StatusTypeDefaultArgs> = $Result.GetResult<Prisma.$StatusTypePayload, S>

  type StatusTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StatusTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StatusTypeCountAggregateInputType | true
    }

  export interface StatusTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StatusType'], meta: { name: 'StatusType' } }
    /**
     * Find zero or one StatusType that matches the filter.
     * @param {StatusTypeFindUniqueArgs} args - Arguments to find a StatusType
     * @example
     * // Get one StatusType
     * const statusType = await prisma.statusType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StatusTypeFindUniqueArgs>(args: SelectSubset<T, StatusTypeFindUniqueArgs<ExtArgs>>): Prisma__StatusTypeClient<$Result.GetResult<Prisma.$StatusTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StatusType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StatusTypeFindUniqueOrThrowArgs} args - Arguments to find a StatusType
     * @example
     * // Get one StatusType
     * const statusType = await prisma.statusType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StatusTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, StatusTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StatusTypeClient<$Result.GetResult<Prisma.$StatusTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StatusType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusTypeFindFirstArgs} args - Arguments to find a StatusType
     * @example
     * // Get one StatusType
     * const statusType = await prisma.statusType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StatusTypeFindFirstArgs>(args?: SelectSubset<T, StatusTypeFindFirstArgs<ExtArgs>>): Prisma__StatusTypeClient<$Result.GetResult<Prisma.$StatusTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StatusType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusTypeFindFirstOrThrowArgs} args - Arguments to find a StatusType
     * @example
     * // Get one StatusType
     * const statusType = await prisma.statusType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StatusTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, StatusTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__StatusTypeClient<$Result.GetResult<Prisma.$StatusTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StatusTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StatusTypes
     * const statusTypes = await prisma.statusType.findMany()
     * 
     * // Get first 10 StatusTypes
     * const statusTypes = await prisma.statusType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const statusTypeWithIdOnly = await prisma.statusType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StatusTypeFindManyArgs>(args?: SelectSubset<T, StatusTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatusTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StatusType.
     * @param {StatusTypeCreateArgs} args - Arguments to create a StatusType.
     * @example
     * // Create one StatusType
     * const StatusType = await prisma.statusType.create({
     *   data: {
     *     // ... data to create a StatusType
     *   }
     * })
     * 
     */
    create<T extends StatusTypeCreateArgs>(args: SelectSubset<T, StatusTypeCreateArgs<ExtArgs>>): Prisma__StatusTypeClient<$Result.GetResult<Prisma.$StatusTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StatusTypes.
     * @param {StatusTypeCreateManyArgs} args - Arguments to create many StatusTypes.
     * @example
     * // Create many StatusTypes
     * const statusType = await prisma.statusType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StatusTypeCreateManyArgs>(args?: SelectSubset<T, StatusTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StatusType.
     * @param {StatusTypeDeleteArgs} args - Arguments to delete one StatusType.
     * @example
     * // Delete one StatusType
     * const StatusType = await prisma.statusType.delete({
     *   where: {
     *     // ... filter to delete one StatusType
     *   }
     * })
     * 
     */
    delete<T extends StatusTypeDeleteArgs>(args: SelectSubset<T, StatusTypeDeleteArgs<ExtArgs>>): Prisma__StatusTypeClient<$Result.GetResult<Prisma.$StatusTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StatusType.
     * @param {StatusTypeUpdateArgs} args - Arguments to update one StatusType.
     * @example
     * // Update one StatusType
     * const statusType = await prisma.statusType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StatusTypeUpdateArgs>(args: SelectSubset<T, StatusTypeUpdateArgs<ExtArgs>>): Prisma__StatusTypeClient<$Result.GetResult<Prisma.$StatusTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StatusTypes.
     * @param {StatusTypeDeleteManyArgs} args - Arguments to filter StatusTypes to delete.
     * @example
     * // Delete a few StatusTypes
     * const { count } = await prisma.statusType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StatusTypeDeleteManyArgs>(args?: SelectSubset<T, StatusTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StatusTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StatusTypes
     * const statusType = await prisma.statusType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StatusTypeUpdateManyArgs>(args: SelectSubset<T, StatusTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StatusType.
     * @param {StatusTypeUpsertArgs} args - Arguments to update or create a StatusType.
     * @example
     * // Update or create a StatusType
     * const statusType = await prisma.statusType.upsert({
     *   create: {
     *     // ... data to create a StatusType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StatusType we want to update
     *   }
     * })
     */
    upsert<T extends StatusTypeUpsertArgs>(args: SelectSubset<T, StatusTypeUpsertArgs<ExtArgs>>): Prisma__StatusTypeClient<$Result.GetResult<Prisma.$StatusTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StatusTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusTypeCountArgs} args - Arguments to filter StatusTypes to count.
     * @example
     * // Count the number of StatusTypes
     * const count = await prisma.statusType.count({
     *   where: {
     *     // ... the filter for the StatusTypes we want to count
     *   }
     * })
    **/
    count<T extends StatusTypeCountArgs>(
      args?: Subset<T, StatusTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StatusTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StatusType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StatusTypeAggregateArgs>(args: Subset<T, StatusTypeAggregateArgs>): Prisma.PrismaPromise<GetStatusTypeAggregateType<T>>

    /**
     * Group by StatusType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StatusTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StatusTypeGroupByArgs['orderBy'] }
        : { orderBy?: StatusTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StatusTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatusTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StatusType model
   */
  readonly fields: StatusTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StatusType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StatusTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StatusType model
   */
  interface StatusTypeFieldRefs {
    readonly id: FieldRef<"StatusType", 'String'>
    readonly Name: FieldRef<"StatusType", 'String'>
    readonly Status: FieldRef<"StatusType", 'String'>
    readonly createdAt: FieldRef<"StatusType", 'DateTime'>
    readonly updatedAt: FieldRef<"StatusType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StatusType findUnique
   */
  export type StatusTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusType
     */
    select?: StatusTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusType
     */
    omit?: StatusTypeOmit<ExtArgs> | null
    /**
     * Filter, which StatusType to fetch.
     */
    where: StatusTypeWhereUniqueInput
  }

  /**
   * StatusType findUniqueOrThrow
   */
  export type StatusTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusType
     */
    select?: StatusTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusType
     */
    omit?: StatusTypeOmit<ExtArgs> | null
    /**
     * Filter, which StatusType to fetch.
     */
    where: StatusTypeWhereUniqueInput
  }

  /**
   * StatusType findFirst
   */
  export type StatusTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusType
     */
    select?: StatusTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusType
     */
    omit?: StatusTypeOmit<ExtArgs> | null
    /**
     * Filter, which StatusType to fetch.
     */
    where?: StatusTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusTypes to fetch.
     */
    orderBy?: StatusTypeOrderByWithRelationInput | StatusTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StatusTypes.
     */
    cursor?: StatusTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StatusTypes.
     */
    distinct?: StatusTypeScalarFieldEnum | StatusTypeScalarFieldEnum[]
  }

  /**
   * StatusType findFirstOrThrow
   */
  export type StatusTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusType
     */
    select?: StatusTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusType
     */
    omit?: StatusTypeOmit<ExtArgs> | null
    /**
     * Filter, which StatusType to fetch.
     */
    where?: StatusTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusTypes to fetch.
     */
    orderBy?: StatusTypeOrderByWithRelationInput | StatusTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StatusTypes.
     */
    cursor?: StatusTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StatusTypes.
     */
    distinct?: StatusTypeScalarFieldEnum | StatusTypeScalarFieldEnum[]
  }

  /**
   * StatusType findMany
   */
  export type StatusTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusType
     */
    select?: StatusTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusType
     */
    omit?: StatusTypeOmit<ExtArgs> | null
    /**
     * Filter, which StatusTypes to fetch.
     */
    where?: StatusTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusTypes to fetch.
     */
    orderBy?: StatusTypeOrderByWithRelationInput | StatusTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StatusTypes.
     */
    cursor?: StatusTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusTypes.
     */
    skip?: number
    distinct?: StatusTypeScalarFieldEnum | StatusTypeScalarFieldEnum[]
  }

  /**
   * StatusType create
   */
  export type StatusTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusType
     */
    select?: StatusTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusType
     */
    omit?: StatusTypeOmit<ExtArgs> | null
    /**
     * The data needed to create a StatusType.
     */
    data: XOR<StatusTypeCreateInput, StatusTypeUncheckedCreateInput>
  }

  /**
   * StatusType createMany
   */
  export type StatusTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StatusTypes.
     */
    data: StatusTypeCreateManyInput | StatusTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StatusType update
   */
  export type StatusTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusType
     */
    select?: StatusTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusType
     */
    omit?: StatusTypeOmit<ExtArgs> | null
    /**
     * The data needed to update a StatusType.
     */
    data: XOR<StatusTypeUpdateInput, StatusTypeUncheckedUpdateInput>
    /**
     * Choose, which StatusType to update.
     */
    where: StatusTypeWhereUniqueInput
  }

  /**
   * StatusType updateMany
   */
  export type StatusTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StatusTypes.
     */
    data: XOR<StatusTypeUpdateManyMutationInput, StatusTypeUncheckedUpdateManyInput>
    /**
     * Filter which StatusTypes to update
     */
    where?: StatusTypeWhereInput
    /**
     * Limit how many StatusTypes to update.
     */
    limit?: number
  }

  /**
   * StatusType upsert
   */
  export type StatusTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusType
     */
    select?: StatusTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusType
     */
    omit?: StatusTypeOmit<ExtArgs> | null
    /**
     * The filter to search for the StatusType to update in case it exists.
     */
    where: StatusTypeWhereUniqueInput
    /**
     * In case the StatusType found by the `where` argument doesn't exist, create a new StatusType with this data.
     */
    create: XOR<StatusTypeCreateInput, StatusTypeUncheckedCreateInput>
    /**
     * In case the StatusType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StatusTypeUpdateInput, StatusTypeUncheckedUpdateInput>
  }

  /**
   * StatusType delete
   */
  export type StatusTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusType
     */
    select?: StatusTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusType
     */
    omit?: StatusTypeOmit<ExtArgs> | null
    /**
     * Filter which StatusType to delete.
     */
    where: StatusTypeWhereUniqueInput
  }

  /**
   * StatusType deleteMany
   */
  export type StatusTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StatusTypes to delete
     */
    where?: StatusTypeWhereInput
    /**
     * Limit how many StatusTypes to delete.
     */
    limit?: number
  }

  /**
   * StatusType without action
   */
  export type StatusTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusType
     */
    select?: StatusTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusType
     */
    omit?: StatusTypeOmit<ExtArgs> | null
  }


  /**
   * Model ContactStatusType
   */

  export type AggregateContactStatusType = {
    _count: ContactStatusTypeCountAggregateOutputType | null
    _min: ContactStatusTypeMinAggregateOutputType | null
    _max: ContactStatusTypeMaxAggregateOutputType | null
  }

  export type ContactStatusTypeMinAggregateOutputType = {
    id: string | null
    Name: string | null
    Status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactStatusTypeMaxAggregateOutputType = {
    id: string | null
    Name: string | null
    Status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactStatusTypeCountAggregateOutputType = {
    id: number
    Name: number
    Status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactStatusTypeMinAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactStatusTypeMaxAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactStatusTypeCountAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactStatusTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactStatusType to aggregate.
     */
    where?: ContactStatusTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactStatusTypes to fetch.
     */
    orderBy?: ContactStatusTypeOrderByWithRelationInput | ContactStatusTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactStatusTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactStatusTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactStatusTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactStatusTypes
    **/
    _count?: true | ContactStatusTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactStatusTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactStatusTypeMaxAggregateInputType
  }

  export type GetContactStatusTypeAggregateType<T extends ContactStatusTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateContactStatusType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactStatusType[P]>
      : GetScalarType<T[P], AggregateContactStatusType[P]>
  }




  export type ContactStatusTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactStatusTypeWhereInput
    orderBy?: ContactStatusTypeOrderByWithAggregationInput | ContactStatusTypeOrderByWithAggregationInput[]
    by: ContactStatusTypeScalarFieldEnum[] | ContactStatusTypeScalarFieldEnum
    having?: ContactStatusTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactStatusTypeCountAggregateInputType | true
    _min?: ContactStatusTypeMinAggregateInputType
    _max?: ContactStatusTypeMaxAggregateInputType
  }

  export type ContactStatusTypeGroupByOutputType = {
    id: string
    Name: string
    Status: string
    createdAt: Date
    updatedAt: Date
    _count: ContactStatusTypeCountAggregateOutputType | null
    _min: ContactStatusTypeMinAggregateOutputType | null
    _max: ContactStatusTypeMaxAggregateOutputType | null
  }

  type GetContactStatusTypeGroupByPayload<T extends ContactStatusTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactStatusTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactStatusTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactStatusTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ContactStatusTypeGroupByOutputType[P]>
        }
      >
    >


  export type ContactStatusTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Name?: boolean
    Status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contactStatusType"]>



  export type ContactStatusTypeSelectScalar = {
    id?: boolean
    Name?: boolean
    Status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactStatusTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "Name" | "Status" | "createdAt" | "updatedAt", ExtArgs["result"]["contactStatusType"]>

  export type $ContactStatusTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactStatusType"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      Name: string
      Status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contactStatusType"]>
    composites: {}
  }

  type ContactStatusTypeGetPayload<S extends boolean | null | undefined | ContactStatusTypeDefaultArgs> = $Result.GetResult<Prisma.$ContactStatusTypePayload, S>

  type ContactStatusTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactStatusTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactStatusTypeCountAggregateInputType | true
    }

  export interface ContactStatusTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactStatusType'], meta: { name: 'ContactStatusType' } }
    /**
     * Find zero or one ContactStatusType that matches the filter.
     * @param {ContactStatusTypeFindUniqueArgs} args - Arguments to find a ContactStatusType
     * @example
     * // Get one ContactStatusType
     * const contactStatusType = await prisma.contactStatusType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactStatusTypeFindUniqueArgs>(args: SelectSubset<T, ContactStatusTypeFindUniqueArgs<ExtArgs>>): Prisma__ContactStatusTypeClient<$Result.GetResult<Prisma.$ContactStatusTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContactStatusType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactStatusTypeFindUniqueOrThrowArgs} args - Arguments to find a ContactStatusType
     * @example
     * // Get one ContactStatusType
     * const contactStatusType = await prisma.contactStatusType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactStatusTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactStatusTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactStatusTypeClient<$Result.GetResult<Prisma.$ContactStatusTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactStatusType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactStatusTypeFindFirstArgs} args - Arguments to find a ContactStatusType
     * @example
     * // Get one ContactStatusType
     * const contactStatusType = await prisma.contactStatusType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactStatusTypeFindFirstArgs>(args?: SelectSubset<T, ContactStatusTypeFindFirstArgs<ExtArgs>>): Prisma__ContactStatusTypeClient<$Result.GetResult<Prisma.$ContactStatusTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactStatusType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactStatusTypeFindFirstOrThrowArgs} args - Arguments to find a ContactStatusType
     * @example
     * // Get one ContactStatusType
     * const contactStatusType = await prisma.contactStatusType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactStatusTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactStatusTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactStatusTypeClient<$Result.GetResult<Prisma.$ContactStatusTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContactStatusTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactStatusTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactStatusTypes
     * const contactStatusTypes = await prisma.contactStatusType.findMany()
     * 
     * // Get first 10 ContactStatusTypes
     * const contactStatusTypes = await prisma.contactStatusType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactStatusTypeWithIdOnly = await prisma.contactStatusType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactStatusTypeFindManyArgs>(args?: SelectSubset<T, ContactStatusTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactStatusTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContactStatusType.
     * @param {ContactStatusTypeCreateArgs} args - Arguments to create a ContactStatusType.
     * @example
     * // Create one ContactStatusType
     * const ContactStatusType = await prisma.contactStatusType.create({
     *   data: {
     *     // ... data to create a ContactStatusType
     *   }
     * })
     * 
     */
    create<T extends ContactStatusTypeCreateArgs>(args: SelectSubset<T, ContactStatusTypeCreateArgs<ExtArgs>>): Prisma__ContactStatusTypeClient<$Result.GetResult<Prisma.$ContactStatusTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContactStatusTypes.
     * @param {ContactStatusTypeCreateManyArgs} args - Arguments to create many ContactStatusTypes.
     * @example
     * // Create many ContactStatusTypes
     * const contactStatusType = await prisma.contactStatusType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactStatusTypeCreateManyArgs>(args?: SelectSubset<T, ContactStatusTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContactStatusType.
     * @param {ContactStatusTypeDeleteArgs} args - Arguments to delete one ContactStatusType.
     * @example
     * // Delete one ContactStatusType
     * const ContactStatusType = await prisma.contactStatusType.delete({
     *   where: {
     *     // ... filter to delete one ContactStatusType
     *   }
     * })
     * 
     */
    delete<T extends ContactStatusTypeDeleteArgs>(args: SelectSubset<T, ContactStatusTypeDeleteArgs<ExtArgs>>): Prisma__ContactStatusTypeClient<$Result.GetResult<Prisma.$ContactStatusTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContactStatusType.
     * @param {ContactStatusTypeUpdateArgs} args - Arguments to update one ContactStatusType.
     * @example
     * // Update one ContactStatusType
     * const contactStatusType = await prisma.contactStatusType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactStatusTypeUpdateArgs>(args: SelectSubset<T, ContactStatusTypeUpdateArgs<ExtArgs>>): Prisma__ContactStatusTypeClient<$Result.GetResult<Prisma.$ContactStatusTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContactStatusTypes.
     * @param {ContactStatusTypeDeleteManyArgs} args - Arguments to filter ContactStatusTypes to delete.
     * @example
     * // Delete a few ContactStatusTypes
     * const { count } = await prisma.contactStatusType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactStatusTypeDeleteManyArgs>(args?: SelectSubset<T, ContactStatusTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactStatusTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactStatusTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactStatusTypes
     * const contactStatusType = await prisma.contactStatusType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactStatusTypeUpdateManyArgs>(args: SelectSubset<T, ContactStatusTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContactStatusType.
     * @param {ContactStatusTypeUpsertArgs} args - Arguments to update or create a ContactStatusType.
     * @example
     * // Update or create a ContactStatusType
     * const contactStatusType = await prisma.contactStatusType.upsert({
     *   create: {
     *     // ... data to create a ContactStatusType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactStatusType we want to update
     *   }
     * })
     */
    upsert<T extends ContactStatusTypeUpsertArgs>(args: SelectSubset<T, ContactStatusTypeUpsertArgs<ExtArgs>>): Prisma__ContactStatusTypeClient<$Result.GetResult<Prisma.$ContactStatusTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContactStatusTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactStatusTypeCountArgs} args - Arguments to filter ContactStatusTypes to count.
     * @example
     * // Count the number of ContactStatusTypes
     * const count = await prisma.contactStatusType.count({
     *   where: {
     *     // ... the filter for the ContactStatusTypes we want to count
     *   }
     * })
    **/
    count<T extends ContactStatusTypeCountArgs>(
      args?: Subset<T, ContactStatusTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactStatusTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactStatusType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactStatusTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactStatusTypeAggregateArgs>(args: Subset<T, ContactStatusTypeAggregateArgs>): Prisma.PrismaPromise<GetContactStatusTypeAggregateType<T>>

    /**
     * Group by ContactStatusType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactStatusTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactStatusTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactStatusTypeGroupByArgs['orderBy'] }
        : { orderBy?: ContactStatusTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactStatusTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactStatusTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactStatusType model
   */
  readonly fields: ContactStatusTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactStatusType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactStatusTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactStatusType model
   */
  interface ContactStatusTypeFieldRefs {
    readonly id: FieldRef<"ContactStatusType", 'String'>
    readonly Name: FieldRef<"ContactStatusType", 'String'>
    readonly Status: FieldRef<"ContactStatusType", 'String'>
    readonly createdAt: FieldRef<"ContactStatusType", 'DateTime'>
    readonly updatedAt: FieldRef<"ContactStatusType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContactStatusType findUnique
   */
  export type ContactStatusTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactStatusType
     */
    select?: ContactStatusTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactStatusType
     */
    omit?: ContactStatusTypeOmit<ExtArgs> | null
    /**
     * Filter, which ContactStatusType to fetch.
     */
    where: ContactStatusTypeWhereUniqueInput
  }

  /**
   * ContactStatusType findUniqueOrThrow
   */
  export type ContactStatusTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactStatusType
     */
    select?: ContactStatusTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactStatusType
     */
    omit?: ContactStatusTypeOmit<ExtArgs> | null
    /**
     * Filter, which ContactStatusType to fetch.
     */
    where: ContactStatusTypeWhereUniqueInput
  }

  /**
   * ContactStatusType findFirst
   */
  export type ContactStatusTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactStatusType
     */
    select?: ContactStatusTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactStatusType
     */
    omit?: ContactStatusTypeOmit<ExtArgs> | null
    /**
     * Filter, which ContactStatusType to fetch.
     */
    where?: ContactStatusTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactStatusTypes to fetch.
     */
    orderBy?: ContactStatusTypeOrderByWithRelationInput | ContactStatusTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactStatusTypes.
     */
    cursor?: ContactStatusTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactStatusTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactStatusTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactStatusTypes.
     */
    distinct?: ContactStatusTypeScalarFieldEnum | ContactStatusTypeScalarFieldEnum[]
  }

  /**
   * ContactStatusType findFirstOrThrow
   */
  export type ContactStatusTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactStatusType
     */
    select?: ContactStatusTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactStatusType
     */
    omit?: ContactStatusTypeOmit<ExtArgs> | null
    /**
     * Filter, which ContactStatusType to fetch.
     */
    where?: ContactStatusTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactStatusTypes to fetch.
     */
    orderBy?: ContactStatusTypeOrderByWithRelationInput | ContactStatusTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactStatusTypes.
     */
    cursor?: ContactStatusTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactStatusTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactStatusTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactStatusTypes.
     */
    distinct?: ContactStatusTypeScalarFieldEnum | ContactStatusTypeScalarFieldEnum[]
  }

  /**
   * ContactStatusType findMany
   */
  export type ContactStatusTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactStatusType
     */
    select?: ContactStatusTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactStatusType
     */
    omit?: ContactStatusTypeOmit<ExtArgs> | null
    /**
     * Filter, which ContactStatusTypes to fetch.
     */
    where?: ContactStatusTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactStatusTypes to fetch.
     */
    orderBy?: ContactStatusTypeOrderByWithRelationInput | ContactStatusTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactStatusTypes.
     */
    cursor?: ContactStatusTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactStatusTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactStatusTypes.
     */
    skip?: number
    distinct?: ContactStatusTypeScalarFieldEnum | ContactStatusTypeScalarFieldEnum[]
  }

  /**
   * ContactStatusType create
   */
  export type ContactStatusTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactStatusType
     */
    select?: ContactStatusTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactStatusType
     */
    omit?: ContactStatusTypeOmit<ExtArgs> | null
    /**
     * The data needed to create a ContactStatusType.
     */
    data: XOR<ContactStatusTypeCreateInput, ContactStatusTypeUncheckedCreateInput>
  }

  /**
   * ContactStatusType createMany
   */
  export type ContactStatusTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactStatusTypes.
     */
    data: ContactStatusTypeCreateManyInput | ContactStatusTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactStatusType update
   */
  export type ContactStatusTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactStatusType
     */
    select?: ContactStatusTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactStatusType
     */
    omit?: ContactStatusTypeOmit<ExtArgs> | null
    /**
     * The data needed to update a ContactStatusType.
     */
    data: XOR<ContactStatusTypeUpdateInput, ContactStatusTypeUncheckedUpdateInput>
    /**
     * Choose, which ContactStatusType to update.
     */
    where: ContactStatusTypeWhereUniqueInput
  }

  /**
   * ContactStatusType updateMany
   */
  export type ContactStatusTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactStatusTypes.
     */
    data: XOR<ContactStatusTypeUpdateManyMutationInput, ContactStatusTypeUncheckedUpdateManyInput>
    /**
     * Filter which ContactStatusTypes to update
     */
    where?: ContactStatusTypeWhereInput
    /**
     * Limit how many ContactStatusTypes to update.
     */
    limit?: number
  }

  /**
   * ContactStatusType upsert
   */
  export type ContactStatusTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactStatusType
     */
    select?: ContactStatusTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactStatusType
     */
    omit?: ContactStatusTypeOmit<ExtArgs> | null
    /**
     * The filter to search for the ContactStatusType to update in case it exists.
     */
    where: ContactStatusTypeWhereUniqueInput
    /**
     * In case the ContactStatusType found by the `where` argument doesn't exist, create a new ContactStatusType with this data.
     */
    create: XOR<ContactStatusTypeCreateInput, ContactStatusTypeUncheckedCreateInput>
    /**
     * In case the ContactStatusType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactStatusTypeUpdateInput, ContactStatusTypeUncheckedUpdateInput>
  }

  /**
   * ContactStatusType delete
   */
  export type ContactStatusTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactStatusType
     */
    select?: ContactStatusTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactStatusType
     */
    omit?: ContactStatusTypeOmit<ExtArgs> | null
    /**
     * Filter which ContactStatusType to delete.
     */
    where: ContactStatusTypeWhereUniqueInput
  }

  /**
   * ContactStatusType deleteMany
   */
  export type ContactStatusTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactStatusTypes to delete
     */
    where?: ContactStatusTypeWhereInput
    /**
     * Limit how many ContactStatusTypes to delete.
     */
    limit?: number
  }

  /**
   * ContactStatusType without action
   */
  export type ContactStatusTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactStatusType
     */
    select?: ContactStatusTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactStatusType
     */
    omit?: ContactStatusTypeOmit<ExtArgs> | null
  }


  /**
   * Model PaymentMethod
   */

  export type AggregatePaymentMethod = {
    _count: PaymentMethodCountAggregateOutputType | null
    _min: PaymentMethodMinAggregateOutputType | null
    _max: PaymentMethodMaxAggregateOutputType | null
  }

  export type PaymentMethodMinAggregateOutputType = {
    id: string | null
    Name: string | null
    Status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMethodMaxAggregateOutputType = {
    id: string | null
    Name: string | null
    Status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMethodCountAggregateOutputType = {
    id: number
    Name: number
    Status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentMethodMinAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMethodMaxAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMethodCountAggregateInputType = {
    id?: true
    Name?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentMethodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethod to aggregate.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentMethods
    **/
    _count?: true | PaymentMethodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMethodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMethodMaxAggregateInputType
  }

  export type GetPaymentMethodAggregateType<T extends PaymentMethodAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentMethod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentMethod[P]>
      : GetScalarType<T[P], AggregatePaymentMethod[P]>
  }




  export type PaymentMethodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentMethodWhereInput
    orderBy?: PaymentMethodOrderByWithAggregationInput | PaymentMethodOrderByWithAggregationInput[]
    by: PaymentMethodScalarFieldEnum[] | PaymentMethodScalarFieldEnum
    having?: PaymentMethodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentMethodCountAggregateInputType | true
    _min?: PaymentMethodMinAggregateInputType
    _max?: PaymentMethodMaxAggregateInputType
  }

  export type PaymentMethodGroupByOutputType = {
    id: string
    Name: string
    Status: string
    createdAt: Date
    updatedAt: Date
    _count: PaymentMethodCountAggregateOutputType | null
    _min: PaymentMethodMinAggregateOutputType | null
    _max: PaymentMethodMaxAggregateOutputType | null
  }

  type GetPaymentMethodGroupByPayload<T extends PaymentMethodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentMethodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentMethodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentMethodGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentMethodGroupByOutputType[P]>
        }
      >
    >


  export type PaymentMethodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Name?: boolean
    Status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentMethod"]>



  export type PaymentMethodSelectScalar = {
    id?: boolean
    Name?: boolean
    Status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentMethodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "Name" | "Status" | "createdAt" | "updatedAt", ExtArgs["result"]["paymentMethod"]>

  export type $PaymentMethodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentMethod"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      Name: string
      Status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paymentMethod"]>
    composites: {}
  }

  type PaymentMethodGetPayload<S extends boolean | null | undefined | PaymentMethodDefaultArgs> = $Result.GetResult<Prisma.$PaymentMethodPayload, S>

  type PaymentMethodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentMethodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentMethodCountAggregateInputType | true
    }

  export interface PaymentMethodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentMethod'], meta: { name: 'PaymentMethod' } }
    /**
     * Find zero or one PaymentMethod that matches the filter.
     * @param {PaymentMethodFindUniqueArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentMethodFindUniqueArgs>(args: SelectSubset<T, PaymentMethodFindUniqueArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentMethod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentMethodFindUniqueOrThrowArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentMethodFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentMethodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentMethod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindFirstArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentMethodFindFirstArgs>(args?: SelectSubset<T, PaymentMethodFindFirstArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentMethod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindFirstOrThrowArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentMethodFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentMethodFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentMethods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentMethods
     * const paymentMethods = await prisma.paymentMethod.findMany()
     * 
     * // Get first 10 PaymentMethods
     * const paymentMethods = await prisma.paymentMethod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentMethodFindManyArgs>(args?: SelectSubset<T, PaymentMethodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentMethod.
     * @param {PaymentMethodCreateArgs} args - Arguments to create a PaymentMethod.
     * @example
     * // Create one PaymentMethod
     * const PaymentMethod = await prisma.paymentMethod.create({
     *   data: {
     *     // ... data to create a PaymentMethod
     *   }
     * })
     * 
     */
    create<T extends PaymentMethodCreateArgs>(args: SelectSubset<T, PaymentMethodCreateArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentMethods.
     * @param {PaymentMethodCreateManyArgs} args - Arguments to create many PaymentMethods.
     * @example
     * // Create many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentMethodCreateManyArgs>(args?: SelectSubset<T, PaymentMethodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PaymentMethod.
     * @param {PaymentMethodDeleteArgs} args - Arguments to delete one PaymentMethod.
     * @example
     * // Delete one PaymentMethod
     * const PaymentMethod = await prisma.paymentMethod.delete({
     *   where: {
     *     // ... filter to delete one PaymentMethod
     *   }
     * })
     * 
     */
    delete<T extends PaymentMethodDeleteArgs>(args: SelectSubset<T, PaymentMethodDeleteArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentMethod.
     * @param {PaymentMethodUpdateArgs} args - Arguments to update one PaymentMethod.
     * @example
     * // Update one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentMethodUpdateArgs>(args: SelectSubset<T, PaymentMethodUpdateArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentMethods.
     * @param {PaymentMethodDeleteManyArgs} args - Arguments to filter PaymentMethods to delete.
     * @example
     * // Delete a few PaymentMethods
     * const { count } = await prisma.paymentMethod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentMethodDeleteManyArgs>(args?: SelectSubset<T, PaymentMethodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentMethodUpdateManyArgs>(args: SelectSubset<T, PaymentMethodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PaymentMethod.
     * @param {PaymentMethodUpsertArgs} args - Arguments to update or create a PaymentMethod.
     * @example
     * // Update or create a PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.upsert({
     *   create: {
     *     // ... data to create a PaymentMethod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentMethod we want to update
     *   }
     * })
     */
    upsert<T extends PaymentMethodUpsertArgs>(args: SelectSubset<T, PaymentMethodUpsertArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodCountArgs} args - Arguments to filter PaymentMethods to count.
     * @example
     * // Count the number of PaymentMethods
     * const count = await prisma.paymentMethod.count({
     *   where: {
     *     // ... the filter for the PaymentMethods we want to count
     *   }
     * })
    **/
    count<T extends PaymentMethodCountArgs>(
      args?: Subset<T, PaymentMethodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentMethodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentMethodAggregateArgs>(args: Subset<T, PaymentMethodAggregateArgs>): Prisma.PrismaPromise<GetPaymentMethodAggregateType<T>>

    /**
     * Group by PaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentMethodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentMethodGroupByArgs['orderBy'] }
        : { orderBy?: PaymentMethodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentMethodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentMethodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentMethod model
   */
  readonly fields: PaymentMethodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentMethod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentMethodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentMethod model
   */
  interface PaymentMethodFieldRefs {
    readonly id: FieldRef<"PaymentMethod", 'String'>
    readonly Name: FieldRef<"PaymentMethod", 'String'>
    readonly Status: FieldRef<"PaymentMethod", 'String'>
    readonly createdAt: FieldRef<"PaymentMethod", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentMethod", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentMethod findUnique
   */
  export type PaymentMethodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod findUniqueOrThrow
   */
  export type PaymentMethodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod findFirst
   */
  export type PaymentMethodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod findFirstOrThrow
   */
  export type PaymentMethodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod findMany
   */
  export type PaymentMethodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Filter, which PaymentMethods to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod create
   */
  export type PaymentMethodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * The data needed to create a PaymentMethod.
     */
    data: XOR<PaymentMethodCreateInput, PaymentMethodUncheckedCreateInput>
  }

  /**
   * PaymentMethod createMany
   */
  export type PaymentMethodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentMethods.
     */
    data: PaymentMethodCreateManyInput | PaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentMethod update
   */
  export type PaymentMethodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * The data needed to update a PaymentMethod.
     */
    data: XOR<PaymentMethodUpdateInput, PaymentMethodUncheckedUpdateInput>
    /**
     * Choose, which PaymentMethod to update.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod updateMany
   */
  export type PaymentMethodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentMethods.
     */
    data: XOR<PaymentMethodUpdateManyMutationInput, PaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which PaymentMethods to update
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to update.
     */
    limit?: number
  }

  /**
   * PaymentMethod upsert
   */
  export type PaymentMethodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * The filter to search for the PaymentMethod to update in case it exists.
     */
    where: PaymentMethodWhereUniqueInput
    /**
     * In case the PaymentMethod found by the `where` argument doesn't exist, create a new PaymentMethod with this data.
     */
    create: XOR<PaymentMethodCreateInput, PaymentMethodUncheckedCreateInput>
    /**
     * In case the PaymentMethod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentMethodUpdateInput, PaymentMethodUncheckedUpdateInput>
  }

  /**
   * PaymentMethod delete
   */
  export type PaymentMethodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Filter which PaymentMethod to delete.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod deleteMany
   */
  export type PaymentMethodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethods to delete
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to delete.
     */
    limit?: number
  }

  /**
   * PaymentMethod without action
   */
  export type PaymentMethodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
  }


  /**
   * Model Template
   */

  export type AggregateTemplate = {
    _count: TemplateCountAggregateOutputType | null
    _min: TemplateMinAggregateOutputType | null
    _max: TemplateMaxAggregateOutputType | null
  }

  export type TemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    subject: string | null
    body: string | null
    description: string | null
    createdBy: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    subject: string | null
    body: string | null
    description: string | null
    createdBy: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TemplateCountAggregateOutputType = {
    id: number
    name: number
    type: number
    subject: number
    body: number
    description: number
    whatsappImage: number
    createdBy: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TemplateMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    subject?: true
    body?: true
    description?: true
    createdBy?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TemplateMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    subject?: true
    body?: true
    description?: true
    createdBy?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TemplateCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    subject?: true
    body?: true
    description?: true
    whatsappImage?: true
    createdBy?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Template to aggregate.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Templates
    **/
    _count?: true | TemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemplateMaxAggregateInputType
  }

  export type GetTemplateAggregateType<T extends TemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplate[P]>
      : GetScalarType<T[P], AggregateTemplate[P]>
  }




  export type TemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateWhereInput
    orderBy?: TemplateOrderByWithAggregationInput | TemplateOrderByWithAggregationInput[]
    by: TemplateScalarFieldEnum[] | TemplateScalarFieldEnum
    having?: TemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemplateCountAggregateInputType | true
    _min?: TemplateMinAggregateInputType
    _max?: TemplateMaxAggregateInputType
  }

  export type TemplateGroupByOutputType = {
    id: string
    name: string
    type: string
    subject: string
    body: string
    description: string
    whatsappImage: JsonValue | null
    createdBy: string
    status: string
    createdAt: Date
    updatedAt: Date
    _count: TemplateCountAggregateOutputType | null
    _min: TemplateMinAggregateOutputType | null
    _max: TemplateMaxAggregateOutputType | null
  }

  type GetTemplateGroupByPayload<T extends TemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemplateGroupByOutputType[P]>
            : GetScalarType<T[P], TemplateGroupByOutputType[P]>
        }
      >
    >


  export type TemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    subject?: boolean
    body?: boolean
    description?: boolean
    whatsappImage?: boolean
    createdBy?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["template"]>



  export type TemplateSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    subject?: boolean
    body?: boolean
    description?: boolean
    whatsappImage?: boolean
    createdBy?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "subject" | "body" | "description" | "whatsappImage" | "createdBy" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["template"]>

  export type $TemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Template"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      subject: string
      body: string
      description: string
      whatsappImage: Prisma.JsonValue | null
      createdBy: string
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["template"]>
    composites: {}
  }

  type TemplateGetPayload<S extends boolean | null | undefined | TemplateDefaultArgs> = $Result.GetResult<Prisma.$TemplatePayload, S>

  type TemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TemplateCountAggregateInputType | true
    }

  export interface TemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Template'], meta: { name: 'Template' } }
    /**
     * Find zero or one Template that matches the filter.
     * @param {TemplateFindUniqueArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TemplateFindUniqueArgs>(args: SelectSubset<T, TemplateFindUniqueArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Template that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TemplateFindUniqueOrThrowArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, TemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Template that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFindFirstArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TemplateFindFirstArgs>(args?: SelectSubset<T, TemplateFindFirstArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Template that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFindFirstOrThrowArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, TemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Templates
     * const templates = await prisma.template.findMany()
     * 
     * // Get first 10 Templates
     * const templates = await prisma.template.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const templateWithIdOnly = await prisma.template.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TemplateFindManyArgs>(args?: SelectSubset<T, TemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Template.
     * @param {TemplateCreateArgs} args - Arguments to create a Template.
     * @example
     * // Create one Template
     * const Template = await prisma.template.create({
     *   data: {
     *     // ... data to create a Template
     *   }
     * })
     * 
     */
    create<T extends TemplateCreateArgs>(args: SelectSubset<T, TemplateCreateArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Templates.
     * @param {TemplateCreateManyArgs} args - Arguments to create many Templates.
     * @example
     * // Create many Templates
     * const template = await prisma.template.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TemplateCreateManyArgs>(args?: SelectSubset<T, TemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Template.
     * @param {TemplateDeleteArgs} args - Arguments to delete one Template.
     * @example
     * // Delete one Template
     * const Template = await prisma.template.delete({
     *   where: {
     *     // ... filter to delete one Template
     *   }
     * })
     * 
     */
    delete<T extends TemplateDeleteArgs>(args: SelectSubset<T, TemplateDeleteArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Template.
     * @param {TemplateUpdateArgs} args - Arguments to update one Template.
     * @example
     * // Update one Template
     * const template = await prisma.template.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TemplateUpdateArgs>(args: SelectSubset<T, TemplateUpdateArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Templates.
     * @param {TemplateDeleteManyArgs} args - Arguments to filter Templates to delete.
     * @example
     * // Delete a few Templates
     * const { count } = await prisma.template.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TemplateDeleteManyArgs>(args?: SelectSubset<T, TemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Templates
     * const template = await prisma.template.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TemplateUpdateManyArgs>(args: SelectSubset<T, TemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Template.
     * @param {TemplateUpsertArgs} args - Arguments to update or create a Template.
     * @example
     * // Update or create a Template
     * const template = await prisma.template.upsert({
     *   create: {
     *     // ... data to create a Template
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Template we want to update
     *   }
     * })
     */
    upsert<T extends TemplateUpsertArgs>(args: SelectSubset<T, TemplateUpsertArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateCountArgs} args - Arguments to filter Templates to count.
     * @example
     * // Count the number of Templates
     * const count = await prisma.template.count({
     *   where: {
     *     // ... the filter for the Templates we want to count
     *   }
     * })
    **/
    count<T extends TemplateCountArgs>(
      args?: Subset<T, TemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Template.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemplateAggregateArgs>(args: Subset<T, TemplateAggregateArgs>): Prisma.PrismaPromise<GetTemplateAggregateType<T>>

    /**
     * Group by Template.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemplateGroupByArgs['orderBy'] }
        : { orderBy?: TemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Template model
   */
  readonly fields: TemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Template.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Template model
   */
  interface TemplateFieldRefs {
    readonly id: FieldRef<"Template", 'String'>
    readonly name: FieldRef<"Template", 'String'>
    readonly type: FieldRef<"Template", 'String'>
    readonly subject: FieldRef<"Template", 'String'>
    readonly body: FieldRef<"Template", 'String'>
    readonly description: FieldRef<"Template", 'String'>
    readonly whatsappImage: FieldRef<"Template", 'Json'>
    readonly createdBy: FieldRef<"Template", 'String'>
    readonly status: FieldRef<"Template", 'String'>
    readonly createdAt: FieldRef<"Template", 'DateTime'>
    readonly updatedAt: FieldRef<"Template", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Template findUnique
   */
  export type TemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where: TemplateWhereUniqueInput
  }

  /**
   * Template findUniqueOrThrow
   */
  export type TemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where: TemplateWhereUniqueInput
  }

  /**
   * Template findFirst
   */
  export type TemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Templates.
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Templates.
     */
    distinct?: TemplateScalarFieldEnum | TemplateScalarFieldEnum[]
  }

  /**
   * Template findFirstOrThrow
   */
  export type TemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Templates.
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Templates.
     */
    distinct?: TemplateScalarFieldEnum | TemplateScalarFieldEnum[]
  }

  /**
   * Template findMany
   */
  export type TemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Filter, which Templates to fetch.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Templates.
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    distinct?: TemplateScalarFieldEnum | TemplateScalarFieldEnum[]
  }

  /**
   * Template create
   */
  export type TemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * The data needed to create a Template.
     */
    data: XOR<TemplateCreateInput, TemplateUncheckedCreateInput>
  }

  /**
   * Template createMany
   */
  export type TemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Templates.
     */
    data: TemplateCreateManyInput | TemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Template update
   */
  export type TemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * The data needed to update a Template.
     */
    data: XOR<TemplateUpdateInput, TemplateUncheckedUpdateInput>
    /**
     * Choose, which Template to update.
     */
    where: TemplateWhereUniqueInput
  }

  /**
   * Template updateMany
   */
  export type TemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Templates.
     */
    data: XOR<TemplateUpdateManyMutationInput, TemplateUncheckedUpdateManyInput>
    /**
     * Filter which Templates to update
     */
    where?: TemplateWhereInput
    /**
     * Limit how many Templates to update.
     */
    limit?: number
  }

  /**
   * Template upsert
   */
  export type TemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * The filter to search for the Template to update in case it exists.
     */
    where: TemplateWhereUniqueInput
    /**
     * In case the Template found by the `where` argument doesn't exist, create a new Template with this data.
     */
    create: XOR<TemplateCreateInput, TemplateUncheckedCreateInput>
    /**
     * In case the Template was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemplateUpdateInput, TemplateUncheckedUpdateInput>
  }

  /**
   * Template delete
   */
  export type TemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Filter which Template to delete.
     */
    where: TemplateWhereUniqueInput
  }

  /**
   * Template deleteMany
   */
  export type TemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Templates to delete
     */
    where?: TemplateWhereInput
    /**
     * Limit how many Templates to delete.
     */
    limit?: number
  }

  /**
   * Template without action
   */
  export type TemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
  }


  /**
   * Model IncomeMarketing
   */

  export type AggregateIncomeMarketing = {
    _count: IncomeMarketingCountAggregateOutputType | null
    _min: IncomeMarketingMinAggregateOutputType | null
    _max: IncomeMarketingMaxAggregateOutputType | null
  }

  export type IncomeMarketingMinAggregateOutputType = {
    id: string | null
    Date: string | null
    PartyName: string | null
    User: string | null
    Income: string | null
    Amount: string | null
    DueAmount: string | null
    PaymentMethode: string | null
    Status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IncomeMarketingMaxAggregateOutputType = {
    id: string | null
    Date: string | null
    PartyName: string | null
    User: string | null
    Income: string | null
    Amount: string | null
    DueAmount: string | null
    PaymentMethode: string | null
    Status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IncomeMarketingCountAggregateOutputType = {
    id: number
    Date: number
    PartyName: number
    User: number
    Income: number
    Amount: number
    DueAmount: number
    PaymentMethode: number
    Status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IncomeMarketingMinAggregateInputType = {
    id?: true
    Date?: true
    PartyName?: true
    User?: true
    Income?: true
    Amount?: true
    DueAmount?: true
    PaymentMethode?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IncomeMarketingMaxAggregateInputType = {
    id?: true
    Date?: true
    PartyName?: true
    User?: true
    Income?: true
    Amount?: true
    DueAmount?: true
    PaymentMethode?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IncomeMarketingCountAggregateInputType = {
    id?: true
    Date?: true
    PartyName?: true
    User?: true
    Income?: true
    Amount?: true
    DueAmount?: true
    PaymentMethode?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IncomeMarketingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IncomeMarketing to aggregate.
     */
    where?: IncomeMarketingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomeMarketings to fetch.
     */
    orderBy?: IncomeMarketingOrderByWithRelationInput | IncomeMarketingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IncomeMarketingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomeMarketings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomeMarketings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IncomeMarketings
    **/
    _count?: true | IncomeMarketingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IncomeMarketingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IncomeMarketingMaxAggregateInputType
  }

  export type GetIncomeMarketingAggregateType<T extends IncomeMarketingAggregateArgs> = {
        [P in keyof T & keyof AggregateIncomeMarketing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncomeMarketing[P]>
      : GetScalarType<T[P], AggregateIncomeMarketing[P]>
  }




  export type IncomeMarketingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncomeMarketingWhereInput
    orderBy?: IncomeMarketingOrderByWithAggregationInput | IncomeMarketingOrderByWithAggregationInput[]
    by: IncomeMarketingScalarFieldEnum[] | IncomeMarketingScalarFieldEnum
    having?: IncomeMarketingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IncomeMarketingCountAggregateInputType | true
    _min?: IncomeMarketingMinAggregateInputType
    _max?: IncomeMarketingMaxAggregateInputType
  }

  export type IncomeMarketingGroupByOutputType = {
    id: string
    Date: string | null
    PartyName: string | null
    User: string | null
    Income: string | null
    Amount: string | null
    DueAmount: string | null
    PaymentMethode: string | null
    Status: string
    createdAt: Date
    updatedAt: Date
    _count: IncomeMarketingCountAggregateOutputType | null
    _min: IncomeMarketingMinAggregateOutputType | null
    _max: IncomeMarketingMaxAggregateOutputType | null
  }

  type GetIncomeMarketingGroupByPayload<T extends IncomeMarketingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IncomeMarketingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IncomeMarketingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IncomeMarketingGroupByOutputType[P]>
            : GetScalarType<T[P], IncomeMarketingGroupByOutputType[P]>
        }
      >
    >


  export type IncomeMarketingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Date?: boolean
    PartyName?: boolean
    User?: boolean
    Income?: boolean
    Amount?: boolean
    DueAmount?: boolean
    PaymentMethode?: boolean
    Status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["incomeMarketing"]>



  export type IncomeMarketingSelectScalar = {
    id?: boolean
    Date?: boolean
    PartyName?: boolean
    User?: boolean
    Income?: boolean
    Amount?: boolean
    DueAmount?: boolean
    PaymentMethode?: boolean
    Status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IncomeMarketingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "Date" | "PartyName" | "User" | "Income" | "Amount" | "DueAmount" | "PaymentMethode" | "Status" | "createdAt" | "updatedAt", ExtArgs["result"]["incomeMarketing"]>

  export type $IncomeMarketingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IncomeMarketing"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      Date: string | null
      PartyName: string | null
      User: string | null
      Income: string | null
      Amount: string | null
      DueAmount: string | null
      PaymentMethode: string | null
      Status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["incomeMarketing"]>
    composites: {}
  }

  type IncomeMarketingGetPayload<S extends boolean | null | undefined | IncomeMarketingDefaultArgs> = $Result.GetResult<Prisma.$IncomeMarketingPayload, S>

  type IncomeMarketingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IncomeMarketingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IncomeMarketingCountAggregateInputType | true
    }

  export interface IncomeMarketingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IncomeMarketing'], meta: { name: 'IncomeMarketing' } }
    /**
     * Find zero or one IncomeMarketing that matches the filter.
     * @param {IncomeMarketingFindUniqueArgs} args - Arguments to find a IncomeMarketing
     * @example
     * // Get one IncomeMarketing
     * const incomeMarketing = await prisma.incomeMarketing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IncomeMarketingFindUniqueArgs>(args: SelectSubset<T, IncomeMarketingFindUniqueArgs<ExtArgs>>): Prisma__IncomeMarketingClient<$Result.GetResult<Prisma.$IncomeMarketingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IncomeMarketing that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IncomeMarketingFindUniqueOrThrowArgs} args - Arguments to find a IncomeMarketing
     * @example
     * // Get one IncomeMarketing
     * const incomeMarketing = await prisma.incomeMarketing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IncomeMarketingFindUniqueOrThrowArgs>(args: SelectSubset<T, IncomeMarketingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IncomeMarketingClient<$Result.GetResult<Prisma.$IncomeMarketingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IncomeMarketing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeMarketingFindFirstArgs} args - Arguments to find a IncomeMarketing
     * @example
     * // Get one IncomeMarketing
     * const incomeMarketing = await prisma.incomeMarketing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IncomeMarketingFindFirstArgs>(args?: SelectSubset<T, IncomeMarketingFindFirstArgs<ExtArgs>>): Prisma__IncomeMarketingClient<$Result.GetResult<Prisma.$IncomeMarketingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IncomeMarketing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeMarketingFindFirstOrThrowArgs} args - Arguments to find a IncomeMarketing
     * @example
     * // Get one IncomeMarketing
     * const incomeMarketing = await prisma.incomeMarketing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IncomeMarketingFindFirstOrThrowArgs>(args?: SelectSubset<T, IncomeMarketingFindFirstOrThrowArgs<ExtArgs>>): Prisma__IncomeMarketingClient<$Result.GetResult<Prisma.$IncomeMarketingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IncomeMarketings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeMarketingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IncomeMarketings
     * const incomeMarketings = await prisma.incomeMarketing.findMany()
     * 
     * // Get first 10 IncomeMarketings
     * const incomeMarketings = await prisma.incomeMarketing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const incomeMarketingWithIdOnly = await prisma.incomeMarketing.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IncomeMarketingFindManyArgs>(args?: SelectSubset<T, IncomeMarketingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncomeMarketingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IncomeMarketing.
     * @param {IncomeMarketingCreateArgs} args - Arguments to create a IncomeMarketing.
     * @example
     * // Create one IncomeMarketing
     * const IncomeMarketing = await prisma.incomeMarketing.create({
     *   data: {
     *     // ... data to create a IncomeMarketing
     *   }
     * })
     * 
     */
    create<T extends IncomeMarketingCreateArgs>(args: SelectSubset<T, IncomeMarketingCreateArgs<ExtArgs>>): Prisma__IncomeMarketingClient<$Result.GetResult<Prisma.$IncomeMarketingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IncomeMarketings.
     * @param {IncomeMarketingCreateManyArgs} args - Arguments to create many IncomeMarketings.
     * @example
     * // Create many IncomeMarketings
     * const incomeMarketing = await prisma.incomeMarketing.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IncomeMarketingCreateManyArgs>(args?: SelectSubset<T, IncomeMarketingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a IncomeMarketing.
     * @param {IncomeMarketingDeleteArgs} args - Arguments to delete one IncomeMarketing.
     * @example
     * // Delete one IncomeMarketing
     * const IncomeMarketing = await prisma.incomeMarketing.delete({
     *   where: {
     *     // ... filter to delete one IncomeMarketing
     *   }
     * })
     * 
     */
    delete<T extends IncomeMarketingDeleteArgs>(args: SelectSubset<T, IncomeMarketingDeleteArgs<ExtArgs>>): Prisma__IncomeMarketingClient<$Result.GetResult<Prisma.$IncomeMarketingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IncomeMarketing.
     * @param {IncomeMarketingUpdateArgs} args - Arguments to update one IncomeMarketing.
     * @example
     * // Update one IncomeMarketing
     * const incomeMarketing = await prisma.incomeMarketing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IncomeMarketingUpdateArgs>(args: SelectSubset<T, IncomeMarketingUpdateArgs<ExtArgs>>): Prisma__IncomeMarketingClient<$Result.GetResult<Prisma.$IncomeMarketingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IncomeMarketings.
     * @param {IncomeMarketingDeleteManyArgs} args - Arguments to filter IncomeMarketings to delete.
     * @example
     * // Delete a few IncomeMarketings
     * const { count } = await prisma.incomeMarketing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IncomeMarketingDeleteManyArgs>(args?: SelectSubset<T, IncomeMarketingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IncomeMarketings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeMarketingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IncomeMarketings
     * const incomeMarketing = await prisma.incomeMarketing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IncomeMarketingUpdateManyArgs>(args: SelectSubset<T, IncomeMarketingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IncomeMarketing.
     * @param {IncomeMarketingUpsertArgs} args - Arguments to update or create a IncomeMarketing.
     * @example
     * // Update or create a IncomeMarketing
     * const incomeMarketing = await prisma.incomeMarketing.upsert({
     *   create: {
     *     // ... data to create a IncomeMarketing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IncomeMarketing we want to update
     *   }
     * })
     */
    upsert<T extends IncomeMarketingUpsertArgs>(args: SelectSubset<T, IncomeMarketingUpsertArgs<ExtArgs>>): Prisma__IncomeMarketingClient<$Result.GetResult<Prisma.$IncomeMarketingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of IncomeMarketings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeMarketingCountArgs} args - Arguments to filter IncomeMarketings to count.
     * @example
     * // Count the number of IncomeMarketings
     * const count = await prisma.incomeMarketing.count({
     *   where: {
     *     // ... the filter for the IncomeMarketings we want to count
     *   }
     * })
    **/
    count<T extends IncomeMarketingCountArgs>(
      args?: Subset<T, IncomeMarketingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IncomeMarketingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IncomeMarketing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeMarketingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IncomeMarketingAggregateArgs>(args: Subset<T, IncomeMarketingAggregateArgs>): Prisma.PrismaPromise<GetIncomeMarketingAggregateType<T>>

    /**
     * Group by IncomeMarketing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeMarketingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IncomeMarketingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IncomeMarketingGroupByArgs['orderBy'] }
        : { orderBy?: IncomeMarketingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IncomeMarketingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncomeMarketingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IncomeMarketing model
   */
  readonly fields: IncomeMarketingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IncomeMarketing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IncomeMarketingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IncomeMarketing model
   */
  interface IncomeMarketingFieldRefs {
    readonly id: FieldRef<"IncomeMarketing", 'String'>
    readonly Date: FieldRef<"IncomeMarketing", 'String'>
    readonly PartyName: FieldRef<"IncomeMarketing", 'String'>
    readonly User: FieldRef<"IncomeMarketing", 'String'>
    readonly Income: FieldRef<"IncomeMarketing", 'String'>
    readonly Amount: FieldRef<"IncomeMarketing", 'String'>
    readonly DueAmount: FieldRef<"IncomeMarketing", 'String'>
    readonly PaymentMethode: FieldRef<"IncomeMarketing", 'String'>
    readonly Status: FieldRef<"IncomeMarketing", 'String'>
    readonly createdAt: FieldRef<"IncomeMarketing", 'DateTime'>
    readonly updatedAt: FieldRef<"IncomeMarketing", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IncomeMarketing findUnique
   */
  export type IncomeMarketingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeMarketing
     */
    select?: IncomeMarketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncomeMarketing
     */
    omit?: IncomeMarketingOmit<ExtArgs> | null
    /**
     * Filter, which IncomeMarketing to fetch.
     */
    where: IncomeMarketingWhereUniqueInput
  }

  /**
   * IncomeMarketing findUniqueOrThrow
   */
  export type IncomeMarketingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeMarketing
     */
    select?: IncomeMarketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncomeMarketing
     */
    omit?: IncomeMarketingOmit<ExtArgs> | null
    /**
     * Filter, which IncomeMarketing to fetch.
     */
    where: IncomeMarketingWhereUniqueInput
  }

  /**
   * IncomeMarketing findFirst
   */
  export type IncomeMarketingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeMarketing
     */
    select?: IncomeMarketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncomeMarketing
     */
    omit?: IncomeMarketingOmit<ExtArgs> | null
    /**
     * Filter, which IncomeMarketing to fetch.
     */
    where?: IncomeMarketingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomeMarketings to fetch.
     */
    orderBy?: IncomeMarketingOrderByWithRelationInput | IncomeMarketingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncomeMarketings.
     */
    cursor?: IncomeMarketingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomeMarketings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomeMarketings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncomeMarketings.
     */
    distinct?: IncomeMarketingScalarFieldEnum | IncomeMarketingScalarFieldEnum[]
  }

  /**
   * IncomeMarketing findFirstOrThrow
   */
  export type IncomeMarketingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeMarketing
     */
    select?: IncomeMarketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncomeMarketing
     */
    omit?: IncomeMarketingOmit<ExtArgs> | null
    /**
     * Filter, which IncomeMarketing to fetch.
     */
    where?: IncomeMarketingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomeMarketings to fetch.
     */
    orderBy?: IncomeMarketingOrderByWithRelationInput | IncomeMarketingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncomeMarketings.
     */
    cursor?: IncomeMarketingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomeMarketings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomeMarketings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncomeMarketings.
     */
    distinct?: IncomeMarketingScalarFieldEnum | IncomeMarketingScalarFieldEnum[]
  }

  /**
   * IncomeMarketing findMany
   */
  export type IncomeMarketingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeMarketing
     */
    select?: IncomeMarketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncomeMarketing
     */
    omit?: IncomeMarketingOmit<ExtArgs> | null
    /**
     * Filter, which IncomeMarketings to fetch.
     */
    where?: IncomeMarketingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomeMarketings to fetch.
     */
    orderBy?: IncomeMarketingOrderByWithRelationInput | IncomeMarketingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IncomeMarketings.
     */
    cursor?: IncomeMarketingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomeMarketings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomeMarketings.
     */
    skip?: number
    distinct?: IncomeMarketingScalarFieldEnum | IncomeMarketingScalarFieldEnum[]
  }

  /**
   * IncomeMarketing create
   */
  export type IncomeMarketingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeMarketing
     */
    select?: IncomeMarketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncomeMarketing
     */
    omit?: IncomeMarketingOmit<ExtArgs> | null
    /**
     * The data needed to create a IncomeMarketing.
     */
    data: XOR<IncomeMarketingCreateInput, IncomeMarketingUncheckedCreateInput>
  }

  /**
   * IncomeMarketing createMany
   */
  export type IncomeMarketingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IncomeMarketings.
     */
    data: IncomeMarketingCreateManyInput | IncomeMarketingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IncomeMarketing update
   */
  export type IncomeMarketingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeMarketing
     */
    select?: IncomeMarketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncomeMarketing
     */
    omit?: IncomeMarketingOmit<ExtArgs> | null
    /**
     * The data needed to update a IncomeMarketing.
     */
    data: XOR<IncomeMarketingUpdateInput, IncomeMarketingUncheckedUpdateInput>
    /**
     * Choose, which IncomeMarketing to update.
     */
    where: IncomeMarketingWhereUniqueInput
  }

  /**
   * IncomeMarketing updateMany
   */
  export type IncomeMarketingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IncomeMarketings.
     */
    data: XOR<IncomeMarketingUpdateManyMutationInput, IncomeMarketingUncheckedUpdateManyInput>
    /**
     * Filter which IncomeMarketings to update
     */
    where?: IncomeMarketingWhereInput
    /**
     * Limit how many IncomeMarketings to update.
     */
    limit?: number
  }

  /**
   * IncomeMarketing upsert
   */
  export type IncomeMarketingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeMarketing
     */
    select?: IncomeMarketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncomeMarketing
     */
    omit?: IncomeMarketingOmit<ExtArgs> | null
    /**
     * The filter to search for the IncomeMarketing to update in case it exists.
     */
    where: IncomeMarketingWhereUniqueInput
    /**
     * In case the IncomeMarketing found by the `where` argument doesn't exist, create a new IncomeMarketing with this data.
     */
    create: XOR<IncomeMarketingCreateInput, IncomeMarketingUncheckedCreateInput>
    /**
     * In case the IncomeMarketing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IncomeMarketingUpdateInput, IncomeMarketingUncheckedUpdateInput>
  }

  /**
   * IncomeMarketing delete
   */
  export type IncomeMarketingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeMarketing
     */
    select?: IncomeMarketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncomeMarketing
     */
    omit?: IncomeMarketingOmit<ExtArgs> | null
    /**
     * Filter which IncomeMarketing to delete.
     */
    where: IncomeMarketingWhereUniqueInput
  }

  /**
   * IncomeMarketing deleteMany
   */
  export type IncomeMarketingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IncomeMarketings to delete
     */
    where?: IncomeMarketingWhereInput
    /**
     * Limit how many IncomeMarketings to delete.
     */
    limit?: number
  }

  /**
   * IncomeMarketing without action
   */
  export type IncomeMarketingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomeMarketing
     */
    select?: IncomeMarketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IncomeMarketing
     */
    omit?: IncomeMarketingOmit<ExtArgs> | null
  }


  /**
   * Model ExpenseMarketing
   */

  export type AggregateExpenseMarketing = {
    _count: ExpenseMarketingCountAggregateOutputType | null
    _min: ExpenseMarketingMinAggregateOutputType | null
    _max: ExpenseMarketingMaxAggregateOutputType | null
  }

  export type ExpenseMarketingMinAggregateOutputType = {
    id: string | null
    Date: string | null
    PartyName: string | null
    User: string | null
    Expense: string | null
    Amount: string | null
    DueAmount: string | null
    PaymentMethode: string | null
    Status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpenseMarketingMaxAggregateOutputType = {
    id: string | null
    Date: string | null
    PartyName: string | null
    User: string | null
    Expense: string | null
    Amount: string | null
    DueAmount: string | null
    PaymentMethode: string | null
    Status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExpenseMarketingCountAggregateOutputType = {
    id: number
    Date: number
    PartyName: number
    User: number
    Expense: number
    Amount: number
    DueAmount: number
    PaymentMethode: number
    Status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExpenseMarketingMinAggregateInputType = {
    id?: true
    Date?: true
    PartyName?: true
    User?: true
    Expense?: true
    Amount?: true
    DueAmount?: true
    PaymentMethode?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpenseMarketingMaxAggregateInputType = {
    id?: true
    Date?: true
    PartyName?: true
    User?: true
    Expense?: true
    Amount?: true
    DueAmount?: true
    PaymentMethode?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExpenseMarketingCountAggregateInputType = {
    id?: true
    Date?: true
    PartyName?: true
    User?: true
    Expense?: true
    Amount?: true
    DueAmount?: true
    PaymentMethode?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExpenseMarketingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpenseMarketing to aggregate.
     */
    where?: ExpenseMarketingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseMarketings to fetch.
     */
    orderBy?: ExpenseMarketingOrderByWithRelationInput | ExpenseMarketingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseMarketingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseMarketings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseMarketings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExpenseMarketings
    **/
    _count?: true | ExpenseMarketingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseMarketingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseMarketingMaxAggregateInputType
  }

  export type GetExpenseMarketingAggregateType<T extends ExpenseMarketingAggregateArgs> = {
        [P in keyof T & keyof AggregateExpenseMarketing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpenseMarketing[P]>
      : GetScalarType<T[P], AggregateExpenseMarketing[P]>
  }




  export type ExpenseMarketingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseMarketingWhereInput
    orderBy?: ExpenseMarketingOrderByWithAggregationInput | ExpenseMarketingOrderByWithAggregationInput[]
    by: ExpenseMarketingScalarFieldEnum[] | ExpenseMarketingScalarFieldEnum
    having?: ExpenseMarketingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseMarketingCountAggregateInputType | true
    _min?: ExpenseMarketingMinAggregateInputType
    _max?: ExpenseMarketingMaxAggregateInputType
  }

  export type ExpenseMarketingGroupByOutputType = {
    id: string
    Date: string | null
    PartyName: string | null
    User: string | null
    Expense: string | null
    Amount: string | null
    DueAmount: string | null
    PaymentMethode: string | null
    Status: string
    createdAt: Date
    updatedAt: Date
    _count: ExpenseMarketingCountAggregateOutputType | null
    _min: ExpenseMarketingMinAggregateOutputType | null
    _max: ExpenseMarketingMaxAggregateOutputType | null
  }

  type GetExpenseMarketingGroupByPayload<T extends ExpenseMarketingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseMarketingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseMarketingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseMarketingGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseMarketingGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseMarketingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Date?: boolean
    PartyName?: boolean
    User?: boolean
    Expense?: boolean
    Amount?: boolean
    DueAmount?: boolean
    PaymentMethode?: boolean
    Status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["expenseMarketing"]>



  export type ExpenseMarketingSelectScalar = {
    id?: boolean
    Date?: boolean
    PartyName?: boolean
    User?: boolean
    Expense?: boolean
    Amount?: boolean
    DueAmount?: boolean
    PaymentMethode?: boolean
    Status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExpenseMarketingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "Date" | "PartyName" | "User" | "Expense" | "Amount" | "DueAmount" | "PaymentMethode" | "Status" | "createdAt" | "updatedAt", ExtArgs["result"]["expenseMarketing"]>

  export type $ExpenseMarketingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExpenseMarketing"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      Date: string | null
      PartyName: string | null
      User: string | null
      Expense: string | null
      Amount: string | null
      DueAmount: string | null
      PaymentMethode: string | null
      Status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["expenseMarketing"]>
    composites: {}
  }

  type ExpenseMarketingGetPayload<S extends boolean | null | undefined | ExpenseMarketingDefaultArgs> = $Result.GetResult<Prisma.$ExpenseMarketingPayload, S>

  type ExpenseMarketingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExpenseMarketingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExpenseMarketingCountAggregateInputType | true
    }

  export interface ExpenseMarketingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExpenseMarketing'], meta: { name: 'ExpenseMarketing' } }
    /**
     * Find zero or one ExpenseMarketing that matches the filter.
     * @param {ExpenseMarketingFindUniqueArgs} args - Arguments to find a ExpenseMarketing
     * @example
     * // Get one ExpenseMarketing
     * const expenseMarketing = await prisma.expenseMarketing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseMarketingFindUniqueArgs>(args: SelectSubset<T, ExpenseMarketingFindUniqueArgs<ExtArgs>>): Prisma__ExpenseMarketingClient<$Result.GetResult<Prisma.$ExpenseMarketingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExpenseMarketing that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExpenseMarketingFindUniqueOrThrowArgs} args - Arguments to find a ExpenseMarketing
     * @example
     * // Get one ExpenseMarketing
     * const expenseMarketing = await prisma.expenseMarketing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseMarketingFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseMarketingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseMarketingClient<$Result.GetResult<Prisma.$ExpenseMarketingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExpenseMarketing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseMarketingFindFirstArgs} args - Arguments to find a ExpenseMarketing
     * @example
     * // Get one ExpenseMarketing
     * const expenseMarketing = await prisma.expenseMarketing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseMarketingFindFirstArgs>(args?: SelectSubset<T, ExpenseMarketingFindFirstArgs<ExtArgs>>): Prisma__ExpenseMarketingClient<$Result.GetResult<Prisma.$ExpenseMarketingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExpenseMarketing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseMarketingFindFirstOrThrowArgs} args - Arguments to find a ExpenseMarketing
     * @example
     * // Get one ExpenseMarketing
     * const expenseMarketing = await prisma.expenseMarketing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseMarketingFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseMarketingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseMarketingClient<$Result.GetResult<Prisma.$ExpenseMarketingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExpenseMarketings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseMarketingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExpenseMarketings
     * const expenseMarketings = await prisma.expenseMarketing.findMany()
     * 
     * // Get first 10 ExpenseMarketings
     * const expenseMarketings = await prisma.expenseMarketing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseMarketingWithIdOnly = await prisma.expenseMarketing.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseMarketingFindManyArgs>(args?: SelectSubset<T, ExpenseMarketingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseMarketingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExpenseMarketing.
     * @param {ExpenseMarketingCreateArgs} args - Arguments to create a ExpenseMarketing.
     * @example
     * // Create one ExpenseMarketing
     * const ExpenseMarketing = await prisma.expenseMarketing.create({
     *   data: {
     *     // ... data to create a ExpenseMarketing
     *   }
     * })
     * 
     */
    create<T extends ExpenseMarketingCreateArgs>(args: SelectSubset<T, ExpenseMarketingCreateArgs<ExtArgs>>): Prisma__ExpenseMarketingClient<$Result.GetResult<Prisma.$ExpenseMarketingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExpenseMarketings.
     * @param {ExpenseMarketingCreateManyArgs} args - Arguments to create many ExpenseMarketings.
     * @example
     * // Create many ExpenseMarketings
     * const expenseMarketing = await prisma.expenseMarketing.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseMarketingCreateManyArgs>(args?: SelectSubset<T, ExpenseMarketingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ExpenseMarketing.
     * @param {ExpenseMarketingDeleteArgs} args - Arguments to delete one ExpenseMarketing.
     * @example
     * // Delete one ExpenseMarketing
     * const ExpenseMarketing = await prisma.expenseMarketing.delete({
     *   where: {
     *     // ... filter to delete one ExpenseMarketing
     *   }
     * })
     * 
     */
    delete<T extends ExpenseMarketingDeleteArgs>(args: SelectSubset<T, ExpenseMarketingDeleteArgs<ExtArgs>>): Prisma__ExpenseMarketingClient<$Result.GetResult<Prisma.$ExpenseMarketingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExpenseMarketing.
     * @param {ExpenseMarketingUpdateArgs} args - Arguments to update one ExpenseMarketing.
     * @example
     * // Update one ExpenseMarketing
     * const expenseMarketing = await prisma.expenseMarketing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseMarketingUpdateArgs>(args: SelectSubset<T, ExpenseMarketingUpdateArgs<ExtArgs>>): Prisma__ExpenseMarketingClient<$Result.GetResult<Prisma.$ExpenseMarketingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExpenseMarketings.
     * @param {ExpenseMarketingDeleteManyArgs} args - Arguments to filter ExpenseMarketings to delete.
     * @example
     * // Delete a few ExpenseMarketings
     * const { count } = await prisma.expenseMarketing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseMarketingDeleteManyArgs>(args?: SelectSubset<T, ExpenseMarketingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExpenseMarketings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseMarketingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExpenseMarketings
     * const expenseMarketing = await prisma.expenseMarketing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseMarketingUpdateManyArgs>(args: SelectSubset<T, ExpenseMarketingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExpenseMarketing.
     * @param {ExpenseMarketingUpsertArgs} args - Arguments to update or create a ExpenseMarketing.
     * @example
     * // Update or create a ExpenseMarketing
     * const expenseMarketing = await prisma.expenseMarketing.upsert({
     *   create: {
     *     // ... data to create a ExpenseMarketing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExpenseMarketing we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseMarketingUpsertArgs>(args: SelectSubset<T, ExpenseMarketingUpsertArgs<ExtArgs>>): Prisma__ExpenseMarketingClient<$Result.GetResult<Prisma.$ExpenseMarketingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExpenseMarketings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseMarketingCountArgs} args - Arguments to filter ExpenseMarketings to count.
     * @example
     * // Count the number of ExpenseMarketings
     * const count = await prisma.expenseMarketing.count({
     *   where: {
     *     // ... the filter for the ExpenseMarketings we want to count
     *   }
     * })
    **/
    count<T extends ExpenseMarketingCountArgs>(
      args?: Subset<T, ExpenseMarketingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseMarketingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExpenseMarketing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseMarketingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseMarketingAggregateArgs>(args: Subset<T, ExpenseMarketingAggregateArgs>): Prisma.PrismaPromise<GetExpenseMarketingAggregateType<T>>

    /**
     * Group by ExpenseMarketing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseMarketingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseMarketingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseMarketingGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseMarketingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseMarketingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseMarketingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExpenseMarketing model
   */
  readonly fields: ExpenseMarketingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExpenseMarketing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseMarketingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExpenseMarketing model
   */
  interface ExpenseMarketingFieldRefs {
    readonly id: FieldRef<"ExpenseMarketing", 'String'>
    readonly Date: FieldRef<"ExpenseMarketing", 'String'>
    readonly PartyName: FieldRef<"ExpenseMarketing", 'String'>
    readonly User: FieldRef<"ExpenseMarketing", 'String'>
    readonly Expense: FieldRef<"ExpenseMarketing", 'String'>
    readonly Amount: FieldRef<"ExpenseMarketing", 'String'>
    readonly DueAmount: FieldRef<"ExpenseMarketing", 'String'>
    readonly PaymentMethode: FieldRef<"ExpenseMarketing", 'String'>
    readonly Status: FieldRef<"ExpenseMarketing", 'String'>
    readonly createdAt: FieldRef<"ExpenseMarketing", 'DateTime'>
    readonly updatedAt: FieldRef<"ExpenseMarketing", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExpenseMarketing findUnique
   */
  export type ExpenseMarketingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseMarketing
     */
    select?: ExpenseMarketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseMarketing
     */
    omit?: ExpenseMarketingOmit<ExtArgs> | null
    /**
     * Filter, which ExpenseMarketing to fetch.
     */
    where: ExpenseMarketingWhereUniqueInput
  }

  /**
   * ExpenseMarketing findUniqueOrThrow
   */
  export type ExpenseMarketingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseMarketing
     */
    select?: ExpenseMarketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseMarketing
     */
    omit?: ExpenseMarketingOmit<ExtArgs> | null
    /**
     * Filter, which ExpenseMarketing to fetch.
     */
    where: ExpenseMarketingWhereUniqueInput
  }

  /**
   * ExpenseMarketing findFirst
   */
  export type ExpenseMarketingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseMarketing
     */
    select?: ExpenseMarketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseMarketing
     */
    omit?: ExpenseMarketingOmit<ExtArgs> | null
    /**
     * Filter, which ExpenseMarketing to fetch.
     */
    where?: ExpenseMarketingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseMarketings to fetch.
     */
    orderBy?: ExpenseMarketingOrderByWithRelationInput | ExpenseMarketingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpenseMarketings.
     */
    cursor?: ExpenseMarketingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseMarketings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseMarketings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpenseMarketings.
     */
    distinct?: ExpenseMarketingScalarFieldEnum | ExpenseMarketingScalarFieldEnum[]
  }

  /**
   * ExpenseMarketing findFirstOrThrow
   */
  export type ExpenseMarketingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseMarketing
     */
    select?: ExpenseMarketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseMarketing
     */
    omit?: ExpenseMarketingOmit<ExtArgs> | null
    /**
     * Filter, which ExpenseMarketing to fetch.
     */
    where?: ExpenseMarketingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseMarketings to fetch.
     */
    orderBy?: ExpenseMarketingOrderByWithRelationInput | ExpenseMarketingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpenseMarketings.
     */
    cursor?: ExpenseMarketingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseMarketings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseMarketings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpenseMarketings.
     */
    distinct?: ExpenseMarketingScalarFieldEnum | ExpenseMarketingScalarFieldEnum[]
  }

  /**
   * ExpenseMarketing findMany
   */
  export type ExpenseMarketingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseMarketing
     */
    select?: ExpenseMarketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseMarketing
     */
    omit?: ExpenseMarketingOmit<ExtArgs> | null
    /**
     * Filter, which ExpenseMarketings to fetch.
     */
    where?: ExpenseMarketingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseMarketings to fetch.
     */
    orderBy?: ExpenseMarketingOrderByWithRelationInput | ExpenseMarketingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExpenseMarketings.
     */
    cursor?: ExpenseMarketingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseMarketings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseMarketings.
     */
    skip?: number
    distinct?: ExpenseMarketingScalarFieldEnum | ExpenseMarketingScalarFieldEnum[]
  }

  /**
   * ExpenseMarketing create
   */
  export type ExpenseMarketingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseMarketing
     */
    select?: ExpenseMarketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseMarketing
     */
    omit?: ExpenseMarketingOmit<ExtArgs> | null
    /**
     * The data needed to create a ExpenseMarketing.
     */
    data: XOR<ExpenseMarketingCreateInput, ExpenseMarketingUncheckedCreateInput>
  }

  /**
   * ExpenseMarketing createMany
   */
  export type ExpenseMarketingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExpenseMarketings.
     */
    data: ExpenseMarketingCreateManyInput | ExpenseMarketingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExpenseMarketing update
   */
  export type ExpenseMarketingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseMarketing
     */
    select?: ExpenseMarketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseMarketing
     */
    omit?: ExpenseMarketingOmit<ExtArgs> | null
    /**
     * The data needed to update a ExpenseMarketing.
     */
    data: XOR<ExpenseMarketingUpdateInput, ExpenseMarketingUncheckedUpdateInput>
    /**
     * Choose, which ExpenseMarketing to update.
     */
    where: ExpenseMarketingWhereUniqueInput
  }

  /**
   * ExpenseMarketing updateMany
   */
  export type ExpenseMarketingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExpenseMarketings.
     */
    data: XOR<ExpenseMarketingUpdateManyMutationInput, ExpenseMarketingUncheckedUpdateManyInput>
    /**
     * Filter which ExpenseMarketings to update
     */
    where?: ExpenseMarketingWhereInput
    /**
     * Limit how many ExpenseMarketings to update.
     */
    limit?: number
  }

  /**
   * ExpenseMarketing upsert
   */
  export type ExpenseMarketingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseMarketing
     */
    select?: ExpenseMarketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseMarketing
     */
    omit?: ExpenseMarketingOmit<ExtArgs> | null
    /**
     * The filter to search for the ExpenseMarketing to update in case it exists.
     */
    where: ExpenseMarketingWhereUniqueInput
    /**
     * In case the ExpenseMarketing found by the `where` argument doesn't exist, create a new ExpenseMarketing with this data.
     */
    create: XOR<ExpenseMarketingCreateInput, ExpenseMarketingUncheckedCreateInput>
    /**
     * In case the ExpenseMarketing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseMarketingUpdateInput, ExpenseMarketingUncheckedUpdateInput>
  }

  /**
   * ExpenseMarketing delete
   */
  export type ExpenseMarketingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseMarketing
     */
    select?: ExpenseMarketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseMarketing
     */
    omit?: ExpenseMarketingOmit<ExtArgs> | null
    /**
     * Filter which ExpenseMarketing to delete.
     */
    where: ExpenseMarketingWhereUniqueInput
  }

  /**
   * ExpenseMarketing deleteMany
   */
  export type ExpenseMarketingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpenseMarketings to delete
     */
    where?: ExpenseMarketingWhereInput
    /**
     * Limit how many ExpenseMarketings to delete.
     */
    limit?: number
  }

  /**
   * ExpenseMarketing without action
   */
  export type ExpenseMarketingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseMarketing
     */
    select?: ExpenseMarketingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseMarketing
     */
    omit?: ExpenseMarketingOmit<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskMinAggregateOutputType = {
    id: string | null
    date: string | null
    Time: string | null
    Description: string | null
    User: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskMaxAggregateOutputType = {
    id: string | null
    date: string | null
    Time: string | null
    Description: string | null
    User: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    date: number
    Time: number
    Description: number
    User: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TaskMinAggregateInputType = {
    id?: true
    date?: true
    Time?: true
    Description?: true
    User?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    date?: true
    Time?: true
    Description?: true
    User?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    date?: true
    Time?: true
    Description?: true
    User?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: string
    date: string | null
    Time: string | null
    Description: string | null
    User: string | null
    createdAt: Date
    updatedAt: Date
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    Time?: boolean
    Description?: boolean
    User?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["task"]>



  export type TaskSelectScalar = {
    id?: boolean
    date?: boolean
    Time?: boolean
    Description?: boolean
    User?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "Time" | "Description" | "User" | "createdAt" | "updatedAt", ExtArgs["result"]["task"]>

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: string | null
      Time: string | null
      Description: string | null
      User: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'String'>
    readonly date: FieldRef<"Task", 'String'>
    readonly Time: FieldRef<"Task", 'String'>
    readonly Description: FieldRef<"Task", 'String'>
    readonly User: FieldRef<"Task", 'String'>
    readonly createdAt: FieldRef<"Task", 'DateTime'>
    readonly updatedAt: FieldRef<"Task", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to delete.
     */
    limit?: number
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
  }


  /**
   * Model Schedule
   */

  export type AggregateSchedule = {
    _count: ScheduleCountAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
  }

  export type ScheduleMinAggregateOutputType = {
    id: string | null
    date: string | null
    Time: string | null
    Description: string | null
    User: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduleMaxAggregateOutputType = {
    id: string | null
    date: string | null
    Time: string | null
    Description: string | null
    User: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduleCountAggregateOutputType = {
    id: number
    date: number
    Time: number
    Description: number
    User: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ScheduleMinAggregateInputType = {
    id?: true
    date?: true
    Time?: true
    Description?: true
    User?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduleMaxAggregateInputType = {
    id?: true
    date?: true
    Time?: true
    Description?: true
    User?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduleCountAggregateInputType = {
    id?: true
    date?: true
    Time?: true
    Description?: true
    User?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schedule to aggregate.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Schedules
    **/
    _count?: true | ScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduleMaxAggregateInputType
  }

  export type GetScheduleAggregateType<T extends ScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchedule[P]>
      : GetScalarType<T[P], AggregateSchedule[P]>
  }




  export type ScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithAggregationInput | ScheduleOrderByWithAggregationInput[]
    by: ScheduleScalarFieldEnum[] | ScheduleScalarFieldEnum
    having?: ScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduleCountAggregateInputType | true
    _min?: ScheduleMinAggregateInputType
    _max?: ScheduleMaxAggregateInputType
  }

  export type ScheduleGroupByOutputType = {
    id: string
    date: string | null
    Time: string | null
    Description: string | null
    User: string | null
    createdAt: Date
    updatedAt: Date
    _count: ScheduleCountAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
  }

  type GetScheduleGroupByPayload<T extends ScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduleGroupByOutputType[P]>
        }
      >
    >


  export type ScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    Time?: boolean
    Description?: boolean
    User?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["schedule"]>



  export type ScheduleSelectScalar = {
    id?: boolean
    date?: boolean
    Time?: boolean
    Description?: boolean
    User?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ScheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "Time" | "Description" | "User" | "createdAt" | "updatedAt", ExtArgs["result"]["schedule"]>

  export type $SchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Schedule"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: string | null
      Time: string | null
      Description: string | null
      User: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["schedule"]>
    composites: {}
  }

  type ScheduleGetPayload<S extends boolean | null | undefined | ScheduleDefaultArgs> = $Result.GetResult<Prisma.$SchedulePayload, S>

  type ScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScheduleCountAggregateInputType | true
    }

  export interface ScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Schedule'], meta: { name: 'Schedule' } }
    /**
     * Find zero or one Schedule that matches the filter.
     * @param {ScheduleFindUniqueArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduleFindUniqueArgs>(args: SelectSubset<T, ScheduleFindUniqueArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Schedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScheduleFindUniqueOrThrowArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Schedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindFirstArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduleFindFirstArgs>(args?: SelectSubset<T, ScheduleFindFirstArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Schedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindFirstOrThrowArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Schedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schedules
     * const schedules = await prisma.schedule.findMany()
     * 
     * // Get first 10 Schedules
     * const schedules = await prisma.schedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduleWithIdOnly = await prisma.schedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduleFindManyArgs>(args?: SelectSubset<T, ScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Schedule.
     * @param {ScheduleCreateArgs} args - Arguments to create a Schedule.
     * @example
     * // Create one Schedule
     * const Schedule = await prisma.schedule.create({
     *   data: {
     *     // ... data to create a Schedule
     *   }
     * })
     * 
     */
    create<T extends ScheduleCreateArgs>(args: SelectSubset<T, ScheduleCreateArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Schedules.
     * @param {ScheduleCreateManyArgs} args - Arguments to create many Schedules.
     * @example
     * // Create many Schedules
     * const schedule = await prisma.schedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduleCreateManyArgs>(args?: SelectSubset<T, ScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Schedule.
     * @param {ScheduleDeleteArgs} args - Arguments to delete one Schedule.
     * @example
     * // Delete one Schedule
     * const Schedule = await prisma.schedule.delete({
     *   where: {
     *     // ... filter to delete one Schedule
     *   }
     * })
     * 
     */
    delete<T extends ScheduleDeleteArgs>(args: SelectSubset<T, ScheduleDeleteArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Schedule.
     * @param {ScheduleUpdateArgs} args - Arguments to update one Schedule.
     * @example
     * // Update one Schedule
     * const schedule = await prisma.schedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduleUpdateArgs>(args: SelectSubset<T, ScheduleUpdateArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Schedules.
     * @param {ScheduleDeleteManyArgs} args - Arguments to filter Schedules to delete.
     * @example
     * // Delete a few Schedules
     * const { count } = await prisma.schedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduleDeleteManyArgs>(args?: SelectSubset<T, ScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schedules
     * const schedule = await prisma.schedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduleUpdateManyArgs>(args: SelectSubset<T, ScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Schedule.
     * @param {ScheduleUpsertArgs} args - Arguments to update or create a Schedule.
     * @example
     * // Update or create a Schedule
     * const schedule = await prisma.schedule.upsert({
     *   create: {
     *     // ... data to create a Schedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Schedule we want to update
     *   }
     * })
     */
    upsert<T extends ScheduleUpsertArgs>(args: SelectSubset<T, ScheduleUpsertArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleCountArgs} args - Arguments to filter Schedules to count.
     * @example
     * // Count the number of Schedules
     * const count = await prisma.schedule.count({
     *   where: {
     *     // ... the filter for the Schedules we want to count
     *   }
     * })
    **/
    count<T extends ScheduleCountArgs>(
      args?: Subset<T, ScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduleAggregateArgs>(args: Subset<T, ScheduleAggregateArgs>): Prisma.PrismaPromise<GetScheduleAggregateType<T>>

    /**
     * Group by Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduleGroupByArgs['orderBy'] }
        : { orderBy?: ScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Schedule model
   */
  readonly fields: ScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Schedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Schedule model
   */
  interface ScheduleFieldRefs {
    readonly id: FieldRef<"Schedule", 'String'>
    readonly date: FieldRef<"Schedule", 'String'>
    readonly Time: FieldRef<"Schedule", 'String'>
    readonly Description: FieldRef<"Schedule", 'String'>
    readonly User: FieldRef<"Schedule", 'String'>
    readonly createdAt: FieldRef<"Schedule", 'DateTime'>
    readonly updatedAt: FieldRef<"Schedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Schedule findUnique
   */
  export type ScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule findUniqueOrThrow
   */
  export type ScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule findFirst
   */
  export type ScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedules.
     */
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule findFirstOrThrow
   */
  export type ScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedules.
     */
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule findMany
   */
  export type ScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Filter, which Schedules to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule create
   */
  export type ScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * The data needed to create a Schedule.
     */
    data: XOR<ScheduleCreateInput, ScheduleUncheckedCreateInput>
  }

  /**
   * Schedule createMany
   */
  export type ScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Schedules.
     */
    data: ScheduleCreateManyInput | ScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Schedule update
   */
  export type ScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * The data needed to update a Schedule.
     */
    data: XOR<ScheduleUpdateInput, ScheduleUncheckedUpdateInput>
    /**
     * Choose, which Schedule to update.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule updateMany
   */
  export type ScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Schedules.
     */
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyInput>
    /**
     * Filter which Schedules to update
     */
    where?: ScheduleWhereInput
    /**
     * Limit how many Schedules to update.
     */
    limit?: number
  }

  /**
   * Schedule upsert
   */
  export type ScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * The filter to search for the Schedule to update in case it exists.
     */
    where: ScheduleWhereUniqueInput
    /**
     * In case the Schedule found by the `where` argument doesn't exist, create a new Schedule with this data.
     */
    create: XOR<ScheduleCreateInput, ScheduleUncheckedCreateInput>
    /**
     * In case the Schedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduleUpdateInput, ScheduleUncheckedUpdateInput>
  }

  /**
   * Schedule delete
   */
  export type ScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Filter which Schedule to delete.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule deleteMany
   */
  export type ScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schedules to delete
     */
    where?: ScheduleWhereInput
    /**
     * Limit how many Schedules to delete.
     */
    limit?: number
  }

  /**
   * Schedule without action
   */
  export type ScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
  }


  /**
   * Model CompanyProject
   */

  export type AggregateCompanyProject = {
    _count: CompanyProjectCountAggregateOutputType | null
    _min: CompanyProjectMinAggregateOutputType | null
    _max: CompanyProjectMaxAggregateOutputType | null
  }

  export type CompanyProjectMinAggregateOutputType = {
    id: string | null
    ProjectName: string | null
    ProjectType: string | null
    ProjectStatus: string | null
    City: string | null
    Location: string | null
    Area: string | null
    Range: string | null
    Adderess: string | null
    Facillities: string | null
    Amenities: string | null
    Description: string | null
    Video: string | null
    GoogleMap: string | null
    CreatedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyProjectMaxAggregateOutputType = {
    id: string | null
    ProjectName: string | null
    ProjectType: string | null
    ProjectStatus: string | null
    City: string | null
    Location: string | null
    Area: string | null
    Range: string | null
    Adderess: string | null
    Facillities: string | null
    Amenities: string | null
    Description: string | null
    Video: string | null
    GoogleMap: string | null
    CreatedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyProjectCountAggregateOutputType = {
    id: number
    ProjectName: number
    ProjectType: number
    ProjectStatus: number
    City: number
    Location: number
    Area: number
    Range: number
    Adderess: number
    Facillities: number
    Amenities: number
    Description: number
    Video: number
    GoogleMap: number
    CustomerImage: number
    SitePlan: number
    CreatedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyProjectMinAggregateInputType = {
    id?: true
    ProjectName?: true
    ProjectType?: true
    ProjectStatus?: true
    City?: true
    Location?: true
    Area?: true
    Range?: true
    Adderess?: true
    Facillities?: true
    Amenities?: true
    Description?: true
    Video?: true
    GoogleMap?: true
    CreatedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyProjectMaxAggregateInputType = {
    id?: true
    ProjectName?: true
    ProjectType?: true
    ProjectStatus?: true
    City?: true
    Location?: true
    Area?: true
    Range?: true
    Adderess?: true
    Facillities?: true
    Amenities?: true
    Description?: true
    Video?: true
    GoogleMap?: true
    CreatedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyProjectCountAggregateInputType = {
    id?: true
    ProjectName?: true
    ProjectType?: true
    ProjectStatus?: true
    City?: true
    Location?: true
    Area?: true
    Range?: true
    Adderess?: true
    Facillities?: true
    Amenities?: true
    Description?: true
    Video?: true
    GoogleMap?: true
    CustomerImage?: true
    SitePlan?: true
    CreatedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyProject to aggregate.
     */
    where?: CompanyProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyProjects to fetch.
     */
    orderBy?: CompanyProjectOrderByWithRelationInput | CompanyProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyProjects
    **/
    _count?: true | CompanyProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyProjectMaxAggregateInputType
  }

  export type GetCompanyProjectAggregateType<T extends CompanyProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyProject[P]>
      : GetScalarType<T[P], AggregateCompanyProject[P]>
  }




  export type CompanyProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyProjectWhereInput
    orderBy?: CompanyProjectOrderByWithAggregationInput | CompanyProjectOrderByWithAggregationInput[]
    by: CompanyProjectScalarFieldEnum[] | CompanyProjectScalarFieldEnum
    having?: CompanyProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyProjectCountAggregateInputType | true
    _min?: CompanyProjectMinAggregateInputType
    _max?: CompanyProjectMaxAggregateInputType
  }

  export type CompanyProjectGroupByOutputType = {
    id: string
    ProjectName: string
    ProjectType: string | null
    ProjectStatus: string | null
    City: string | null
    Location: string | null
    Area: string | null
    Range: string | null
    Adderess: string | null
    Facillities: string | null
    Amenities: string | null
    Description: string | null
    Video: string | null
    GoogleMap: string | null
    CustomerImage: JsonValue | null
    SitePlan: JsonValue | null
    CreatedBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: CompanyProjectCountAggregateOutputType | null
    _min: CompanyProjectMinAggregateOutputType | null
    _max: CompanyProjectMaxAggregateOutputType | null
  }

  type GetCompanyProjectGroupByPayload<T extends CompanyProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyProjectGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyProjectGroupByOutputType[P]>
        }
      >
    >


  export type CompanyProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ProjectName?: boolean
    ProjectType?: boolean
    ProjectStatus?: boolean
    City?: boolean
    Location?: boolean
    Area?: boolean
    Range?: boolean
    Adderess?: boolean
    Facillities?: boolean
    Amenities?: boolean
    Description?: boolean
    Video?: boolean
    GoogleMap?: boolean
    CustomerImage?: boolean
    SitePlan?: boolean
    CreatedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["companyProject"]>



  export type CompanyProjectSelectScalar = {
    id?: boolean
    ProjectName?: boolean
    ProjectType?: boolean
    ProjectStatus?: boolean
    City?: boolean
    Location?: boolean
    Area?: boolean
    Range?: boolean
    Adderess?: boolean
    Facillities?: boolean
    Amenities?: boolean
    Description?: boolean
    Video?: boolean
    GoogleMap?: boolean
    CustomerImage?: boolean
    SitePlan?: boolean
    CreatedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompanyProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ProjectName" | "ProjectType" | "ProjectStatus" | "City" | "Location" | "Area" | "Range" | "Adderess" | "Facillities" | "Amenities" | "Description" | "Video" | "GoogleMap" | "CustomerImage" | "SitePlan" | "CreatedBy" | "createdAt" | "updatedAt", ExtArgs["result"]["companyProject"]>

  export type $CompanyProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyProject"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ProjectName: string
      ProjectType: string | null
      ProjectStatus: string | null
      City: string | null
      Location: string | null
      Area: string | null
      Range: string | null
      Adderess: string | null
      Facillities: string | null
      Amenities: string | null
      Description: string | null
      Video: string | null
      GoogleMap: string | null
      CustomerImage: Prisma.JsonValue | null
      SitePlan: Prisma.JsonValue | null
      CreatedBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["companyProject"]>
    composites: {}
  }

  type CompanyProjectGetPayload<S extends boolean | null | undefined | CompanyProjectDefaultArgs> = $Result.GetResult<Prisma.$CompanyProjectPayload, S>

  type CompanyProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyProjectCountAggregateInputType | true
    }

  export interface CompanyProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyProject'], meta: { name: 'CompanyProject' } }
    /**
     * Find zero or one CompanyProject that matches the filter.
     * @param {CompanyProjectFindUniqueArgs} args - Arguments to find a CompanyProject
     * @example
     * // Get one CompanyProject
     * const companyProject = await prisma.companyProject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyProjectFindUniqueArgs>(args: SelectSubset<T, CompanyProjectFindUniqueArgs<ExtArgs>>): Prisma__CompanyProjectClient<$Result.GetResult<Prisma.$CompanyProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompanyProject that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyProjectFindUniqueOrThrowArgs} args - Arguments to find a CompanyProject
     * @example
     * // Get one CompanyProject
     * const companyProject = await prisma.companyProject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyProjectClient<$Result.GetResult<Prisma.$CompanyProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyProject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyProjectFindFirstArgs} args - Arguments to find a CompanyProject
     * @example
     * // Get one CompanyProject
     * const companyProject = await prisma.companyProject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyProjectFindFirstArgs>(args?: SelectSubset<T, CompanyProjectFindFirstArgs<ExtArgs>>): Prisma__CompanyProjectClient<$Result.GetResult<Prisma.$CompanyProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyProject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyProjectFindFirstOrThrowArgs} args - Arguments to find a CompanyProject
     * @example
     * // Get one CompanyProject
     * const companyProject = await prisma.companyProject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyProjectClient<$Result.GetResult<Prisma.$CompanyProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompanyProjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyProjects
     * const companyProjects = await prisma.companyProject.findMany()
     * 
     * // Get first 10 CompanyProjects
     * const companyProjects = await prisma.companyProject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyProjectWithIdOnly = await prisma.companyProject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyProjectFindManyArgs>(args?: SelectSubset<T, CompanyProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompanyProject.
     * @param {CompanyProjectCreateArgs} args - Arguments to create a CompanyProject.
     * @example
     * // Create one CompanyProject
     * const CompanyProject = await prisma.companyProject.create({
     *   data: {
     *     // ... data to create a CompanyProject
     *   }
     * })
     * 
     */
    create<T extends CompanyProjectCreateArgs>(args: SelectSubset<T, CompanyProjectCreateArgs<ExtArgs>>): Prisma__CompanyProjectClient<$Result.GetResult<Prisma.$CompanyProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompanyProjects.
     * @param {CompanyProjectCreateManyArgs} args - Arguments to create many CompanyProjects.
     * @example
     * // Create many CompanyProjects
     * const companyProject = await prisma.companyProject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyProjectCreateManyArgs>(args?: SelectSubset<T, CompanyProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CompanyProject.
     * @param {CompanyProjectDeleteArgs} args - Arguments to delete one CompanyProject.
     * @example
     * // Delete one CompanyProject
     * const CompanyProject = await prisma.companyProject.delete({
     *   where: {
     *     // ... filter to delete one CompanyProject
     *   }
     * })
     * 
     */
    delete<T extends CompanyProjectDeleteArgs>(args: SelectSubset<T, CompanyProjectDeleteArgs<ExtArgs>>): Prisma__CompanyProjectClient<$Result.GetResult<Prisma.$CompanyProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompanyProject.
     * @param {CompanyProjectUpdateArgs} args - Arguments to update one CompanyProject.
     * @example
     * // Update one CompanyProject
     * const companyProject = await prisma.companyProject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyProjectUpdateArgs>(args: SelectSubset<T, CompanyProjectUpdateArgs<ExtArgs>>): Prisma__CompanyProjectClient<$Result.GetResult<Prisma.$CompanyProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompanyProjects.
     * @param {CompanyProjectDeleteManyArgs} args - Arguments to filter CompanyProjects to delete.
     * @example
     * // Delete a few CompanyProjects
     * const { count } = await prisma.companyProject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyProjectDeleteManyArgs>(args?: SelectSubset<T, CompanyProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyProjects
     * const companyProject = await prisma.companyProject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyProjectUpdateManyArgs>(args: SelectSubset<T, CompanyProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompanyProject.
     * @param {CompanyProjectUpsertArgs} args - Arguments to update or create a CompanyProject.
     * @example
     * // Update or create a CompanyProject
     * const companyProject = await prisma.companyProject.upsert({
     *   create: {
     *     // ... data to create a CompanyProject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyProject we want to update
     *   }
     * })
     */
    upsert<T extends CompanyProjectUpsertArgs>(args: SelectSubset<T, CompanyProjectUpsertArgs<ExtArgs>>): Prisma__CompanyProjectClient<$Result.GetResult<Prisma.$CompanyProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompanyProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyProjectCountArgs} args - Arguments to filter CompanyProjects to count.
     * @example
     * // Count the number of CompanyProjects
     * const count = await prisma.companyProject.count({
     *   where: {
     *     // ... the filter for the CompanyProjects we want to count
     *   }
     * })
    **/
    count<T extends CompanyProjectCountArgs>(
      args?: Subset<T, CompanyProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyProject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyProjectAggregateArgs>(args: Subset<T, CompanyProjectAggregateArgs>): Prisma.PrismaPromise<GetCompanyProjectAggregateType<T>>

    /**
     * Group by CompanyProject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyProjectGroupByArgs['orderBy'] }
        : { orderBy?: CompanyProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyProject model
   */
  readonly fields: CompanyProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyProject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyProject model
   */
  interface CompanyProjectFieldRefs {
    readonly id: FieldRef<"CompanyProject", 'String'>
    readonly ProjectName: FieldRef<"CompanyProject", 'String'>
    readonly ProjectType: FieldRef<"CompanyProject", 'String'>
    readonly ProjectStatus: FieldRef<"CompanyProject", 'String'>
    readonly City: FieldRef<"CompanyProject", 'String'>
    readonly Location: FieldRef<"CompanyProject", 'String'>
    readonly Area: FieldRef<"CompanyProject", 'String'>
    readonly Range: FieldRef<"CompanyProject", 'String'>
    readonly Adderess: FieldRef<"CompanyProject", 'String'>
    readonly Facillities: FieldRef<"CompanyProject", 'String'>
    readonly Amenities: FieldRef<"CompanyProject", 'String'>
    readonly Description: FieldRef<"CompanyProject", 'String'>
    readonly Video: FieldRef<"CompanyProject", 'String'>
    readonly GoogleMap: FieldRef<"CompanyProject", 'String'>
    readonly CustomerImage: FieldRef<"CompanyProject", 'Json'>
    readonly SitePlan: FieldRef<"CompanyProject", 'Json'>
    readonly CreatedBy: FieldRef<"CompanyProject", 'String'>
    readonly createdAt: FieldRef<"CompanyProject", 'DateTime'>
    readonly updatedAt: FieldRef<"CompanyProject", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanyProject findUnique
   */
  export type CompanyProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProject
     */
    select?: CompanyProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyProject
     */
    omit?: CompanyProjectOmit<ExtArgs> | null
    /**
     * Filter, which CompanyProject to fetch.
     */
    where: CompanyProjectWhereUniqueInput
  }

  /**
   * CompanyProject findUniqueOrThrow
   */
  export type CompanyProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProject
     */
    select?: CompanyProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyProject
     */
    omit?: CompanyProjectOmit<ExtArgs> | null
    /**
     * Filter, which CompanyProject to fetch.
     */
    where: CompanyProjectWhereUniqueInput
  }

  /**
   * CompanyProject findFirst
   */
  export type CompanyProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProject
     */
    select?: CompanyProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyProject
     */
    omit?: CompanyProjectOmit<ExtArgs> | null
    /**
     * Filter, which CompanyProject to fetch.
     */
    where?: CompanyProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyProjects to fetch.
     */
    orderBy?: CompanyProjectOrderByWithRelationInput | CompanyProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyProjects.
     */
    cursor?: CompanyProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyProjects.
     */
    distinct?: CompanyProjectScalarFieldEnum | CompanyProjectScalarFieldEnum[]
  }

  /**
   * CompanyProject findFirstOrThrow
   */
  export type CompanyProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProject
     */
    select?: CompanyProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyProject
     */
    omit?: CompanyProjectOmit<ExtArgs> | null
    /**
     * Filter, which CompanyProject to fetch.
     */
    where?: CompanyProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyProjects to fetch.
     */
    orderBy?: CompanyProjectOrderByWithRelationInput | CompanyProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyProjects.
     */
    cursor?: CompanyProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyProjects.
     */
    distinct?: CompanyProjectScalarFieldEnum | CompanyProjectScalarFieldEnum[]
  }

  /**
   * CompanyProject findMany
   */
  export type CompanyProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProject
     */
    select?: CompanyProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyProject
     */
    omit?: CompanyProjectOmit<ExtArgs> | null
    /**
     * Filter, which CompanyProjects to fetch.
     */
    where?: CompanyProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyProjects to fetch.
     */
    orderBy?: CompanyProjectOrderByWithRelationInput | CompanyProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyProjects.
     */
    cursor?: CompanyProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyProjects.
     */
    skip?: number
    distinct?: CompanyProjectScalarFieldEnum | CompanyProjectScalarFieldEnum[]
  }

  /**
   * CompanyProject create
   */
  export type CompanyProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProject
     */
    select?: CompanyProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyProject
     */
    omit?: CompanyProjectOmit<ExtArgs> | null
    /**
     * The data needed to create a CompanyProject.
     */
    data: XOR<CompanyProjectCreateInput, CompanyProjectUncheckedCreateInput>
  }

  /**
   * CompanyProject createMany
   */
  export type CompanyProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyProjects.
     */
    data: CompanyProjectCreateManyInput | CompanyProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanyProject update
   */
  export type CompanyProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProject
     */
    select?: CompanyProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyProject
     */
    omit?: CompanyProjectOmit<ExtArgs> | null
    /**
     * The data needed to update a CompanyProject.
     */
    data: XOR<CompanyProjectUpdateInput, CompanyProjectUncheckedUpdateInput>
    /**
     * Choose, which CompanyProject to update.
     */
    where: CompanyProjectWhereUniqueInput
  }

  /**
   * CompanyProject updateMany
   */
  export type CompanyProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyProjects.
     */
    data: XOR<CompanyProjectUpdateManyMutationInput, CompanyProjectUncheckedUpdateManyInput>
    /**
     * Filter which CompanyProjects to update
     */
    where?: CompanyProjectWhereInput
    /**
     * Limit how many CompanyProjects to update.
     */
    limit?: number
  }

  /**
   * CompanyProject upsert
   */
  export type CompanyProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProject
     */
    select?: CompanyProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyProject
     */
    omit?: CompanyProjectOmit<ExtArgs> | null
    /**
     * The filter to search for the CompanyProject to update in case it exists.
     */
    where: CompanyProjectWhereUniqueInput
    /**
     * In case the CompanyProject found by the `where` argument doesn't exist, create a new CompanyProject with this data.
     */
    create: XOR<CompanyProjectCreateInput, CompanyProjectUncheckedCreateInput>
    /**
     * In case the CompanyProject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyProjectUpdateInput, CompanyProjectUncheckedUpdateInput>
  }

  /**
   * CompanyProject delete
   */
  export type CompanyProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProject
     */
    select?: CompanyProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyProject
     */
    omit?: CompanyProjectOmit<ExtArgs> | null
    /**
     * Filter which CompanyProject to delete.
     */
    where: CompanyProjectWhereUniqueInput
  }

  /**
   * CompanyProject deleteMany
   */
  export type CompanyProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyProjects to delete
     */
    where?: CompanyProjectWhereInput
    /**
     * Limit how many CompanyProjects to delete.
     */
    limit?: number
  }

  /**
   * CompanyProject without action
   */
  export type CompanyProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyProject
     */
    select?: CompanyProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyProject
     */
    omit?: CompanyProjectOmit<ExtArgs> | null
  }


  /**
   * Model BuilderSlider
   */

  export type AggregateBuilderSlider = {
    _count: BuilderSliderCountAggregateOutputType | null
    _min: BuilderSliderMinAggregateOutputType | null
    _max: BuilderSliderMaxAggregateOutputType | null
  }

  export type BuilderSliderMinAggregateOutputType = {
    id: string | null
    Status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BuilderSliderMaxAggregateOutputType = {
    id: string | null
    Status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BuilderSliderCountAggregateOutputType = {
    id: number
    Image: number
    Status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BuilderSliderMinAggregateInputType = {
    id?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BuilderSliderMaxAggregateInputType = {
    id?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BuilderSliderCountAggregateInputType = {
    id?: true
    Image?: true
    Status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BuilderSliderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuilderSlider to aggregate.
     */
    where?: BuilderSliderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuilderSliders to fetch.
     */
    orderBy?: BuilderSliderOrderByWithRelationInput | BuilderSliderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BuilderSliderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuilderSliders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuilderSliders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BuilderSliders
    **/
    _count?: true | BuilderSliderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuilderSliderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuilderSliderMaxAggregateInputType
  }

  export type GetBuilderSliderAggregateType<T extends BuilderSliderAggregateArgs> = {
        [P in keyof T & keyof AggregateBuilderSlider]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuilderSlider[P]>
      : GetScalarType<T[P], AggregateBuilderSlider[P]>
  }




  export type BuilderSliderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuilderSliderWhereInput
    orderBy?: BuilderSliderOrderByWithAggregationInput | BuilderSliderOrderByWithAggregationInput[]
    by: BuilderSliderScalarFieldEnum[] | BuilderSliderScalarFieldEnum
    having?: BuilderSliderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuilderSliderCountAggregateInputType | true
    _min?: BuilderSliderMinAggregateInputType
    _max?: BuilderSliderMaxAggregateInputType
  }

  export type BuilderSliderGroupByOutputType = {
    id: string
    Image: JsonValue | null
    Status: string
    createdAt: Date
    updatedAt: Date
    _count: BuilderSliderCountAggregateOutputType | null
    _min: BuilderSliderMinAggregateOutputType | null
    _max: BuilderSliderMaxAggregateOutputType | null
  }

  type GetBuilderSliderGroupByPayload<T extends BuilderSliderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuilderSliderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuilderSliderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuilderSliderGroupByOutputType[P]>
            : GetScalarType<T[P], BuilderSliderGroupByOutputType[P]>
        }
      >
    >


  export type BuilderSliderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Image?: boolean
    Status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["builderSlider"]>



  export type BuilderSliderSelectScalar = {
    id?: boolean
    Image?: boolean
    Status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BuilderSliderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "Image" | "Status" | "createdAt" | "updatedAt", ExtArgs["result"]["builderSlider"]>

  export type $BuilderSliderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BuilderSlider"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      Image: Prisma.JsonValue | null
      Status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["builderSlider"]>
    composites: {}
  }

  type BuilderSliderGetPayload<S extends boolean | null | undefined | BuilderSliderDefaultArgs> = $Result.GetResult<Prisma.$BuilderSliderPayload, S>

  type BuilderSliderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BuilderSliderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BuilderSliderCountAggregateInputType | true
    }

  export interface BuilderSliderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BuilderSlider'], meta: { name: 'BuilderSlider' } }
    /**
     * Find zero or one BuilderSlider that matches the filter.
     * @param {BuilderSliderFindUniqueArgs} args - Arguments to find a BuilderSlider
     * @example
     * // Get one BuilderSlider
     * const builderSlider = await prisma.builderSlider.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BuilderSliderFindUniqueArgs>(args: SelectSubset<T, BuilderSliderFindUniqueArgs<ExtArgs>>): Prisma__BuilderSliderClient<$Result.GetResult<Prisma.$BuilderSliderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BuilderSlider that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BuilderSliderFindUniqueOrThrowArgs} args - Arguments to find a BuilderSlider
     * @example
     * // Get one BuilderSlider
     * const builderSlider = await prisma.builderSlider.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BuilderSliderFindUniqueOrThrowArgs>(args: SelectSubset<T, BuilderSliderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BuilderSliderClient<$Result.GetResult<Prisma.$BuilderSliderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BuilderSlider that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuilderSliderFindFirstArgs} args - Arguments to find a BuilderSlider
     * @example
     * // Get one BuilderSlider
     * const builderSlider = await prisma.builderSlider.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BuilderSliderFindFirstArgs>(args?: SelectSubset<T, BuilderSliderFindFirstArgs<ExtArgs>>): Prisma__BuilderSliderClient<$Result.GetResult<Prisma.$BuilderSliderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BuilderSlider that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuilderSliderFindFirstOrThrowArgs} args - Arguments to find a BuilderSlider
     * @example
     * // Get one BuilderSlider
     * const builderSlider = await prisma.builderSlider.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BuilderSliderFindFirstOrThrowArgs>(args?: SelectSubset<T, BuilderSliderFindFirstOrThrowArgs<ExtArgs>>): Prisma__BuilderSliderClient<$Result.GetResult<Prisma.$BuilderSliderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BuilderSliders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuilderSliderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BuilderSliders
     * const builderSliders = await prisma.builderSlider.findMany()
     * 
     * // Get first 10 BuilderSliders
     * const builderSliders = await prisma.builderSlider.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const builderSliderWithIdOnly = await prisma.builderSlider.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BuilderSliderFindManyArgs>(args?: SelectSubset<T, BuilderSliderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuilderSliderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BuilderSlider.
     * @param {BuilderSliderCreateArgs} args - Arguments to create a BuilderSlider.
     * @example
     * // Create one BuilderSlider
     * const BuilderSlider = await prisma.builderSlider.create({
     *   data: {
     *     // ... data to create a BuilderSlider
     *   }
     * })
     * 
     */
    create<T extends BuilderSliderCreateArgs>(args: SelectSubset<T, BuilderSliderCreateArgs<ExtArgs>>): Prisma__BuilderSliderClient<$Result.GetResult<Prisma.$BuilderSliderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BuilderSliders.
     * @param {BuilderSliderCreateManyArgs} args - Arguments to create many BuilderSliders.
     * @example
     * // Create many BuilderSliders
     * const builderSlider = await prisma.builderSlider.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BuilderSliderCreateManyArgs>(args?: SelectSubset<T, BuilderSliderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BuilderSlider.
     * @param {BuilderSliderDeleteArgs} args - Arguments to delete one BuilderSlider.
     * @example
     * // Delete one BuilderSlider
     * const BuilderSlider = await prisma.builderSlider.delete({
     *   where: {
     *     // ... filter to delete one BuilderSlider
     *   }
     * })
     * 
     */
    delete<T extends BuilderSliderDeleteArgs>(args: SelectSubset<T, BuilderSliderDeleteArgs<ExtArgs>>): Prisma__BuilderSliderClient<$Result.GetResult<Prisma.$BuilderSliderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BuilderSlider.
     * @param {BuilderSliderUpdateArgs} args - Arguments to update one BuilderSlider.
     * @example
     * // Update one BuilderSlider
     * const builderSlider = await prisma.builderSlider.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BuilderSliderUpdateArgs>(args: SelectSubset<T, BuilderSliderUpdateArgs<ExtArgs>>): Prisma__BuilderSliderClient<$Result.GetResult<Prisma.$BuilderSliderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BuilderSliders.
     * @param {BuilderSliderDeleteManyArgs} args - Arguments to filter BuilderSliders to delete.
     * @example
     * // Delete a few BuilderSliders
     * const { count } = await prisma.builderSlider.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BuilderSliderDeleteManyArgs>(args?: SelectSubset<T, BuilderSliderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BuilderSliders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuilderSliderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BuilderSliders
     * const builderSlider = await prisma.builderSlider.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BuilderSliderUpdateManyArgs>(args: SelectSubset<T, BuilderSliderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BuilderSlider.
     * @param {BuilderSliderUpsertArgs} args - Arguments to update or create a BuilderSlider.
     * @example
     * // Update or create a BuilderSlider
     * const builderSlider = await prisma.builderSlider.upsert({
     *   create: {
     *     // ... data to create a BuilderSlider
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BuilderSlider we want to update
     *   }
     * })
     */
    upsert<T extends BuilderSliderUpsertArgs>(args: SelectSubset<T, BuilderSliderUpsertArgs<ExtArgs>>): Prisma__BuilderSliderClient<$Result.GetResult<Prisma.$BuilderSliderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BuilderSliders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuilderSliderCountArgs} args - Arguments to filter BuilderSliders to count.
     * @example
     * // Count the number of BuilderSliders
     * const count = await prisma.builderSlider.count({
     *   where: {
     *     // ... the filter for the BuilderSliders we want to count
     *   }
     * })
    **/
    count<T extends BuilderSliderCountArgs>(
      args?: Subset<T, BuilderSliderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuilderSliderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BuilderSlider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuilderSliderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuilderSliderAggregateArgs>(args: Subset<T, BuilderSliderAggregateArgs>): Prisma.PrismaPromise<GetBuilderSliderAggregateType<T>>

    /**
     * Group by BuilderSlider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuilderSliderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuilderSliderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuilderSliderGroupByArgs['orderBy'] }
        : { orderBy?: BuilderSliderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuilderSliderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuilderSliderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BuilderSlider model
   */
  readonly fields: BuilderSliderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BuilderSlider.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BuilderSliderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BuilderSlider model
   */
  interface BuilderSliderFieldRefs {
    readonly id: FieldRef<"BuilderSlider", 'String'>
    readonly Image: FieldRef<"BuilderSlider", 'Json'>
    readonly Status: FieldRef<"BuilderSlider", 'String'>
    readonly createdAt: FieldRef<"BuilderSlider", 'DateTime'>
    readonly updatedAt: FieldRef<"BuilderSlider", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BuilderSlider findUnique
   */
  export type BuilderSliderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuilderSlider
     */
    select?: BuilderSliderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuilderSlider
     */
    omit?: BuilderSliderOmit<ExtArgs> | null
    /**
     * Filter, which BuilderSlider to fetch.
     */
    where: BuilderSliderWhereUniqueInput
  }

  /**
   * BuilderSlider findUniqueOrThrow
   */
  export type BuilderSliderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuilderSlider
     */
    select?: BuilderSliderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuilderSlider
     */
    omit?: BuilderSliderOmit<ExtArgs> | null
    /**
     * Filter, which BuilderSlider to fetch.
     */
    where: BuilderSliderWhereUniqueInput
  }

  /**
   * BuilderSlider findFirst
   */
  export type BuilderSliderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuilderSlider
     */
    select?: BuilderSliderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuilderSlider
     */
    omit?: BuilderSliderOmit<ExtArgs> | null
    /**
     * Filter, which BuilderSlider to fetch.
     */
    where?: BuilderSliderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuilderSliders to fetch.
     */
    orderBy?: BuilderSliderOrderByWithRelationInput | BuilderSliderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuilderSliders.
     */
    cursor?: BuilderSliderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuilderSliders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuilderSliders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuilderSliders.
     */
    distinct?: BuilderSliderScalarFieldEnum | BuilderSliderScalarFieldEnum[]
  }

  /**
   * BuilderSlider findFirstOrThrow
   */
  export type BuilderSliderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuilderSlider
     */
    select?: BuilderSliderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuilderSlider
     */
    omit?: BuilderSliderOmit<ExtArgs> | null
    /**
     * Filter, which BuilderSlider to fetch.
     */
    where?: BuilderSliderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuilderSliders to fetch.
     */
    orderBy?: BuilderSliderOrderByWithRelationInput | BuilderSliderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuilderSliders.
     */
    cursor?: BuilderSliderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuilderSliders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuilderSliders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuilderSliders.
     */
    distinct?: BuilderSliderScalarFieldEnum | BuilderSliderScalarFieldEnum[]
  }

  /**
   * BuilderSlider findMany
   */
  export type BuilderSliderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuilderSlider
     */
    select?: BuilderSliderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuilderSlider
     */
    omit?: BuilderSliderOmit<ExtArgs> | null
    /**
     * Filter, which BuilderSliders to fetch.
     */
    where?: BuilderSliderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuilderSliders to fetch.
     */
    orderBy?: BuilderSliderOrderByWithRelationInput | BuilderSliderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BuilderSliders.
     */
    cursor?: BuilderSliderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuilderSliders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuilderSliders.
     */
    skip?: number
    distinct?: BuilderSliderScalarFieldEnum | BuilderSliderScalarFieldEnum[]
  }

  /**
   * BuilderSlider create
   */
  export type BuilderSliderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuilderSlider
     */
    select?: BuilderSliderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuilderSlider
     */
    omit?: BuilderSliderOmit<ExtArgs> | null
    /**
     * The data needed to create a BuilderSlider.
     */
    data: XOR<BuilderSliderCreateInput, BuilderSliderUncheckedCreateInput>
  }

  /**
   * BuilderSlider createMany
   */
  export type BuilderSliderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BuilderSliders.
     */
    data: BuilderSliderCreateManyInput | BuilderSliderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BuilderSlider update
   */
  export type BuilderSliderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuilderSlider
     */
    select?: BuilderSliderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuilderSlider
     */
    omit?: BuilderSliderOmit<ExtArgs> | null
    /**
     * The data needed to update a BuilderSlider.
     */
    data: XOR<BuilderSliderUpdateInput, BuilderSliderUncheckedUpdateInput>
    /**
     * Choose, which BuilderSlider to update.
     */
    where: BuilderSliderWhereUniqueInput
  }

  /**
   * BuilderSlider updateMany
   */
  export type BuilderSliderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BuilderSliders.
     */
    data: XOR<BuilderSliderUpdateManyMutationInput, BuilderSliderUncheckedUpdateManyInput>
    /**
     * Filter which BuilderSliders to update
     */
    where?: BuilderSliderWhereInput
    /**
     * Limit how many BuilderSliders to update.
     */
    limit?: number
  }

  /**
   * BuilderSlider upsert
   */
  export type BuilderSliderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuilderSlider
     */
    select?: BuilderSliderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuilderSlider
     */
    omit?: BuilderSliderOmit<ExtArgs> | null
    /**
     * The filter to search for the BuilderSlider to update in case it exists.
     */
    where: BuilderSliderWhereUniqueInput
    /**
     * In case the BuilderSlider found by the `where` argument doesn't exist, create a new BuilderSlider with this data.
     */
    create: XOR<BuilderSliderCreateInput, BuilderSliderUncheckedCreateInput>
    /**
     * In case the BuilderSlider was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BuilderSliderUpdateInput, BuilderSliderUncheckedUpdateInput>
  }

  /**
   * BuilderSlider delete
   */
  export type BuilderSliderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuilderSlider
     */
    select?: BuilderSliderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuilderSlider
     */
    omit?: BuilderSliderOmit<ExtArgs> | null
    /**
     * Filter which BuilderSlider to delete.
     */
    where: BuilderSliderWhereUniqueInput
  }

  /**
   * BuilderSlider deleteMany
   */
  export type BuilderSliderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuilderSliders to delete
     */
    where?: BuilderSliderWhereInput
    /**
     * Limit how many BuilderSliders to delete.
     */
    limit?: number
  }

  /**
   * BuilderSlider without action
   */
  export type BuilderSliderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuilderSlider
     */
    select?: BuilderSliderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuilderSlider
     */
    omit?: BuilderSliderOmit<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    Campaign: string | null
    CustomerType: string | null
    CustomerSubType: string | null
    customerName: string | null
    ContactNumber: string | null
    City: string | null
    Location: string | null
    Area: string | null
    Adderess: string | null
    Email: string | null
    Facillities: string | null
    ReferenceId: string | null
    CustomerId: string | null
    CustomerDate: string | null
    CustomerYear: string | null
    Other: string | null
    Description: string | null
    Video: string | null
    Verified: string | null
    GoogleMap: string | null
    isFavourite: boolean | null
    AssignToId: string | null
    CreatedById: string | null
    isImported: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    Campaign: string | null
    CustomerType: string | null
    CustomerSubType: string | null
    customerName: string | null
    ContactNumber: string | null
    City: string | null
    Location: string | null
    Area: string | null
    Adderess: string | null
    Email: string | null
    Facillities: string | null
    ReferenceId: string | null
    CustomerId: string | null
    CustomerDate: string | null
    CustomerYear: string | null
    Other: string | null
    Description: string | null
    Video: string | null
    Verified: string | null
    GoogleMap: string | null
    isFavourite: boolean | null
    AssignToId: string | null
    CreatedById: string | null
    isImported: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    Campaign: number
    CustomerType: number
    CustomerSubType: number
    customerName: number
    ContactNumber: number
    City: number
    Location: number
    Area: number
    Adderess: number
    Email: number
    Facillities: number
    ReferenceId: number
    CustomerId: number
    CustomerDate: number
    CustomerYear: number
    Other: number
    Description: number
    Video: number
    Verified: number
    GoogleMap: number
    CustomerImage: number
    SitePlan: number
    isFavourite: number
    AssignToId: number
    CreatedById: number
    isImported: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerMinAggregateInputType = {
    id?: true
    Campaign?: true
    CustomerType?: true
    CustomerSubType?: true
    customerName?: true
    ContactNumber?: true
    City?: true
    Location?: true
    Area?: true
    Adderess?: true
    Email?: true
    Facillities?: true
    ReferenceId?: true
    CustomerId?: true
    CustomerDate?: true
    CustomerYear?: true
    Other?: true
    Description?: true
    Video?: true
    Verified?: true
    GoogleMap?: true
    isFavourite?: true
    AssignToId?: true
    CreatedById?: true
    isImported?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    Campaign?: true
    CustomerType?: true
    CustomerSubType?: true
    customerName?: true
    ContactNumber?: true
    City?: true
    Location?: true
    Area?: true
    Adderess?: true
    Email?: true
    Facillities?: true
    ReferenceId?: true
    CustomerId?: true
    CustomerDate?: true
    CustomerYear?: true
    Other?: true
    Description?: true
    Video?: true
    Verified?: true
    GoogleMap?: true
    isFavourite?: true
    AssignToId?: true
    CreatedById?: true
    isImported?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    Campaign?: true
    CustomerType?: true
    CustomerSubType?: true
    customerName?: true
    ContactNumber?: true
    City?: true
    Location?: true
    Area?: true
    Adderess?: true
    Email?: true
    Facillities?: true
    ReferenceId?: true
    CustomerId?: true
    CustomerDate?: true
    CustomerYear?: true
    Other?: true
    Description?: true
    Video?: true
    Verified?: true
    GoogleMap?: true
    CustomerImage?: true
    SitePlan?: true
    isFavourite?: true
    AssignToId?: true
    CreatedById?: true
    isImported?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    Campaign: string | null
    CustomerType: string | null
    CustomerSubType: string | null
    customerName: string
    ContactNumber: string
    City: string | null
    Location: string | null
    Area: string | null
    Adderess: string | null
    Email: string | null
    Facillities: string | null
    ReferenceId: string | null
    CustomerId: string | null
    CustomerDate: string | null
    CustomerYear: string | null
    Other: string | null
    Description: string | null
    Video: string | null
    Verified: string | null
    GoogleMap: string | null
    CustomerImage: JsonValue | null
    SitePlan: JsonValue | null
    isFavourite: boolean
    AssignToId: string | null
    CreatedById: string | null
    isImported: boolean
    createdAt: Date
    updatedAt: Date
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Campaign?: boolean
    CustomerType?: boolean
    CustomerSubType?: boolean
    customerName?: boolean
    ContactNumber?: boolean
    City?: boolean
    Location?: boolean
    Area?: boolean
    Adderess?: boolean
    Email?: boolean
    Facillities?: boolean
    ReferenceId?: boolean
    CustomerId?: boolean
    CustomerDate?: boolean
    CustomerYear?: boolean
    Other?: boolean
    Description?: boolean
    Video?: boolean
    Verified?: boolean
    GoogleMap?: boolean
    CustomerImage?: boolean
    SitePlan?: boolean
    isFavourite?: boolean
    AssignToId?: boolean
    CreatedById?: boolean
    isImported?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    AssignTo?: boolean | Customer$AssignToArgs<ExtArgs>
    CreatedBy?: boolean | Customer$CreatedByArgs<ExtArgs>
    followups?: boolean | Customer$followupsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>



  export type CustomerSelectScalar = {
    id?: boolean
    Campaign?: boolean
    CustomerType?: boolean
    CustomerSubType?: boolean
    customerName?: boolean
    ContactNumber?: boolean
    City?: boolean
    Location?: boolean
    Area?: boolean
    Adderess?: boolean
    Email?: boolean
    Facillities?: boolean
    ReferenceId?: boolean
    CustomerId?: boolean
    CustomerDate?: boolean
    CustomerYear?: boolean
    Other?: boolean
    Description?: boolean
    Video?: boolean
    Verified?: boolean
    GoogleMap?: boolean
    CustomerImage?: boolean
    SitePlan?: boolean
    isFavourite?: boolean
    AssignToId?: boolean
    CreatedById?: boolean
    isImported?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "Campaign" | "CustomerType" | "CustomerSubType" | "customerName" | "ContactNumber" | "City" | "Location" | "Area" | "Adderess" | "Email" | "Facillities" | "ReferenceId" | "CustomerId" | "CustomerDate" | "CustomerYear" | "Other" | "Description" | "Video" | "Verified" | "GoogleMap" | "CustomerImage" | "SitePlan" | "isFavourite" | "AssignToId" | "CreatedById" | "isImported" | "createdAt" | "updatedAt", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AssignTo?: boolean | Customer$AssignToArgs<ExtArgs>
    CreatedBy?: boolean | Customer$CreatedByArgs<ExtArgs>
    followups?: boolean | Customer$followupsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      AssignTo: Prisma.$AdminPayload<ExtArgs> | null
      CreatedBy: Prisma.$AdminPayload<ExtArgs> | null
      followups: Prisma.$FollowupPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      Campaign: string | null
      CustomerType: string | null
      CustomerSubType: string | null
      customerName: string
      ContactNumber: string
      City: string | null
      Location: string | null
      Area: string | null
      Adderess: string | null
      Email: string | null
      Facillities: string | null
      ReferenceId: string | null
      CustomerId: string | null
      CustomerDate: string | null
      CustomerYear: string | null
      Other: string | null
      Description: string | null
      Video: string | null
      Verified: string | null
      GoogleMap: string | null
      CustomerImage: Prisma.JsonValue | null
      SitePlan: Prisma.JsonValue | null
      isFavourite: boolean
      AssignToId: string | null
      CreatedById: string | null
      isImported: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AssignTo<T extends Customer$AssignToArgs<ExtArgs> = {}>(args?: Subset<T, Customer$AssignToArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    CreatedBy<T extends Customer$CreatedByArgs<ExtArgs> = {}>(args?: Subset<T, Customer$CreatedByArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    followups<T extends Customer$followupsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$followupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly Campaign: FieldRef<"Customer", 'String'>
    readonly CustomerType: FieldRef<"Customer", 'String'>
    readonly CustomerSubType: FieldRef<"Customer", 'String'>
    readonly customerName: FieldRef<"Customer", 'String'>
    readonly ContactNumber: FieldRef<"Customer", 'String'>
    readonly City: FieldRef<"Customer", 'String'>
    readonly Location: FieldRef<"Customer", 'String'>
    readonly Area: FieldRef<"Customer", 'String'>
    readonly Adderess: FieldRef<"Customer", 'String'>
    readonly Email: FieldRef<"Customer", 'String'>
    readonly Facillities: FieldRef<"Customer", 'String'>
    readonly ReferenceId: FieldRef<"Customer", 'String'>
    readonly CustomerId: FieldRef<"Customer", 'String'>
    readonly CustomerDate: FieldRef<"Customer", 'String'>
    readonly CustomerYear: FieldRef<"Customer", 'String'>
    readonly Other: FieldRef<"Customer", 'String'>
    readonly Description: FieldRef<"Customer", 'String'>
    readonly Video: FieldRef<"Customer", 'String'>
    readonly Verified: FieldRef<"Customer", 'String'>
    readonly GoogleMap: FieldRef<"Customer", 'String'>
    readonly CustomerImage: FieldRef<"Customer", 'Json'>
    readonly SitePlan: FieldRef<"Customer", 'Json'>
    readonly isFavourite: FieldRef<"Customer", 'Boolean'>
    readonly AssignToId: FieldRef<"Customer", 'String'>
    readonly CreatedById: FieldRef<"Customer", 'String'>
    readonly isImported: FieldRef<"Customer", 'Boolean'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.AssignTo
   */
  export type Customer$AssignToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * Customer.CreatedBy
   */
  export type Customer$CreatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * Customer.followups
   */
  export type Customer$followupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Followup
     */
    select?: FollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Followup
     */
    omit?: FollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowupInclude<ExtArgs> | null
    where?: FollowupWhereInput
    orderBy?: FollowupOrderByWithRelationInput | FollowupOrderByWithRelationInput[]
    cursor?: FollowupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowupScalarFieldEnum | FollowupScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model Followup
   */

  export type AggregateFollowup = {
    _count: FollowupCountAggregateOutputType | null
    _min: FollowupMinAggregateOutputType | null
    _max: FollowupMaxAggregateOutputType | null
  }

  export type FollowupMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    StartDate: string | null
    StatusType: string | null
    FollowupNextDate: string | null
    Description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    contactId: string | null
  }

  export type FollowupMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    StartDate: string | null
    StatusType: string | null
    FollowupNextDate: string | null
    Description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    contactId: string | null
  }

  export type FollowupCountAggregateOutputType = {
    id: number
    customerId: number
    StartDate: number
    StatusType: number
    FollowupNextDate: number
    Description: number
    createdAt: number
    updatedAt: number
    contactId: number
    _all: number
  }


  export type FollowupMinAggregateInputType = {
    id?: true
    customerId?: true
    StartDate?: true
    StatusType?: true
    FollowupNextDate?: true
    Description?: true
    createdAt?: true
    updatedAt?: true
    contactId?: true
  }

  export type FollowupMaxAggregateInputType = {
    id?: true
    customerId?: true
    StartDate?: true
    StatusType?: true
    FollowupNextDate?: true
    Description?: true
    createdAt?: true
    updatedAt?: true
    contactId?: true
  }

  export type FollowupCountAggregateInputType = {
    id?: true
    customerId?: true
    StartDate?: true
    StatusType?: true
    FollowupNextDate?: true
    Description?: true
    createdAt?: true
    updatedAt?: true
    contactId?: true
    _all?: true
  }

  export type FollowupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Followup to aggregate.
     */
    where?: FollowupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Followups to fetch.
     */
    orderBy?: FollowupOrderByWithRelationInput | FollowupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FollowupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Followups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Followups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Followups
    **/
    _count?: true | FollowupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FollowupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FollowupMaxAggregateInputType
  }

  export type GetFollowupAggregateType<T extends FollowupAggregateArgs> = {
        [P in keyof T & keyof AggregateFollowup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFollowup[P]>
      : GetScalarType<T[P], AggregateFollowup[P]>
  }




  export type FollowupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowupWhereInput
    orderBy?: FollowupOrderByWithAggregationInput | FollowupOrderByWithAggregationInput[]
    by: FollowupScalarFieldEnum[] | FollowupScalarFieldEnum
    having?: FollowupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FollowupCountAggregateInputType | true
    _min?: FollowupMinAggregateInputType
    _max?: FollowupMaxAggregateInputType
  }

  export type FollowupGroupByOutputType = {
    id: string
    customerId: string
    StartDate: string | null
    StatusType: string | null
    FollowupNextDate: string | null
    Description: string | null
    createdAt: Date
    updatedAt: Date
    contactId: string | null
    _count: FollowupCountAggregateOutputType | null
    _min: FollowupMinAggregateOutputType | null
    _max: FollowupMaxAggregateOutputType | null
  }

  type GetFollowupGroupByPayload<T extends FollowupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FollowupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FollowupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FollowupGroupByOutputType[P]>
            : GetScalarType<T[P], FollowupGroupByOutputType[P]>
        }
      >
    >


  export type FollowupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    StartDate?: boolean
    StatusType?: boolean
    FollowupNextDate?: boolean
    Description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contactId?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    contact?: boolean | Followup$contactArgs<ExtArgs>
  }, ExtArgs["result"]["followup"]>



  export type FollowupSelectScalar = {
    id?: boolean
    customerId?: boolean
    StartDate?: boolean
    StatusType?: boolean
    FollowupNextDate?: boolean
    Description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contactId?: boolean
  }

  export type FollowupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "StartDate" | "StatusType" | "FollowupNextDate" | "Description" | "createdAt" | "updatedAt" | "contactId", ExtArgs["result"]["followup"]>
  export type FollowupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    contact?: boolean | Followup$contactArgs<ExtArgs>
  }

  export type $FollowupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Followup"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      contact: Prisma.$ContactPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      StartDate: string | null
      StatusType: string | null
      FollowupNextDate: string | null
      Description: string | null
      createdAt: Date
      updatedAt: Date
      contactId: string | null
    }, ExtArgs["result"]["followup"]>
    composites: {}
  }

  type FollowupGetPayload<S extends boolean | null | undefined | FollowupDefaultArgs> = $Result.GetResult<Prisma.$FollowupPayload, S>

  type FollowupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FollowupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FollowupCountAggregateInputType | true
    }

  export interface FollowupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Followup'], meta: { name: 'Followup' } }
    /**
     * Find zero or one Followup that matches the filter.
     * @param {FollowupFindUniqueArgs} args - Arguments to find a Followup
     * @example
     * // Get one Followup
     * const followup = await prisma.followup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FollowupFindUniqueArgs>(args: SelectSubset<T, FollowupFindUniqueArgs<ExtArgs>>): Prisma__FollowupClient<$Result.GetResult<Prisma.$FollowupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Followup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FollowupFindUniqueOrThrowArgs} args - Arguments to find a Followup
     * @example
     * // Get one Followup
     * const followup = await prisma.followup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FollowupFindUniqueOrThrowArgs>(args: SelectSubset<T, FollowupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FollowupClient<$Result.GetResult<Prisma.$FollowupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Followup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowupFindFirstArgs} args - Arguments to find a Followup
     * @example
     * // Get one Followup
     * const followup = await prisma.followup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FollowupFindFirstArgs>(args?: SelectSubset<T, FollowupFindFirstArgs<ExtArgs>>): Prisma__FollowupClient<$Result.GetResult<Prisma.$FollowupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Followup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowupFindFirstOrThrowArgs} args - Arguments to find a Followup
     * @example
     * // Get one Followup
     * const followup = await prisma.followup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FollowupFindFirstOrThrowArgs>(args?: SelectSubset<T, FollowupFindFirstOrThrowArgs<ExtArgs>>): Prisma__FollowupClient<$Result.GetResult<Prisma.$FollowupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Followups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Followups
     * const followups = await prisma.followup.findMany()
     * 
     * // Get first 10 Followups
     * const followups = await prisma.followup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const followupWithIdOnly = await prisma.followup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FollowupFindManyArgs>(args?: SelectSubset<T, FollowupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Followup.
     * @param {FollowupCreateArgs} args - Arguments to create a Followup.
     * @example
     * // Create one Followup
     * const Followup = await prisma.followup.create({
     *   data: {
     *     // ... data to create a Followup
     *   }
     * })
     * 
     */
    create<T extends FollowupCreateArgs>(args: SelectSubset<T, FollowupCreateArgs<ExtArgs>>): Prisma__FollowupClient<$Result.GetResult<Prisma.$FollowupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Followups.
     * @param {FollowupCreateManyArgs} args - Arguments to create many Followups.
     * @example
     * // Create many Followups
     * const followup = await prisma.followup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FollowupCreateManyArgs>(args?: SelectSubset<T, FollowupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Followup.
     * @param {FollowupDeleteArgs} args - Arguments to delete one Followup.
     * @example
     * // Delete one Followup
     * const Followup = await prisma.followup.delete({
     *   where: {
     *     // ... filter to delete one Followup
     *   }
     * })
     * 
     */
    delete<T extends FollowupDeleteArgs>(args: SelectSubset<T, FollowupDeleteArgs<ExtArgs>>): Prisma__FollowupClient<$Result.GetResult<Prisma.$FollowupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Followup.
     * @param {FollowupUpdateArgs} args - Arguments to update one Followup.
     * @example
     * // Update one Followup
     * const followup = await prisma.followup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FollowupUpdateArgs>(args: SelectSubset<T, FollowupUpdateArgs<ExtArgs>>): Prisma__FollowupClient<$Result.GetResult<Prisma.$FollowupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Followups.
     * @param {FollowupDeleteManyArgs} args - Arguments to filter Followups to delete.
     * @example
     * // Delete a few Followups
     * const { count } = await prisma.followup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FollowupDeleteManyArgs>(args?: SelectSubset<T, FollowupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Followups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Followups
     * const followup = await prisma.followup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FollowupUpdateManyArgs>(args: SelectSubset<T, FollowupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Followup.
     * @param {FollowupUpsertArgs} args - Arguments to update or create a Followup.
     * @example
     * // Update or create a Followup
     * const followup = await prisma.followup.upsert({
     *   create: {
     *     // ... data to create a Followup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Followup we want to update
     *   }
     * })
     */
    upsert<T extends FollowupUpsertArgs>(args: SelectSubset<T, FollowupUpsertArgs<ExtArgs>>): Prisma__FollowupClient<$Result.GetResult<Prisma.$FollowupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Followups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowupCountArgs} args - Arguments to filter Followups to count.
     * @example
     * // Count the number of Followups
     * const count = await prisma.followup.count({
     *   where: {
     *     // ... the filter for the Followups we want to count
     *   }
     * })
    **/
    count<T extends FollowupCountArgs>(
      args?: Subset<T, FollowupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FollowupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Followup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FollowupAggregateArgs>(args: Subset<T, FollowupAggregateArgs>): Prisma.PrismaPromise<GetFollowupAggregateType<T>>

    /**
     * Group by Followup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FollowupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FollowupGroupByArgs['orderBy'] }
        : { orderBy?: FollowupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FollowupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFollowupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Followup model
   */
  readonly fields: FollowupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Followup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FollowupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contact<T extends Followup$contactArgs<ExtArgs> = {}>(args?: Subset<T, Followup$contactArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Followup model
   */
  interface FollowupFieldRefs {
    readonly id: FieldRef<"Followup", 'String'>
    readonly customerId: FieldRef<"Followup", 'String'>
    readonly StartDate: FieldRef<"Followup", 'String'>
    readonly StatusType: FieldRef<"Followup", 'String'>
    readonly FollowupNextDate: FieldRef<"Followup", 'String'>
    readonly Description: FieldRef<"Followup", 'String'>
    readonly createdAt: FieldRef<"Followup", 'DateTime'>
    readonly updatedAt: FieldRef<"Followup", 'DateTime'>
    readonly contactId: FieldRef<"Followup", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Followup findUnique
   */
  export type FollowupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Followup
     */
    select?: FollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Followup
     */
    omit?: FollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowupInclude<ExtArgs> | null
    /**
     * Filter, which Followup to fetch.
     */
    where: FollowupWhereUniqueInput
  }

  /**
   * Followup findUniqueOrThrow
   */
  export type FollowupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Followup
     */
    select?: FollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Followup
     */
    omit?: FollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowupInclude<ExtArgs> | null
    /**
     * Filter, which Followup to fetch.
     */
    where: FollowupWhereUniqueInput
  }

  /**
   * Followup findFirst
   */
  export type FollowupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Followup
     */
    select?: FollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Followup
     */
    omit?: FollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowupInclude<ExtArgs> | null
    /**
     * Filter, which Followup to fetch.
     */
    where?: FollowupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Followups to fetch.
     */
    orderBy?: FollowupOrderByWithRelationInput | FollowupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Followups.
     */
    cursor?: FollowupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Followups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Followups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Followups.
     */
    distinct?: FollowupScalarFieldEnum | FollowupScalarFieldEnum[]
  }

  /**
   * Followup findFirstOrThrow
   */
  export type FollowupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Followup
     */
    select?: FollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Followup
     */
    omit?: FollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowupInclude<ExtArgs> | null
    /**
     * Filter, which Followup to fetch.
     */
    where?: FollowupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Followups to fetch.
     */
    orderBy?: FollowupOrderByWithRelationInput | FollowupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Followups.
     */
    cursor?: FollowupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Followups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Followups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Followups.
     */
    distinct?: FollowupScalarFieldEnum | FollowupScalarFieldEnum[]
  }

  /**
   * Followup findMany
   */
  export type FollowupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Followup
     */
    select?: FollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Followup
     */
    omit?: FollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowupInclude<ExtArgs> | null
    /**
     * Filter, which Followups to fetch.
     */
    where?: FollowupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Followups to fetch.
     */
    orderBy?: FollowupOrderByWithRelationInput | FollowupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Followups.
     */
    cursor?: FollowupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Followups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Followups.
     */
    skip?: number
    distinct?: FollowupScalarFieldEnum | FollowupScalarFieldEnum[]
  }

  /**
   * Followup create
   */
  export type FollowupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Followup
     */
    select?: FollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Followup
     */
    omit?: FollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowupInclude<ExtArgs> | null
    /**
     * The data needed to create a Followup.
     */
    data: XOR<FollowupCreateInput, FollowupUncheckedCreateInput>
  }

  /**
   * Followup createMany
   */
  export type FollowupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Followups.
     */
    data: FollowupCreateManyInput | FollowupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Followup update
   */
  export type FollowupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Followup
     */
    select?: FollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Followup
     */
    omit?: FollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowupInclude<ExtArgs> | null
    /**
     * The data needed to update a Followup.
     */
    data: XOR<FollowupUpdateInput, FollowupUncheckedUpdateInput>
    /**
     * Choose, which Followup to update.
     */
    where: FollowupWhereUniqueInput
  }

  /**
   * Followup updateMany
   */
  export type FollowupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Followups.
     */
    data: XOR<FollowupUpdateManyMutationInput, FollowupUncheckedUpdateManyInput>
    /**
     * Filter which Followups to update
     */
    where?: FollowupWhereInput
    /**
     * Limit how many Followups to update.
     */
    limit?: number
  }

  /**
   * Followup upsert
   */
  export type FollowupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Followup
     */
    select?: FollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Followup
     */
    omit?: FollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowupInclude<ExtArgs> | null
    /**
     * The filter to search for the Followup to update in case it exists.
     */
    where: FollowupWhereUniqueInput
    /**
     * In case the Followup found by the `where` argument doesn't exist, create a new Followup with this data.
     */
    create: XOR<FollowupCreateInput, FollowupUncheckedCreateInput>
    /**
     * In case the Followup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FollowupUpdateInput, FollowupUncheckedUpdateInput>
  }

  /**
   * Followup delete
   */
  export type FollowupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Followup
     */
    select?: FollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Followup
     */
    omit?: FollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowupInclude<ExtArgs> | null
    /**
     * Filter which Followup to delete.
     */
    where: FollowupWhereUniqueInput
  }

  /**
   * Followup deleteMany
   */
  export type FollowupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Followups to delete
     */
    where?: FollowupWhereInput
    /**
     * Limit how many Followups to delete.
     */
    limit?: number
  }

  /**
   * Followup.contact
   */
  export type Followup$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
  }

  /**
   * Followup without action
   */
  export type FollowupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Followup
     */
    select?: FollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Followup
     */
    omit?: FollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowupInclude<ExtArgs> | null
  }


  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactMinAggregateOutputType = {
    id: string | null
    Campaign: string | null
    Range: string | null
    ContactNo: string | null
    Location: string | null
    ContactType: string | null
    Name: string | null
    City: string | null
    Address: string | null
    ContactIndustry: string | null
    ContactFunctionalArea: string | null
    ReferenceId: string | null
    Notes: string | null
    Facilities: string | null
    date: string | null
    Email: string | null
    CompanyName: string | null
    Website: string | null
    Status: string | null
    Qualifications: string | null
    isFavourite: boolean | null
    isImported: boolean | null
    AssignToId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactMaxAggregateOutputType = {
    id: string | null
    Campaign: string | null
    Range: string | null
    ContactNo: string | null
    Location: string | null
    ContactType: string | null
    Name: string | null
    City: string | null
    Address: string | null
    ContactIndustry: string | null
    ContactFunctionalArea: string | null
    ReferenceId: string | null
    Notes: string | null
    Facilities: string | null
    date: string | null
    Email: string | null
    CompanyName: string | null
    Website: string | null
    Status: string | null
    Qualifications: string | null
    isFavourite: boolean | null
    isImported: boolean | null
    AssignToId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    Campaign: number
    Range: number
    ContactNo: number
    Location: number
    ContactType: number
    Name: number
    City: number
    Address: number
    ContactIndustry: number
    ContactFunctionalArea: number
    ReferenceId: number
    Notes: number
    Facilities: number
    date: number
    Email: number
    CompanyName: number
    Website: number
    Status: number
    Qualifications: number
    isFavourite: number
    isImported: number
    AssignToId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactMinAggregateInputType = {
    id?: true
    Campaign?: true
    Range?: true
    ContactNo?: true
    Location?: true
    ContactType?: true
    Name?: true
    City?: true
    Address?: true
    ContactIndustry?: true
    ContactFunctionalArea?: true
    ReferenceId?: true
    Notes?: true
    Facilities?: true
    date?: true
    Email?: true
    CompanyName?: true
    Website?: true
    Status?: true
    Qualifications?: true
    isFavourite?: true
    isImported?: true
    AssignToId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    Campaign?: true
    Range?: true
    ContactNo?: true
    Location?: true
    ContactType?: true
    Name?: true
    City?: true
    Address?: true
    ContactIndustry?: true
    ContactFunctionalArea?: true
    ReferenceId?: true
    Notes?: true
    Facilities?: true
    date?: true
    Email?: true
    CompanyName?: true
    Website?: true
    Status?: true
    Qualifications?: true
    isFavourite?: true
    isImported?: true
    AssignToId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    Campaign?: true
    Range?: true
    ContactNo?: true
    Location?: true
    ContactType?: true
    Name?: true
    City?: true
    Address?: true
    ContactIndustry?: true
    ContactFunctionalArea?: true
    ReferenceId?: true
    Notes?: true
    Facilities?: true
    date?: true
    Email?: true
    CompanyName?: true
    Website?: true
    Status?: true
    Qualifications?: true
    isFavourite?: true
    isImported?: true
    AssignToId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: string
    Campaign: string | null
    Range: string | null
    ContactNo: string | null
    Location: string | null
    ContactType: string | null
    Name: string
    City: string | null
    Address: string | null
    ContactIndustry: string | null
    ContactFunctionalArea: string | null
    ReferenceId: string | null
    Notes: string | null
    Facilities: string | null
    date: string | null
    Email: string | null
    CompanyName: string | null
    Website: string | null
    Status: string | null
    Qualifications: string | null
    isFavourite: boolean
    isImported: boolean
    AssignToId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Campaign?: boolean
    Range?: boolean
    ContactNo?: boolean
    Location?: boolean
    ContactType?: boolean
    Name?: boolean
    City?: boolean
    Address?: boolean
    ContactIndustry?: boolean
    ContactFunctionalArea?: boolean
    ReferenceId?: boolean
    Notes?: boolean
    Facilities?: boolean
    date?: boolean
    Email?: boolean
    CompanyName?: boolean
    Website?: boolean
    Status?: boolean
    Qualifications?: boolean
    isFavourite?: boolean
    isImported?: boolean
    AssignToId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    AssignTo?: boolean | Contact$AssignToArgs<ExtArgs>
    followups?: boolean | Contact$followupsArgs<ExtArgs>
    contactFollowups?: boolean | Contact$contactFollowupsArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>



  export type ContactSelectScalar = {
    id?: boolean
    Campaign?: boolean
    Range?: boolean
    ContactNo?: boolean
    Location?: boolean
    ContactType?: boolean
    Name?: boolean
    City?: boolean
    Address?: boolean
    ContactIndustry?: boolean
    ContactFunctionalArea?: boolean
    ReferenceId?: boolean
    Notes?: boolean
    Facilities?: boolean
    date?: boolean
    Email?: boolean
    CompanyName?: boolean
    Website?: boolean
    Status?: boolean
    Qualifications?: boolean
    isFavourite?: boolean
    isImported?: boolean
    AssignToId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "Campaign" | "Range" | "ContactNo" | "Location" | "ContactType" | "Name" | "City" | "Address" | "ContactIndustry" | "ContactFunctionalArea" | "ReferenceId" | "Notes" | "Facilities" | "date" | "Email" | "CompanyName" | "Website" | "Status" | "Qualifications" | "isFavourite" | "isImported" | "AssignToId" | "createdAt" | "updatedAt", ExtArgs["result"]["contact"]>
  export type ContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AssignTo?: boolean | Contact$AssignToArgs<ExtArgs>
    followups?: boolean | Contact$followupsArgs<ExtArgs>
    contactFollowups?: boolean | Contact$contactFollowupsArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {
      AssignTo: Prisma.$AdminPayload<ExtArgs> | null
      followups: Prisma.$FollowupPayload<ExtArgs>[]
      contactFollowups: Prisma.$ContactFollowupPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      Campaign: string | null
      Range: string | null
      ContactNo: string | null
      Location: string | null
      ContactType: string | null
      Name: string
      City: string | null
      Address: string | null
      ContactIndustry: string | null
      ContactFunctionalArea: string | null
      ReferenceId: string | null
      Notes: string | null
      Facilities: string | null
      date: string | null
      Email: string | null
      CompanyName: string | null
      Website: string | null
      Status: string | null
      Qualifications: string | null
      isFavourite: boolean
      isImported: boolean
      AssignToId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFindUniqueArgs>(args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFindFirstArgs>(args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFindManyArgs>(args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends ContactCreateArgs>(args: SelectSubset<T, ContactCreateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contacts.
     * @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactCreateManyArgs>(args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends ContactDeleteArgs>(args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUpdateArgs>(args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactDeleteManyArgs>(args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUpdateManyArgs>(args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends ContactUpsertArgs>(args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AssignTo<T extends Contact$AssignToArgs<ExtArgs> = {}>(args?: Subset<T, Contact$AssignToArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    followups<T extends Contact$followupsArgs<ExtArgs> = {}>(args?: Subset<T, Contact$followupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contactFollowups<T extends Contact$contactFollowupsArgs<ExtArgs> = {}>(args?: Subset<T, Contact$contactFollowupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactFollowupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact model
   */
  interface ContactFieldRefs {
    readonly id: FieldRef<"Contact", 'String'>
    readonly Campaign: FieldRef<"Contact", 'String'>
    readonly Range: FieldRef<"Contact", 'String'>
    readonly ContactNo: FieldRef<"Contact", 'String'>
    readonly Location: FieldRef<"Contact", 'String'>
    readonly ContactType: FieldRef<"Contact", 'String'>
    readonly Name: FieldRef<"Contact", 'String'>
    readonly City: FieldRef<"Contact", 'String'>
    readonly Address: FieldRef<"Contact", 'String'>
    readonly ContactIndustry: FieldRef<"Contact", 'String'>
    readonly ContactFunctionalArea: FieldRef<"Contact", 'String'>
    readonly ReferenceId: FieldRef<"Contact", 'String'>
    readonly Notes: FieldRef<"Contact", 'String'>
    readonly Facilities: FieldRef<"Contact", 'String'>
    readonly date: FieldRef<"Contact", 'String'>
    readonly Email: FieldRef<"Contact", 'String'>
    readonly CompanyName: FieldRef<"Contact", 'String'>
    readonly Website: FieldRef<"Contact", 'String'>
    readonly Status: FieldRef<"Contact", 'String'>
    readonly Qualifications: FieldRef<"Contact", 'String'>
    readonly isFavourite: FieldRef<"Contact", 'Boolean'>
    readonly isImported: FieldRef<"Contact", 'Boolean'>
    readonly AssignToId: FieldRef<"Contact", 'String'>
    readonly createdAt: FieldRef<"Contact", 'DateTime'>
    readonly updatedAt: FieldRef<"Contact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
  }

  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
  }

  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
  }

  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to delete.
     */
    limit?: number
  }

  /**
   * Contact.AssignTo
   */
  export type Contact$AssignToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * Contact.followups
   */
  export type Contact$followupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Followup
     */
    select?: FollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Followup
     */
    omit?: FollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowupInclude<ExtArgs> | null
    where?: FollowupWhereInput
    orderBy?: FollowupOrderByWithRelationInput | FollowupOrderByWithRelationInput[]
    cursor?: FollowupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowupScalarFieldEnum | FollowupScalarFieldEnum[]
  }

  /**
   * Contact.contactFollowups
   */
  export type Contact$contactFollowupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactFollowup
     */
    select?: ContactFollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactFollowup
     */
    omit?: ContactFollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFollowupInclude<ExtArgs> | null
    where?: ContactFollowupWhereInput
    orderBy?: ContactFollowupOrderByWithRelationInput | ContactFollowupOrderByWithRelationInput[]
    cursor?: ContactFollowupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactFollowupScalarFieldEnum | ContactFollowupScalarFieldEnum[]
  }

  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
  }


  /**
   * Model ContactFollowup
   */

  export type AggregateContactFollowup = {
    _count: ContactFollowupCountAggregateOutputType | null
    _min: ContactFollowupMinAggregateOutputType | null
    _max: ContactFollowupMaxAggregateOutputType | null
  }

  export type ContactFollowupMinAggregateOutputType = {
    id: string | null
    contactId: string | null
    StartDate: string | null
    StatusType: string | null
    FollowupNextDate: string | null
    Description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactFollowupMaxAggregateOutputType = {
    id: string | null
    contactId: string | null
    StartDate: string | null
    StatusType: string | null
    FollowupNextDate: string | null
    Description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactFollowupCountAggregateOutputType = {
    id: number
    contactId: number
    StartDate: number
    StatusType: number
    FollowupNextDate: number
    Description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactFollowupMinAggregateInputType = {
    id?: true
    contactId?: true
    StartDate?: true
    StatusType?: true
    FollowupNextDate?: true
    Description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactFollowupMaxAggregateInputType = {
    id?: true
    contactId?: true
    StartDate?: true
    StatusType?: true
    FollowupNextDate?: true
    Description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactFollowupCountAggregateInputType = {
    id?: true
    contactId?: true
    StartDate?: true
    StatusType?: true
    FollowupNextDate?: true
    Description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactFollowupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactFollowup to aggregate.
     */
    where?: ContactFollowupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactFollowups to fetch.
     */
    orderBy?: ContactFollowupOrderByWithRelationInput | ContactFollowupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactFollowupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactFollowups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactFollowups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactFollowups
    **/
    _count?: true | ContactFollowupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactFollowupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactFollowupMaxAggregateInputType
  }

  export type GetContactFollowupAggregateType<T extends ContactFollowupAggregateArgs> = {
        [P in keyof T & keyof AggregateContactFollowup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactFollowup[P]>
      : GetScalarType<T[P], AggregateContactFollowup[P]>
  }




  export type ContactFollowupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactFollowupWhereInput
    orderBy?: ContactFollowupOrderByWithAggregationInput | ContactFollowupOrderByWithAggregationInput[]
    by: ContactFollowupScalarFieldEnum[] | ContactFollowupScalarFieldEnum
    having?: ContactFollowupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactFollowupCountAggregateInputType | true
    _min?: ContactFollowupMinAggregateInputType
    _max?: ContactFollowupMaxAggregateInputType
  }

  export type ContactFollowupGroupByOutputType = {
    id: string
    contactId: string
    StartDate: string | null
    StatusType: string | null
    FollowupNextDate: string | null
    Description: string | null
    createdAt: Date
    updatedAt: Date
    _count: ContactFollowupCountAggregateOutputType | null
    _min: ContactFollowupMinAggregateOutputType | null
    _max: ContactFollowupMaxAggregateOutputType | null
  }

  type GetContactFollowupGroupByPayload<T extends ContactFollowupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactFollowupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactFollowupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactFollowupGroupByOutputType[P]>
            : GetScalarType<T[P], ContactFollowupGroupByOutputType[P]>
        }
      >
    >


  export type ContactFollowupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contactId?: boolean
    StartDate?: boolean
    StatusType?: boolean
    FollowupNextDate?: boolean
    Description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactFollowup"]>



  export type ContactFollowupSelectScalar = {
    id?: boolean
    contactId?: boolean
    StartDate?: boolean
    StatusType?: boolean
    FollowupNextDate?: boolean
    Description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactFollowupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contactId" | "StartDate" | "StatusType" | "FollowupNextDate" | "Description" | "createdAt" | "updatedAt", ExtArgs["result"]["contactFollowup"]>
  export type ContactFollowupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
  }

  export type $ContactFollowupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactFollowup"
    objects: {
      contact: Prisma.$ContactPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contactId: string
      StartDate: string | null
      StatusType: string | null
      FollowupNextDate: string | null
      Description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contactFollowup"]>
    composites: {}
  }

  type ContactFollowupGetPayload<S extends boolean | null | undefined | ContactFollowupDefaultArgs> = $Result.GetResult<Prisma.$ContactFollowupPayload, S>

  type ContactFollowupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactFollowupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactFollowupCountAggregateInputType | true
    }

  export interface ContactFollowupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactFollowup'], meta: { name: 'ContactFollowup' } }
    /**
     * Find zero or one ContactFollowup that matches the filter.
     * @param {ContactFollowupFindUniqueArgs} args - Arguments to find a ContactFollowup
     * @example
     * // Get one ContactFollowup
     * const contactFollowup = await prisma.contactFollowup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFollowupFindUniqueArgs>(args: SelectSubset<T, ContactFollowupFindUniqueArgs<ExtArgs>>): Prisma__ContactFollowupClient<$Result.GetResult<Prisma.$ContactFollowupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContactFollowup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactFollowupFindUniqueOrThrowArgs} args - Arguments to find a ContactFollowup
     * @example
     * // Get one ContactFollowup
     * const contactFollowup = await prisma.contactFollowup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFollowupFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFollowupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactFollowupClient<$Result.GetResult<Prisma.$ContactFollowupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactFollowup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFollowupFindFirstArgs} args - Arguments to find a ContactFollowup
     * @example
     * // Get one ContactFollowup
     * const contactFollowup = await prisma.contactFollowup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFollowupFindFirstArgs>(args?: SelectSubset<T, ContactFollowupFindFirstArgs<ExtArgs>>): Prisma__ContactFollowupClient<$Result.GetResult<Prisma.$ContactFollowupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactFollowup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFollowupFindFirstOrThrowArgs} args - Arguments to find a ContactFollowup
     * @example
     * // Get one ContactFollowup
     * const contactFollowup = await prisma.contactFollowup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFollowupFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFollowupFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactFollowupClient<$Result.GetResult<Prisma.$ContactFollowupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContactFollowups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFollowupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactFollowups
     * const contactFollowups = await prisma.contactFollowup.findMany()
     * 
     * // Get first 10 ContactFollowups
     * const contactFollowups = await prisma.contactFollowup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactFollowupWithIdOnly = await prisma.contactFollowup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFollowupFindManyArgs>(args?: SelectSubset<T, ContactFollowupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactFollowupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContactFollowup.
     * @param {ContactFollowupCreateArgs} args - Arguments to create a ContactFollowup.
     * @example
     * // Create one ContactFollowup
     * const ContactFollowup = await prisma.contactFollowup.create({
     *   data: {
     *     // ... data to create a ContactFollowup
     *   }
     * })
     * 
     */
    create<T extends ContactFollowupCreateArgs>(args: SelectSubset<T, ContactFollowupCreateArgs<ExtArgs>>): Prisma__ContactFollowupClient<$Result.GetResult<Prisma.$ContactFollowupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContactFollowups.
     * @param {ContactFollowupCreateManyArgs} args - Arguments to create many ContactFollowups.
     * @example
     * // Create many ContactFollowups
     * const contactFollowup = await prisma.contactFollowup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactFollowupCreateManyArgs>(args?: SelectSubset<T, ContactFollowupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContactFollowup.
     * @param {ContactFollowupDeleteArgs} args - Arguments to delete one ContactFollowup.
     * @example
     * // Delete one ContactFollowup
     * const ContactFollowup = await prisma.contactFollowup.delete({
     *   where: {
     *     // ... filter to delete one ContactFollowup
     *   }
     * })
     * 
     */
    delete<T extends ContactFollowupDeleteArgs>(args: SelectSubset<T, ContactFollowupDeleteArgs<ExtArgs>>): Prisma__ContactFollowupClient<$Result.GetResult<Prisma.$ContactFollowupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContactFollowup.
     * @param {ContactFollowupUpdateArgs} args - Arguments to update one ContactFollowup.
     * @example
     * // Update one ContactFollowup
     * const contactFollowup = await prisma.contactFollowup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactFollowupUpdateArgs>(args: SelectSubset<T, ContactFollowupUpdateArgs<ExtArgs>>): Prisma__ContactFollowupClient<$Result.GetResult<Prisma.$ContactFollowupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContactFollowups.
     * @param {ContactFollowupDeleteManyArgs} args - Arguments to filter ContactFollowups to delete.
     * @example
     * // Delete a few ContactFollowups
     * const { count } = await prisma.contactFollowup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactFollowupDeleteManyArgs>(args?: SelectSubset<T, ContactFollowupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactFollowups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFollowupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactFollowups
     * const contactFollowup = await prisma.contactFollowup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactFollowupUpdateManyArgs>(args: SelectSubset<T, ContactFollowupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContactFollowup.
     * @param {ContactFollowupUpsertArgs} args - Arguments to update or create a ContactFollowup.
     * @example
     * // Update or create a ContactFollowup
     * const contactFollowup = await prisma.contactFollowup.upsert({
     *   create: {
     *     // ... data to create a ContactFollowup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactFollowup we want to update
     *   }
     * })
     */
    upsert<T extends ContactFollowupUpsertArgs>(args: SelectSubset<T, ContactFollowupUpsertArgs<ExtArgs>>): Prisma__ContactFollowupClient<$Result.GetResult<Prisma.$ContactFollowupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContactFollowups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFollowupCountArgs} args - Arguments to filter ContactFollowups to count.
     * @example
     * // Count the number of ContactFollowups
     * const count = await prisma.contactFollowup.count({
     *   where: {
     *     // ... the filter for the ContactFollowups we want to count
     *   }
     * })
    **/
    count<T extends ContactFollowupCountArgs>(
      args?: Subset<T, ContactFollowupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactFollowupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactFollowup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFollowupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactFollowupAggregateArgs>(args: Subset<T, ContactFollowupAggregateArgs>): Prisma.PrismaPromise<GetContactFollowupAggregateType<T>>

    /**
     * Group by ContactFollowup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFollowupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactFollowupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactFollowupGroupByArgs['orderBy'] }
        : { orderBy?: ContactFollowupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactFollowupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactFollowupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactFollowup model
   */
  readonly fields: ContactFollowupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactFollowup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactFollowupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contact<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactFollowup model
   */
  interface ContactFollowupFieldRefs {
    readonly id: FieldRef<"ContactFollowup", 'String'>
    readonly contactId: FieldRef<"ContactFollowup", 'String'>
    readonly StartDate: FieldRef<"ContactFollowup", 'String'>
    readonly StatusType: FieldRef<"ContactFollowup", 'String'>
    readonly FollowupNextDate: FieldRef<"ContactFollowup", 'String'>
    readonly Description: FieldRef<"ContactFollowup", 'String'>
    readonly createdAt: FieldRef<"ContactFollowup", 'DateTime'>
    readonly updatedAt: FieldRef<"ContactFollowup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContactFollowup findUnique
   */
  export type ContactFollowupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactFollowup
     */
    select?: ContactFollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactFollowup
     */
    omit?: ContactFollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFollowupInclude<ExtArgs> | null
    /**
     * Filter, which ContactFollowup to fetch.
     */
    where: ContactFollowupWhereUniqueInput
  }

  /**
   * ContactFollowup findUniqueOrThrow
   */
  export type ContactFollowupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactFollowup
     */
    select?: ContactFollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactFollowup
     */
    omit?: ContactFollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFollowupInclude<ExtArgs> | null
    /**
     * Filter, which ContactFollowup to fetch.
     */
    where: ContactFollowupWhereUniqueInput
  }

  /**
   * ContactFollowup findFirst
   */
  export type ContactFollowupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactFollowup
     */
    select?: ContactFollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactFollowup
     */
    omit?: ContactFollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFollowupInclude<ExtArgs> | null
    /**
     * Filter, which ContactFollowup to fetch.
     */
    where?: ContactFollowupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactFollowups to fetch.
     */
    orderBy?: ContactFollowupOrderByWithRelationInput | ContactFollowupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactFollowups.
     */
    cursor?: ContactFollowupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactFollowups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactFollowups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactFollowups.
     */
    distinct?: ContactFollowupScalarFieldEnum | ContactFollowupScalarFieldEnum[]
  }

  /**
   * ContactFollowup findFirstOrThrow
   */
  export type ContactFollowupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactFollowup
     */
    select?: ContactFollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactFollowup
     */
    omit?: ContactFollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFollowupInclude<ExtArgs> | null
    /**
     * Filter, which ContactFollowup to fetch.
     */
    where?: ContactFollowupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactFollowups to fetch.
     */
    orderBy?: ContactFollowupOrderByWithRelationInput | ContactFollowupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactFollowups.
     */
    cursor?: ContactFollowupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactFollowups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactFollowups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactFollowups.
     */
    distinct?: ContactFollowupScalarFieldEnum | ContactFollowupScalarFieldEnum[]
  }

  /**
   * ContactFollowup findMany
   */
  export type ContactFollowupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactFollowup
     */
    select?: ContactFollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactFollowup
     */
    omit?: ContactFollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFollowupInclude<ExtArgs> | null
    /**
     * Filter, which ContactFollowups to fetch.
     */
    where?: ContactFollowupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactFollowups to fetch.
     */
    orderBy?: ContactFollowupOrderByWithRelationInput | ContactFollowupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactFollowups.
     */
    cursor?: ContactFollowupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactFollowups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactFollowups.
     */
    skip?: number
    distinct?: ContactFollowupScalarFieldEnum | ContactFollowupScalarFieldEnum[]
  }

  /**
   * ContactFollowup create
   */
  export type ContactFollowupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactFollowup
     */
    select?: ContactFollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactFollowup
     */
    omit?: ContactFollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFollowupInclude<ExtArgs> | null
    /**
     * The data needed to create a ContactFollowup.
     */
    data: XOR<ContactFollowupCreateInput, ContactFollowupUncheckedCreateInput>
  }

  /**
   * ContactFollowup createMany
   */
  export type ContactFollowupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactFollowups.
     */
    data: ContactFollowupCreateManyInput | ContactFollowupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactFollowup update
   */
  export type ContactFollowupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactFollowup
     */
    select?: ContactFollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactFollowup
     */
    omit?: ContactFollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFollowupInclude<ExtArgs> | null
    /**
     * The data needed to update a ContactFollowup.
     */
    data: XOR<ContactFollowupUpdateInput, ContactFollowupUncheckedUpdateInput>
    /**
     * Choose, which ContactFollowup to update.
     */
    where: ContactFollowupWhereUniqueInput
  }

  /**
   * ContactFollowup updateMany
   */
  export type ContactFollowupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactFollowups.
     */
    data: XOR<ContactFollowupUpdateManyMutationInput, ContactFollowupUncheckedUpdateManyInput>
    /**
     * Filter which ContactFollowups to update
     */
    where?: ContactFollowupWhereInput
    /**
     * Limit how many ContactFollowups to update.
     */
    limit?: number
  }

  /**
   * ContactFollowup upsert
   */
  export type ContactFollowupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactFollowup
     */
    select?: ContactFollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactFollowup
     */
    omit?: ContactFollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFollowupInclude<ExtArgs> | null
    /**
     * The filter to search for the ContactFollowup to update in case it exists.
     */
    where: ContactFollowupWhereUniqueInput
    /**
     * In case the ContactFollowup found by the `where` argument doesn't exist, create a new ContactFollowup with this data.
     */
    create: XOR<ContactFollowupCreateInput, ContactFollowupUncheckedCreateInput>
    /**
     * In case the ContactFollowup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactFollowupUpdateInput, ContactFollowupUncheckedUpdateInput>
  }

  /**
   * ContactFollowup delete
   */
  export type ContactFollowupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactFollowup
     */
    select?: ContactFollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactFollowup
     */
    omit?: ContactFollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFollowupInclude<ExtArgs> | null
    /**
     * Filter which ContactFollowup to delete.
     */
    where: ContactFollowupWhereUniqueInput
  }

  /**
   * ContactFollowup deleteMany
   */
  export type ContactFollowupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactFollowups to delete
     */
    where?: ContactFollowupWhereInput
    /**
     * Limit how many ContactFollowups to delete.
     */
    limit?: number
  }

  /**
   * ContactFollowup without action
   */
  export type ContactFollowupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactFollowup
     */
    select?: ContactFollowupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactFollowup
     */
    omit?: ContactFollowupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFollowupInclude<ExtArgs> | null
  }


  /**
   * Model RequestUser
   */

  export type AggregateRequestUser = {
    _count: RequestUserCountAggregateOutputType | null
    _min: RequestUserMinAggregateOutputType | null
    _max: RequestUserMaxAggregateOutputType | null
  }

  export type RequestUserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
  }

  export type RequestUserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
  }

  export type RequestUserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    _all: number
  }


  export type RequestUserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
  }

  export type RequestUserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
  }

  export type RequestUserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    _all?: true
  }

  export type RequestUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RequestUser to aggregate.
     */
    where?: RequestUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestUsers to fetch.
     */
    orderBy?: RequestUserOrderByWithRelationInput | RequestUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RequestUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RequestUsers
    **/
    _count?: true | RequestUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequestUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequestUserMaxAggregateInputType
  }

  export type GetRequestUserAggregateType<T extends RequestUserAggregateArgs> = {
        [P in keyof T & keyof AggregateRequestUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequestUser[P]>
      : GetScalarType<T[P], AggregateRequestUser[P]>
  }




  export type RequestUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequestUserWhereInput
    orderBy?: RequestUserOrderByWithAggregationInput | RequestUserOrderByWithAggregationInput[]
    by: RequestUserScalarFieldEnum[] | RequestUserScalarFieldEnum
    having?: RequestUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequestUserCountAggregateInputType | true
    _min?: RequestUserMinAggregateInputType
    _max?: RequestUserMaxAggregateInputType
  }

  export type RequestUserGroupByOutputType = {
    id: string
    name: string
    email: string
    password: string
    _count: RequestUserCountAggregateOutputType | null
    _min: RequestUserMinAggregateOutputType | null
    _max: RequestUserMaxAggregateOutputType | null
  }

  type GetRequestUserGroupByPayload<T extends RequestUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RequestUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequestUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequestUserGroupByOutputType[P]>
            : GetScalarType<T[P], RequestUserGroupByOutputType[P]>
        }
      >
    >


  export type RequestUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
  }, ExtArgs["result"]["requestUser"]>



  export type RequestUserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
  }

  export type RequestUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "password", ExtArgs["result"]["requestUser"]>

  export type $RequestUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RequestUser"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      password: string
    }, ExtArgs["result"]["requestUser"]>
    composites: {}
  }

  type RequestUserGetPayload<S extends boolean | null | undefined | RequestUserDefaultArgs> = $Result.GetResult<Prisma.$RequestUserPayload, S>

  type RequestUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RequestUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RequestUserCountAggregateInputType | true
    }

  export interface RequestUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RequestUser'], meta: { name: 'RequestUser' } }
    /**
     * Find zero or one RequestUser that matches the filter.
     * @param {RequestUserFindUniqueArgs} args - Arguments to find a RequestUser
     * @example
     * // Get one RequestUser
     * const requestUser = await prisma.requestUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RequestUserFindUniqueArgs>(args: SelectSubset<T, RequestUserFindUniqueArgs<ExtArgs>>): Prisma__RequestUserClient<$Result.GetResult<Prisma.$RequestUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RequestUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RequestUserFindUniqueOrThrowArgs} args - Arguments to find a RequestUser
     * @example
     * // Get one RequestUser
     * const requestUser = await prisma.requestUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RequestUserFindUniqueOrThrowArgs>(args: SelectSubset<T, RequestUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RequestUserClient<$Result.GetResult<Prisma.$RequestUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RequestUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestUserFindFirstArgs} args - Arguments to find a RequestUser
     * @example
     * // Get one RequestUser
     * const requestUser = await prisma.requestUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RequestUserFindFirstArgs>(args?: SelectSubset<T, RequestUserFindFirstArgs<ExtArgs>>): Prisma__RequestUserClient<$Result.GetResult<Prisma.$RequestUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RequestUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestUserFindFirstOrThrowArgs} args - Arguments to find a RequestUser
     * @example
     * // Get one RequestUser
     * const requestUser = await prisma.requestUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RequestUserFindFirstOrThrowArgs>(args?: SelectSubset<T, RequestUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__RequestUserClient<$Result.GetResult<Prisma.$RequestUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RequestUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequestUsers
     * const requestUsers = await prisma.requestUser.findMany()
     * 
     * // Get first 10 RequestUsers
     * const requestUsers = await prisma.requestUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requestUserWithIdOnly = await prisma.requestUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RequestUserFindManyArgs>(args?: SelectSubset<T, RequestUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequestUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RequestUser.
     * @param {RequestUserCreateArgs} args - Arguments to create a RequestUser.
     * @example
     * // Create one RequestUser
     * const RequestUser = await prisma.requestUser.create({
     *   data: {
     *     // ... data to create a RequestUser
     *   }
     * })
     * 
     */
    create<T extends RequestUserCreateArgs>(args: SelectSubset<T, RequestUserCreateArgs<ExtArgs>>): Prisma__RequestUserClient<$Result.GetResult<Prisma.$RequestUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RequestUsers.
     * @param {RequestUserCreateManyArgs} args - Arguments to create many RequestUsers.
     * @example
     * // Create many RequestUsers
     * const requestUser = await prisma.requestUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RequestUserCreateManyArgs>(args?: SelectSubset<T, RequestUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RequestUser.
     * @param {RequestUserDeleteArgs} args - Arguments to delete one RequestUser.
     * @example
     * // Delete one RequestUser
     * const RequestUser = await prisma.requestUser.delete({
     *   where: {
     *     // ... filter to delete one RequestUser
     *   }
     * })
     * 
     */
    delete<T extends RequestUserDeleteArgs>(args: SelectSubset<T, RequestUserDeleteArgs<ExtArgs>>): Prisma__RequestUserClient<$Result.GetResult<Prisma.$RequestUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RequestUser.
     * @param {RequestUserUpdateArgs} args - Arguments to update one RequestUser.
     * @example
     * // Update one RequestUser
     * const requestUser = await prisma.requestUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RequestUserUpdateArgs>(args: SelectSubset<T, RequestUserUpdateArgs<ExtArgs>>): Prisma__RequestUserClient<$Result.GetResult<Prisma.$RequestUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RequestUsers.
     * @param {RequestUserDeleteManyArgs} args - Arguments to filter RequestUsers to delete.
     * @example
     * // Delete a few RequestUsers
     * const { count } = await prisma.requestUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RequestUserDeleteManyArgs>(args?: SelectSubset<T, RequestUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequestUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequestUsers
     * const requestUser = await prisma.requestUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RequestUserUpdateManyArgs>(args: SelectSubset<T, RequestUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RequestUser.
     * @param {RequestUserUpsertArgs} args - Arguments to update or create a RequestUser.
     * @example
     * // Update or create a RequestUser
     * const requestUser = await prisma.requestUser.upsert({
     *   create: {
     *     // ... data to create a RequestUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequestUser we want to update
     *   }
     * })
     */
    upsert<T extends RequestUserUpsertArgs>(args: SelectSubset<T, RequestUserUpsertArgs<ExtArgs>>): Prisma__RequestUserClient<$Result.GetResult<Prisma.$RequestUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RequestUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestUserCountArgs} args - Arguments to filter RequestUsers to count.
     * @example
     * // Count the number of RequestUsers
     * const count = await prisma.requestUser.count({
     *   where: {
     *     // ... the filter for the RequestUsers we want to count
     *   }
     * })
    **/
    count<T extends RequestUserCountArgs>(
      args?: Subset<T, RequestUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequestUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequestUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequestUserAggregateArgs>(args: Subset<T, RequestUserAggregateArgs>): Prisma.PrismaPromise<GetRequestUserAggregateType<T>>

    /**
     * Group by RequestUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequestUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequestUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequestUserGroupByArgs['orderBy'] }
        : { orderBy?: RequestUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequestUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequestUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RequestUser model
   */
  readonly fields: RequestUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RequestUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RequestUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RequestUser model
   */
  interface RequestUserFieldRefs {
    readonly id: FieldRef<"RequestUser", 'String'>
    readonly name: FieldRef<"RequestUser", 'String'>
    readonly email: FieldRef<"RequestUser", 'String'>
    readonly password: FieldRef<"RequestUser", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RequestUser findUnique
   */
  export type RequestUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestUser
     */
    select?: RequestUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestUser
     */
    omit?: RequestUserOmit<ExtArgs> | null
    /**
     * Filter, which RequestUser to fetch.
     */
    where: RequestUserWhereUniqueInput
  }

  /**
   * RequestUser findUniqueOrThrow
   */
  export type RequestUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestUser
     */
    select?: RequestUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestUser
     */
    omit?: RequestUserOmit<ExtArgs> | null
    /**
     * Filter, which RequestUser to fetch.
     */
    where: RequestUserWhereUniqueInput
  }

  /**
   * RequestUser findFirst
   */
  export type RequestUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestUser
     */
    select?: RequestUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestUser
     */
    omit?: RequestUserOmit<ExtArgs> | null
    /**
     * Filter, which RequestUser to fetch.
     */
    where?: RequestUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestUsers to fetch.
     */
    orderBy?: RequestUserOrderByWithRelationInput | RequestUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestUsers.
     */
    cursor?: RequestUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestUsers.
     */
    distinct?: RequestUserScalarFieldEnum | RequestUserScalarFieldEnum[]
  }

  /**
   * RequestUser findFirstOrThrow
   */
  export type RequestUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestUser
     */
    select?: RequestUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestUser
     */
    omit?: RequestUserOmit<ExtArgs> | null
    /**
     * Filter, which RequestUser to fetch.
     */
    where?: RequestUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestUsers to fetch.
     */
    orderBy?: RequestUserOrderByWithRelationInput | RequestUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequestUsers.
     */
    cursor?: RequestUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequestUsers.
     */
    distinct?: RequestUserScalarFieldEnum | RequestUserScalarFieldEnum[]
  }

  /**
   * RequestUser findMany
   */
  export type RequestUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestUser
     */
    select?: RequestUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestUser
     */
    omit?: RequestUserOmit<ExtArgs> | null
    /**
     * Filter, which RequestUsers to fetch.
     */
    where?: RequestUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequestUsers to fetch.
     */
    orderBy?: RequestUserOrderByWithRelationInput | RequestUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RequestUsers.
     */
    cursor?: RequestUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequestUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequestUsers.
     */
    skip?: number
    distinct?: RequestUserScalarFieldEnum | RequestUserScalarFieldEnum[]
  }

  /**
   * RequestUser create
   */
  export type RequestUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestUser
     */
    select?: RequestUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestUser
     */
    omit?: RequestUserOmit<ExtArgs> | null
    /**
     * The data needed to create a RequestUser.
     */
    data: XOR<RequestUserCreateInput, RequestUserUncheckedCreateInput>
  }

  /**
   * RequestUser createMany
   */
  export type RequestUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RequestUsers.
     */
    data: RequestUserCreateManyInput | RequestUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RequestUser update
   */
  export type RequestUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestUser
     */
    select?: RequestUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestUser
     */
    omit?: RequestUserOmit<ExtArgs> | null
    /**
     * The data needed to update a RequestUser.
     */
    data: XOR<RequestUserUpdateInput, RequestUserUncheckedUpdateInput>
    /**
     * Choose, which RequestUser to update.
     */
    where: RequestUserWhereUniqueInput
  }

  /**
   * RequestUser updateMany
   */
  export type RequestUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RequestUsers.
     */
    data: XOR<RequestUserUpdateManyMutationInput, RequestUserUncheckedUpdateManyInput>
    /**
     * Filter which RequestUsers to update
     */
    where?: RequestUserWhereInput
    /**
     * Limit how many RequestUsers to update.
     */
    limit?: number
  }

  /**
   * RequestUser upsert
   */
  export type RequestUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestUser
     */
    select?: RequestUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestUser
     */
    omit?: RequestUserOmit<ExtArgs> | null
    /**
     * The filter to search for the RequestUser to update in case it exists.
     */
    where: RequestUserWhereUniqueInput
    /**
     * In case the RequestUser found by the `where` argument doesn't exist, create a new RequestUser with this data.
     */
    create: XOR<RequestUserCreateInput, RequestUserUncheckedCreateInput>
    /**
     * In case the RequestUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RequestUserUpdateInput, RequestUserUncheckedUpdateInput>
  }

  /**
   * RequestUser delete
   */
  export type RequestUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestUser
     */
    select?: RequestUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestUser
     */
    omit?: RequestUserOmit<ExtArgs> | null
    /**
     * Filter which RequestUser to delete.
     */
    where: RequestUserWhereUniqueInput
  }

  /**
   * RequestUser deleteMany
   */
  export type RequestUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RequestUsers to delete
     */
    where?: RequestUserWhereInput
    /**
     * Limit how many RequestUsers to delete.
     */
    limit?: number
  }

  /**
   * RequestUser without action
   */
  export type RequestUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequestUser
     */
    select?: RequestUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequestUser
     */
    omit?: RequestUserOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AdminScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    role: 'role',
    city: 'city',
    phone: 'phone',
    status: 'status',
    AddressLine1: 'AddressLine1',
    AddressLine2: 'AddressLine2',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const CampaignScalarFieldEnum: {
    id: 'id',
    Name: 'Name',
    Status: 'Status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CampaignScalarFieldEnum = (typeof CampaignScalarFieldEnum)[keyof typeof CampaignScalarFieldEnum]


  export const TypeScalarFieldEnum: {
    id: 'id',
    Name: 'Name',
    Status: 'Status',
    campaignId: 'campaignId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TypeScalarFieldEnum = (typeof TypeScalarFieldEnum)[keyof typeof TypeScalarFieldEnum]


  export const SubTypeScalarFieldEnum: {
    id: 'id',
    Name: 'Name',
    Status: 'Status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    campaignId: 'campaignId',
    customerTypeId: 'customerTypeId'
  };

  export type SubTypeScalarFieldEnum = (typeof SubTypeScalarFieldEnum)[keyof typeof SubTypeScalarFieldEnum]


  export const ContactCampaignScalarFieldEnum: {
    id: 'id',
    Name: 'Name',
    Status: 'Status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactCampaignScalarFieldEnum = (typeof ContactCampaignScalarFieldEnum)[keyof typeof ContactCampaignScalarFieldEnum]


  export const ContactTypeScalarFieldEnum: {
    id: 'id',
    Name: 'Name',
    Status: 'Status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    campaignId: 'campaignId'
  };

  export type ContactTypeScalarFieldEnum = (typeof ContactTypeScalarFieldEnum)[keyof typeof ContactTypeScalarFieldEnum]


  export const CityScalarFieldEnum: {
    id: 'id',
    Name: 'Name',
    Status: 'Status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CityScalarFieldEnum = (typeof CityScalarFieldEnum)[keyof typeof CityScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    Name: 'Name',
    Status: 'Status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    cityId: 'cityId'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const FacilityScalarFieldEnum: {
    id: 'id',
    Name: 'Name',
    Status: 'Status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FacilityScalarFieldEnum = (typeof FacilityScalarFieldEnum)[keyof typeof FacilityScalarFieldEnum]


  export const AmenityScalarFieldEnum: {
    id: 'id',
    Name: 'Name',
    Status: 'Status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AmenityScalarFieldEnum = (typeof AmenityScalarFieldEnum)[keyof typeof AmenityScalarFieldEnum]


  export const FunctionalAreaScalarFieldEnum: {
    id: 'id',
    Name: 'Name',
    Status: 'Status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FunctionalAreaScalarFieldEnum = (typeof FunctionalAreaScalarFieldEnum)[keyof typeof FunctionalAreaScalarFieldEnum]


  export const IndustryScalarFieldEnum: {
    id: 'id',
    Name: 'Name',
    Status: 'Status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IndustryScalarFieldEnum = (typeof IndustryScalarFieldEnum)[keyof typeof IndustryScalarFieldEnum]


  export const ReferenceScalarFieldEnum: {
    id: 'id',
    Name: 'Name',
    Status: 'Status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReferenceScalarFieldEnum = (typeof ReferenceScalarFieldEnum)[keyof typeof ReferenceScalarFieldEnum]


  export const ExpenseScalarFieldEnum: {
    id: 'id',
    Name: 'Name',
    Status: 'Status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExpenseScalarFieldEnum = (typeof ExpenseScalarFieldEnum)[keyof typeof ExpenseScalarFieldEnum]


  export const IncomeScalarFieldEnum: {
    id: 'id',
    Name: 'Name',
    Status: 'Status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IncomeScalarFieldEnum = (typeof IncomeScalarFieldEnum)[keyof typeof IncomeScalarFieldEnum]


  export const StatusTypeScalarFieldEnum: {
    id: 'id',
    Name: 'Name',
    Status: 'Status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StatusTypeScalarFieldEnum = (typeof StatusTypeScalarFieldEnum)[keyof typeof StatusTypeScalarFieldEnum]


  export const ContactStatusTypeScalarFieldEnum: {
    id: 'id',
    Name: 'Name',
    Status: 'Status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactStatusTypeScalarFieldEnum = (typeof ContactStatusTypeScalarFieldEnum)[keyof typeof ContactStatusTypeScalarFieldEnum]


  export const PaymentMethodScalarFieldEnum: {
    id: 'id',
    Name: 'Name',
    Status: 'Status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentMethodScalarFieldEnum = (typeof PaymentMethodScalarFieldEnum)[keyof typeof PaymentMethodScalarFieldEnum]


  export const TemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    subject: 'subject',
    body: 'body',
    description: 'description',
    whatsappImage: 'whatsappImage',
    createdBy: 'createdBy',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TemplateScalarFieldEnum = (typeof TemplateScalarFieldEnum)[keyof typeof TemplateScalarFieldEnum]


  export const IncomeMarketingScalarFieldEnum: {
    id: 'id',
    Date: 'Date',
    PartyName: 'PartyName',
    User: 'User',
    Income: 'Income',
    Amount: 'Amount',
    DueAmount: 'DueAmount',
    PaymentMethode: 'PaymentMethode',
    Status: 'Status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IncomeMarketingScalarFieldEnum = (typeof IncomeMarketingScalarFieldEnum)[keyof typeof IncomeMarketingScalarFieldEnum]


  export const ExpenseMarketingScalarFieldEnum: {
    id: 'id',
    Date: 'Date',
    PartyName: 'PartyName',
    User: 'User',
    Expense: 'Expense',
    Amount: 'Amount',
    DueAmount: 'DueAmount',
    PaymentMethode: 'PaymentMethode',
    Status: 'Status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExpenseMarketingScalarFieldEnum = (typeof ExpenseMarketingScalarFieldEnum)[keyof typeof ExpenseMarketingScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    date: 'date',
    Time: 'Time',
    Description: 'Description',
    User: 'User',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const ScheduleScalarFieldEnum: {
    id: 'id',
    date: 'date',
    Time: 'Time',
    Description: 'Description',
    User: 'User',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ScheduleScalarFieldEnum = (typeof ScheduleScalarFieldEnum)[keyof typeof ScheduleScalarFieldEnum]


  export const CompanyProjectScalarFieldEnum: {
    id: 'id',
    ProjectName: 'ProjectName',
    ProjectType: 'ProjectType',
    ProjectStatus: 'ProjectStatus',
    City: 'City',
    Location: 'Location',
    Area: 'Area',
    Range: 'Range',
    Adderess: 'Adderess',
    Facillities: 'Facillities',
    Amenities: 'Amenities',
    Description: 'Description',
    Video: 'Video',
    GoogleMap: 'GoogleMap',
    CustomerImage: 'CustomerImage',
    SitePlan: 'SitePlan',
    CreatedBy: 'CreatedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyProjectScalarFieldEnum = (typeof CompanyProjectScalarFieldEnum)[keyof typeof CompanyProjectScalarFieldEnum]


  export const BuilderSliderScalarFieldEnum: {
    id: 'id',
    Image: 'Image',
    Status: 'Status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BuilderSliderScalarFieldEnum = (typeof BuilderSliderScalarFieldEnum)[keyof typeof BuilderSliderScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    Campaign: 'Campaign',
    CustomerType: 'CustomerType',
    CustomerSubType: 'CustomerSubType',
    customerName: 'customerName',
    ContactNumber: 'ContactNumber',
    City: 'City',
    Location: 'Location',
    Area: 'Area',
    Adderess: 'Adderess',
    Email: 'Email',
    Facillities: 'Facillities',
    ReferenceId: 'ReferenceId',
    CustomerId: 'CustomerId',
    CustomerDate: 'CustomerDate',
    CustomerYear: 'CustomerYear',
    Other: 'Other',
    Description: 'Description',
    Video: 'Video',
    Verified: 'Verified',
    GoogleMap: 'GoogleMap',
    CustomerImage: 'CustomerImage',
    SitePlan: 'SitePlan',
    isFavourite: 'isFavourite',
    AssignToId: 'AssignToId',
    CreatedById: 'CreatedById',
    isImported: 'isImported',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const FollowupScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    StartDate: 'StartDate',
    StatusType: 'StatusType',
    FollowupNextDate: 'FollowupNextDate',
    Description: 'Description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    contactId: 'contactId'
  };

  export type FollowupScalarFieldEnum = (typeof FollowupScalarFieldEnum)[keyof typeof FollowupScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    Campaign: 'Campaign',
    Range: 'Range',
    ContactNo: 'ContactNo',
    Location: 'Location',
    ContactType: 'ContactType',
    Name: 'Name',
    City: 'City',
    Address: 'Address',
    ContactIndustry: 'ContactIndustry',
    ContactFunctionalArea: 'ContactFunctionalArea',
    ReferenceId: 'ReferenceId',
    Notes: 'Notes',
    Facilities: 'Facilities',
    date: 'date',
    Email: 'Email',
    CompanyName: 'CompanyName',
    Website: 'Website',
    Status: 'Status',
    Qualifications: 'Qualifications',
    isFavourite: 'isFavourite',
    isImported: 'isImported',
    AssignToId: 'AssignToId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const ContactFollowupScalarFieldEnum: {
    id: 'id',
    contactId: 'contactId',
    StartDate: 'StartDate',
    StatusType: 'StatusType',
    FollowupNextDate: 'FollowupNextDate',
    Description: 'Description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactFollowupScalarFieldEnum = (typeof ContactFollowupScalarFieldEnum)[keyof typeof ContactFollowupScalarFieldEnum]


  export const RequestUserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password'
  };

  export type RequestUserScalarFieldEnum = (typeof RequestUserScalarFieldEnum)[keyof typeof RequestUserScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const AdminOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    city: 'city',
    phone: 'phone',
    AddressLine1: 'AddressLine1',
    AddressLine2: 'AddressLine2',
    createdBy: 'createdBy'
  };

  export type AdminOrderByRelevanceFieldEnum = (typeof AdminOrderByRelevanceFieldEnum)[keyof typeof AdminOrderByRelevanceFieldEnum]


  export const CampaignOrderByRelevanceFieldEnum: {
    id: 'id',
    Name: 'Name'
  };

  export type CampaignOrderByRelevanceFieldEnum = (typeof CampaignOrderByRelevanceFieldEnum)[keyof typeof CampaignOrderByRelevanceFieldEnum]


  export const TypeOrderByRelevanceFieldEnum: {
    id: 'id',
    Name: 'Name',
    campaignId: 'campaignId'
  };

  export type TypeOrderByRelevanceFieldEnum = (typeof TypeOrderByRelevanceFieldEnum)[keyof typeof TypeOrderByRelevanceFieldEnum]


  export const SubTypeOrderByRelevanceFieldEnum: {
    id: 'id',
    Name: 'Name',
    Status: 'Status',
    campaignId: 'campaignId',
    customerTypeId: 'customerTypeId'
  };

  export type SubTypeOrderByRelevanceFieldEnum = (typeof SubTypeOrderByRelevanceFieldEnum)[keyof typeof SubTypeOrderByRelevanceFieldEnum]


  export const ContactCampaignOrderByRelevanceFieldEnum: {
    id: 'id',
    Name: 'Name'
  };

  export type ContactCampaignOrderByRelevanceFieldEnum = (typeof ContactCampaignOrderByRelevanceFieldEnum)[keyof typeof ContactCampaignOrderByRelevanceFieldEnum]


  export const ContactTypeOrderByRelevanceFieldEnum: {
    id: 'id',
    Name: 'Name',
    campaignId: 'campaignId'
  };

  export type ContactTypeOrderByRelevanceFieldEnum = (typeof ContactTypeOrderByRelevanceFieldEnum)[keyof typeof ContactTypeOrderByRelevanceFieldEnum]


  export const CityOrderByRelevanceFieldEnum: {
    id: 'id',
    Name: 'Name',
    Status: 'Status'
  };

  export type CityOrderByRelevanceFieldEnum = (typeof CityOrderByRelevanceFieldEnum)[keyof typeof CityOrderByRelevanceFieldEnum]


  export const LocationOrderByRelevanceFieldEnum: {
    id: 'id',
    Name: 'Name',
    Status: 'Status',
    cityId: 'cityId'
  };

  export type LocationOrderByRelevanceFieldEnum = (typeof LocationOrderByRelevanceFieldEnum)[keyof typeof LocationOrderByRelevanceFieldEnum]


  export const FacilityOrderByRelevanceFieldEnum: {
    id: 'id',
    Name: 'Name',
    Status: 'Status'
  };

  export type FacilityOrderByRelevanceFieldEnum = (typeof FacilityOrderByRelevanceFieldEnum)[keyof typeof FacilityOrderByRelevanceFieldEnum]


  export const AmenityOrderByRelevanceFieldEnum: {
    id: 'id',
    Name: 'Name',
    Status: 'Status'
  };

  export type AmenityOrderByRelevanceFieldEnum = (typeof AmenityOrderByRelevanceFieldEnum)[keyof typeof AmenityOrderByRelevanceFieldEnum]


  export const FunctionalAreaOrderByRelevanceFieldEnum: {
    id: 'id',
    Name: 'Name',
    Status: 'Status'
  };

  export type FunctionalAreaOrderByRelevanceFieldEnum = (typeof FunctionalAreaOrderByRelevanceFieldEnum)[keyof typeof FunctionalAreaOrderByRelevanceFieldEnum]


  export const IndustryOrderByRelevanceFieldEnum: {
    id: 'id',
    Name: 'Name',
    Status: 'Status'
  };

  export type IndustryOrderByRelevanceFieldEnum = (typeof IndustryOrderByRelevanceFieldEnum)[keyof typeof IndustryOrderByRelevanceFieldEnum]


  export const ReferenceOrderByRelevanceFieldEnum: {
    id: 'id',
    Name: 'Name',
    Status: 'Status'
  };

  export type ReferenceOrderByRelevanceFieldEnum = (typeof ReferenceOrderByRelevanceFieldEnum)[keyof typeof ReferenceOrderByRelevanceFieldEnum]


  export const ExpenseOrderByRelevanceFieldEnum: {
    id: 'id',
    Name: 'Name',
    Status: 'Status'
  };

  export type ExpenseOrderByRelevanceFieldEnum = (typeof ExpenseOrderByRelevanceFieldEnum)[keyof typeof ExpenseOrderByRelevanceFieldEnum]


  export const IncomeOrderByRelevanceFieldEnum: {
    id: 'id',
    Name: 'Name',
    Status: 'Status'
  };

  export type IncomeOrderByRelevanceFieldEnum = (typeof IncomeOrderByRelevanceFieldEnum)[keyof typeof IncomeOrderByRelevanceFieldEnum]


  export const StatusTypeOrderByRelevanceFieldEnum: {
    id: 'id',
    Name: 'Name',
    Status: 'Status'
  };

  export type StatusTypeOrderByRelevanceFieldEnum = (typeof StatusTypeOrderByRelevanceFieldEnum)[keyof typeof StatusTypeOrderByRelevanceFieldEnum]


  export const ContactStatusTypeOrderByRelevanceFieldEnum: {
    id: 'id',
    Name: 'Name',
    Status: 'Status'
  };

  export type ContactStatusTypeOrderByRelevanceFieldEnum = (typeof ContactStatusTypeOrderByRelevanceFieldEnum)[keyof typeof ContactStatusTypeOrderByRelevanceFieldEnum]


  export const PaymentMethodOrderByRelevanceFieldEnum: {
    id: 'id',
    Name: 'Name',
    Status: 'Status'
  };

  export type PaymentMethodOrderByRelevanceFieldEnum = (typeof PaymentMethodOrderByRelevanceFieldEnum)[keyof typeof PaymentMethodOrderByRelevanceFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const TemplateOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    subject: 'subject',
    body: 'body',
    description: 'description',
    createdBy: 'createdBy',
    status: 'status'
  };

  export type TemplateOrderByRelevanceFieldEnum = (typeof TemplateOrderByRelevanceFieldEnum)[keyof typeof TemplateOrderByRelevanceFieldEnum]


  export const IncomeMarketingOrderByRelevanceFieldEnum: {
    id: 'id',
    Date: 'Date',
    PartyName: 'PartyName',
    User: 'User',
    Income: 'Income',
    Amount: 'Amount',
    DueAmount: 'DueAmount',
    PaymentMethode: 'PaymentMethode',
    Status: 'Status'
  };

  export type IncomeMarketingOrderByRelevanceFieldEnum = (typeof IncomeMarketingOrderByRelevanceFieldEnum)[keyof typeof IncomeMarketingOrderByRelevanceFieldEnum]


  export const ExpenseMarketingOrderByRelevanceFieldEnum: {
    id: 'id',
    Date: 'Date',
    PartyName: 'PartyName',
    User: 'User',
    Expense: 'Expense',
    Amount: 'Amount',
    DueAmount: 'DueAmount',
    PaymentMethode: 'PaymentMethode',
    Status: 'Status'
  };

  export type ExpenseMarketingOrderByRelevanceFieldEnum = (typeof ExpenseMarketingOrderByRelevanceFieldEnum)[keyof typeof ExpenseMarketingOrderByRelevanceFieldEnum]


  export const TaskOrderByRelevanceFieldEnum: {
    id: 'id',
    date: 'date',
    Time: 'Time',
    Description: 'Description',
    User: 'User'
  };

  export type TaskOrderByRelevanceFieldEnum = (typeof TaskOrderByRelevanceFieldEnum)[keyof typeof TaskOrderByRelevanceFieldEnum]


  export const ScheduleOrderByRelevanceFieldEnum: {
    id: 'id',
    date: 'date',
    Time: 'Time',
    Description: 'Description',
    User: 'User'
  };

  export type ScheduleOrderByRelevanceFieldEnum = (typeof ScheduleOrderByRelevanceFieldEnum)[keyof typeof ScheduleOrderByRelevanceFieldEnum]


  export const CompanyProjectOrderByRelevanceFieldEnum: {
    id: 'id',
    ProjectName: 'ProjectName',
    ProjectType: 'ProjectType',
    ProjectStatus: 'ProjectStatus',
    City: 'City',
    Location: 'Location',
    Area: 'Area',
    Range: 'Range',
    Adderess: 'Adderess',
    Facillities: 'Facillities',
    Amenities: 'Amenities',
    Description: 'Description',
    Video: 'Video',
    GoogleMap: 'GoogleMap',
    CreatedBy: 'CreatedBy'
  };

  export type CompanyProjectOrderByRelevanceFieldEnum = (typeof CompanyProjectOrderByRelevanceFieldEnum)[keyof typeof CompanyProjectOrderByRelevanceFieldEnum]


  export const BuilderSliderOrderByRelevanceFieldEnum: {
    id: 'id',
    Status: 'Status'
  };

  export type BuilderSliderOrderByRelevanceFieldEnum = (typeof BuilderSliderOrderByRelevanceFieldEnum)[keyof typeof BuilderSliderOrderByRelevanceFieldEnum]


  export const CustomerOrderByRelevanceFieldEnum: {
    id: 'id',
    Campaign: 'Campaign',
    CustomerType: 'CustomerType',
    CustomerSubType: 'CustomerSubType',
    customerName: 'customerName',
    ContactNumber: 'ContactNumber',
    City: 'City',
    Location: 'Location',
    Area: 'Area',
    Adderess: 'Adderess',
    Email: 'Email',
    Facillities: 'Facillities',
    ReferenceId: 'ReferenceId',
    CustomerId: 'CustomerId',
    CustomerDate: 'CustomerDate',
    CustomerYear: 'CustomerYear',
    Other: 'Other',
    Description: 'Description',
    Video: 'Video',
    Verified: 'Verified',
    GoogleMap: 'GoogleMap',
    AssignToId: 'AssignToId',
    CreatedById: 'CreatedById'
  };

  export type CustomerOrderByRelevanceFieldEnum = (typeof CustomerOrderByRelevanceFieldEnum)[keyof typeof CustomerOrderByRelevanceFieldEnum]


  export const FollowupOrderByRelevanceFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    StartDate: 'StartDate',
    StatusType: 'StatusType',
    FollowupNextDate: 'FollowupNextDate',
    Description: 'Description',
    contactId: 'contactId'
  };

  export type FollowupOrderByRelevanceFieldEnum = (typeof FollowupOrderByRelevanceFieldEnum)[keyof typeof FollowupOrderByRelevanceFieldEnum]


  export const ContactOrderByRelevanceFieldEnum: {
    id: 'id',
    Campaign: 'Campaign',
    Range: 'Range',
    ContactNo: 'ContactNo',
    Location: 'Location',
    ContactType: 'ContactType',
    Name: 'Name',
    City: 'City',
    Address: 'Address',
    ContactIndustry: 'ContactIndustry',
    ContactFunctionalArea: 'ContactFunctionalArea',
    ReferenceId: 'ReferenceId',
    Notes: 'Notes',
    Facilities: 'Facilities',
    date: 'date',
    Email: 'Email',
    CompanyName: 'CompanyName',
    Website: 'Website',
    Status: 'Status',
    Qualifications: 'Qualifications',
    AssignToId: 'AssignToId'
  };

  export type ContactOrderByRelevanceFieldEnum = (typeof ContactOrderByRelevanceFieldEnum)[keyof typeof ContactOrderByRelevanceFieldEnum]


  export const ContactFollowupOrderByRelevanceFieldEnum: {
    id: 'id',
    contactId: 'contactId',
    StartDate: 'StartDate',
    StatusType: 'StatusType',
    FollowupNextDate: 'FollowupNextDate',
    Description: 'Description'
  };

  export type ContactFollowupOrderByRelevanceFieldEnum = (typeof ContactFollowupOrderByRelevanceFieldEnum)[keyof typeof ContactFollowupOrderByRelevanceFieldEnum]


  export const RequestUserOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password'
  };

  export type RequestUserOrderByRelevanceFieldEnum = (typeof RequestUserOrderByRelevanceFieldEnum)[keyof typeof RequestUserOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'AdminStatus'
   */
  export type EnumAdminStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminStatus'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Status'
   */
  export type EnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    
  /**
   * Deep Input Types
   */


  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: StringFilter<"Admin"> | string
    name?: StringFilter<"Admin"> | string
    email?: StringFilter<"Admin"> | string
    password?: StringFilter<"Admin"> | string
    role?: EnumRoleFilter<"Admin"> | $Enums.Role
    city?: StringNullableFilter<"Admin"> | string | null
    phone?: StringNullableFilter<"Admin"> | string | null
    status?: EnumAdminStatusFilter<"Admin"> | $Enums.AdminStatus
    AddressLine1?: StringNullableFilter<"Admin"> | string | null
    AddressLine2?: StringNullableFilter<"Admin"> | string | null
    createdBy?: StringNullableFilter<"Admin"> | string | null
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    createdByRef?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    createdAdmins?: AdminListRelationFilter
    assignedCustomers?: CustomerListRelationFilter
    createdCustomers?: CustomerListRelationFilter
    assignedContact?: ContactListRelationFilter
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    city?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    status?: SortOrder
    AddressLine1?: SortOrderInput | SortOrder
    AddressLine2?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdByRef?: AdminOrderByWithRelationInput
    createdAdmins?: AdminOrderByRelationAggregateInput
    assignedCustomers?: CustomerOrderByRelationAggregateInput
    createdCustomers?: CustomerOrderByRelationAggregateInput
    assignedContact?: ContactOrderByRelationAggregateInput
    _relevance?: AdminOrderByRelevanceInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    name?: StringFilter<"Admin"> | string
    password?: StringFilter<"Admin"> | string
    role?: EnumRoleFilter<"Admin"> | $Enums.Role
    city?: StringNullableFilter<"Admin"> | string | null
    phone?: StringNullableFilter<"Admin"> | string | null
    status?: EnumAdminStatusFilter<"Admin"> | $Enums.AdminStatus
    AddressLine1?: StringNullableFilter<"Admin"> | string | null
    AddressLine2?: StringNullableFilter<"Admin"> | string | null
    createdBy?: StringNullableFilter<"Admin"> | string | null
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    createdByRef?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    createdAdmins?: AdminListRelationFilter
    assignedCustomers?: CustomerListRelationFilter
    createdCustomers?: CustomerListRelationFilter
    assignedContact?: ContactListRelationFilter
  }, "id" | "email">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    city?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    status?: SortOrder
    AddressLine1?: SortOrderInput | SortOrder
    AddressLine2?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Admin"> | string
    name?: StringWithAggregatesFilter<"Admin"> | string
    email?: StringWithAggregatesFilter<"Admin"> | string
    password?: StringWithAggregatesFilter<"Admin"> | string
    role?: EnumRoleWithAggregatesFilter<"Admin"> | $Enums.Role
    city?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    status?: EnumAdminStatusWithAggregatesFilter<"Admin"> | $Enums.AdminStatus
    AddressLine1?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    AddressLine2?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
  }

  export type CampaignWhereInput = {
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    id?: StringFilter<"Campaign"> | string
    Name?: StringFilter<"Campaign"> | string
    Status?: EnumStatusFilter<"Campaign"> | $Enums.Status
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    types?: TypeListRelationFilter
    subTypes?: SubTypeListRelationFilter
  }

  export type CampaignOrderByWithRelationInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    types?: TypeOrderByRelationAggregateInput
    subTypes?: SubTypeOrderByRelationAggregateInput
    _relevance?: CampaignOrderByRelevanceInput
  }

  export type CampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    Name?: string
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    Status?: EnumStatusFilter<"Campaign"> | $Enums.Status
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    types?: TypeListRelationFilter
    subTypes?: SubTypeListRelationFilter
  }, "id" | "Name">

  export type CampaignOrderByWithAggregationInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CampaignCountOrderByAggregateInput
    _max?: CampaignMaxOrderByAggregateInput
    _min?: CampaignMinOrderByAggregateInput
  }

  export type CampaignScalarWhereWithAggregatesInput = {
    AND?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    OR?: CampaignScalarWhereWithAggregatesInput[]
    NOT?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Campaign"> | string
    Name?: StringWithAggregatesFilter<"Campaign"> | string
    Status?: EnumStatusWithAggregatesFilter<"Campaign"> | $Enums.Status
    createdAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
  }

  export type TypeWhereInput = {
    AND?: TypeWhereInput | TypeWhereInput[]
    OR?: TypeWhereInput[]
    NOT?: TypeWhereInput | TypeWhereInput[]
    id?: StringFilter<"Type"> | string
    Name?: StringFilter<"Type"> | string
    Status?: EnumStatusFilter<"Type"> | $Enums.Status
    campaignId?: StringFilter<"Type"> | string
    createdAt?: DateTimeFilter<"Type"> | Date | string
    updatedAt?: DateTimeFilter<"Type"> | Date | string
    Campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    subTypes?: SubTypeListRelationFilter
  }

  export type TypeOrderByWithRelationInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    campaignId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Campaign?: CampaignOrderByWithRelationInput
    subTypes?: SubTypeOrderByRelationAggregateInput
    _relevance?: TypeOrderByRelevanceInput
  }

  export type TypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TypeWhereInput | TypeWhereInput[]
    OR?: TypeWhereInput[]
    NOT?: TypeWhereInput | TypeWhereInput[]
    Name?: StringFilter<"Type"> | string
    Status?: EnumStatusFilter<"Type"> | $Enums.Status
    campaignId?: StringFilter<"Type"> | string
    createdAt?: DateTimeFilter<"Type"> | Date | string
    updatedAt?: DateTimeFilter<"Type"> | Date | string
    Campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    subTypes?: SubTypeListRelationFilter
  }, "id">

  export type TypeOrderByWithAggregationInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    campaignId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TypeCountOrderByAggregateInput
    _max?: TypeMaxOrderByAggregateInput
    _min?: TypeMinOrderByAggregateInput
  }

  export type TypeScalarWhereWithAggregatesInput = {
    AND?: TypeScalarWhereWithAggregatesInput | TypeScalarWhereWithAggregatesInput[]
    OR?: TypeScalarWhereWithAggregatesInput[]
    NOT?: TypeScalarWhereWithAggregatesInput | TypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Type"> | string
    Name?: StringWithAggregatesFilter<"Type"> | string
    Status?: EnumStatusWithAggregatesFilter<"Type"> | $Enums.Status
    campaignId?: StringWithAggregatesFilter<"Type"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Type"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Type"> | Date | string
  }

  export type SubTypeWhereInput = {
    AND?: SubTypeWhereInput | SubTypeWhereInput[]
    OR?: SubTypeWhereInput[]
    NOT?: SubTypeWhereInput | SubTypeWhereInput[]
    id?: StringFilter<"SubType"> | string
    Name?: StringFilter<"SubType"> | string
    Status?: StringFilter<"SubType"> | string
    createdAt?: DateTimeFilter<"SubType"> | Date | string
    updatedAt?: DateTimeFilter<"SubType"> | Date | string
    campaignId?: StringFilter<"SubType"> | string
    customerTypeId?: StringFilter<"SubType"> | string
    Campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    CustomerType?: XOR<TypeScalarRelationFilter, TypeWhereInput>
  }

  export type SubTypeOrderByWithRelationInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaignId?: SortOrder
    customerTypeId?: SortOrder
    Campaign?: CampaignOrderByWithRelationInput
    CustomerType?: TypeOrderByWithRelationInput
    _relevance?: SubTypeOrderByRelevanceInput
  }

  export type SubTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubTypeWhereInput | SubTypeWhereInput[]
    OR?: SubTypeWhereInput[]
    NOT?: SubTypeWhereInput | SubTypeWhereInput[]
    Name?: StringFilter<"SubType"> | string
    Status?: StringFilter<"SubType"> | string
    createdAt?: DateTimeFilter<"SubType"> | Date | string
    updatedAt?: DateTimeFilter<"SubType"> | Date | string
    campaignId?: StringFilter<"SubType"> | string
    customerTypeId?: StringFilter<"SubType"> | string
    Campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    CustomerType?: XOR<TypeScalarRelationFilter, TypeWhereInput>
  }, "id">

  export type SubTypeOrderByWithAggregationInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaignId?: SortOrder
    customerTypeId?: SortOrder
    _count?: SubTypeCountOrderByAggregateInput
    _max?: SubTypeMaxOrderByAggregateInput
    _min?: SubTypeMinOrderByAggregateInput
  }

  export type SubTypeScalarWhereWithAggregatesInput = {
    AND?: SubTypeScalarWhereWithAggregatesInput | SubTypeScalarWhereWithAggregatesInput[]
    OR?: SubTypeScalarWhereWithAggregatesInput[]
    NOT?: SubTypeScalarWhereWithAggregatesInput | SubTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubType"> | string
    Name?: StringWithAggregatesFilter<"SubType"> | string
    Status?: StringWithAggregatesFilter<"SubType"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SubType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SubType"> | Date | string
    campaignId?: StringWithAggregatesFilter<"SubType"> | string
    customerTypeId?: StringWithAggregatesFilter<"SubType"> | string
  }

  export type ContactCampaignWhereInput = {
    AND?: ContactCampaignWhereInput | ContactCampaignWhereInput[]
    OR?: ContactCampaignWhereInput[]
    NOT?: ContactCampaignWhereInput | ContactCampaignWhereInput[]
    id?: StringFilter<"ContactCampaign"> | string
    Name?: StringFilter<"ContactCampaign"> | string
    Status?: EnumStatusFilter<"ContactCampaign"> | $Enums.Status
    createdAt?: DateTimeFilter<"ContactCampaign"> | Date | string
    updatedAt?: DateTimeFilter<"ContactCampaign"> | Date | string
    contactTypes?: ContactTypeListRelationFilter
  }

  export type ContactCampaignOrderByWithRelationInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contactTypes?: ContactTypeOrderByRelationAggregateInput
    _relevance?: ContactCampaignOrderByRelevanceInput
  }

  export type ContactCampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    Name?: string
    AND?: ContactCampaignWhereInput | ContactCampaignWhereInput[]
    OR?: ContactCampaignWhereInput[]
    NOT?: ContactCampaignWhereInput | ContactCampaignWhereInput[]
    Status?: EnumStatusFilter<"ContactCampaign"> | $Enums.Status
    createdAt?: DateTimeFilter<"ContactCampaign"> | Date | string
    updatedAt?: DateTimeFilter<"ContactCampaign"> | Date | string
    contactTypes?: ContactTypeListRelationFilter
  }, "id" | "Name">

  export type ContactCampaignOrderByWithAggregationInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactCampaignCountOrderByAggregateInput
    _max?: ContactCampaignMaxOrderByAggregateInput
    _min?: ContactCampaignMinOrderByAggregateInput
  }

  export type ContactCampaignScalarWhereWithAggregatesInput = {
    AND?: ContactCampaignScalarWhereWithAggregatesInput | ContactCampaignScalarWhereWithAggregatesInput[]
    OR?: ContactCampaignScalarWhereWithAggregatesInput[]
    NOT?: ContactCampaignScalarWhereWithAggregatesInput | ContactCampaignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContactCampaign"> | string
    Name?: StringWithAggregatesFilter<"ContactCampaign"> | string
    Status?: EnumStatusWithAggregatesFilter<"ContactCampaign"> | $Enums.Status
    createdAt?: DateTimeWithAggregatesFilter<"ContactCampaign"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContactCampaign"> | Date | string
  }

  export type ContactTypeWhereInput = {
    AND?: ContactTypeWhereInput | ContactTypeWhereInput[]
    OR?: ContactTypeWhereInput[]
    NOT?: ContactTypeWhereInput | ContactTypeWhereInput[]
    id?: StringFilter<"ContactType"> | string
    Name?: StringFilter<"ContactType"> | string
    Status?: EnumStatusFilter<"ContactType"> | $Enums.Status
    createdAt?: DateTimeFilter<"ContactType"> | Date | string
    updatedAt?: DateTimeFilter<"ContactType"> | Date | string
    campaignId?: StringFilter<"ContactType"> | string
    Campaign?: XOR<ContactCampaignScalarRelationFilter, ContactCampaignWhereInput>
  }

  export type ContactTypeOrderByWithRelationInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaignId?: SortOrder
    Campaign?: ContactCampaignOrderByWithRelationInput
    _relevance?: ContactTypeOrderByRelevanceInput
  }

  export type ContactTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactTypeWhereInput | ContactTypeWhereInput[]
    OR?: ContactTypeWhereInput[]
    NOT?: ContactTypeWhereInput | ContactTypeWhereInput[]
    Name?: StringFilter<"ContactType"> | string
    Status?: EnumStatusFilter<"ContactType"> | $Enums.Status
    createdAt?: DateTimeFilter<"ContactType"> | Date | string
    updatedAt?: DateTimeFilter<"ContactType"> | Date | string
    campaignId?: StringFilter<"ContactType"> | string
    Campaign?: XOR<ContactCampaignScalarRelationFilter, ContactCampaignWhereInput>
  }, "id">

  export type ContactTypeOrderByWithAggregationInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaignId?: SortOrder
    _count?: ContactTypeCountOrderByAggregateInput
    _max?: ContactTypeMaxOrderByAggregateInput
    _min?: ContactTypeMinOrderByAggregateInput
  }

  export type ContactTypeScalarWhereWithAggregatesInput = {
    AND?: ContactTypeScalarWhereWithAggregatesInput | ContactTypeScalarWhereWithAggregatesInput[]
    OR?: ContactTypeScalarWhereWithAggregatesInput[]
    NOT?: ContactTypeScalarWhereWithAggregatesInput | ContactTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContactType"> | string
    Name?: StringWithAggregatesFilter<"ContactType"> | string
    Status?: EnumStatusWithAggregatesFilter<"ContactType"> | $Enums.Status
    createdAt?: DateTimeWithAggregatesFilter<"ContactType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContactType"> | Date | string
    campaignId?: StringWithAggregatesFilter<"ContactType"> | string
  }

  export type CityWhereInput = {
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    id?: StringFilter<"City"> | string
    Name?: StringFilter<"City"> | string
    Status?: StringFilter<"City"> | string
    createdAt?: DateTimeFilter<"City"> | Date | string
    updatedAt?: DateTimeFilter<"City"> | Date | string
    locations?: LocationListRelationFilter
  }

  export type CityOrderByWithRelationInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    locations?: LocationOrderByRelationAggregateInput
    _relevance?: CityOrderByRelevanceInput
  }

  export type CityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    Name?: StringFilter<"City"> | string
    Status?: StringFilter<"City"> | string
    createdAt?: DateTimeFilter<"City"> | Date | string
    updatedAt?: DateTimeFilter<"City"> | Date | string
    locations?: LocationListRelationFilter
  }, "id">

  export type CityOrderByWithAggregationInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CityCountOrderByAggregateInput
    _max?: CityMaxOrderByAggregateInput
    _min?: CityMinOrderByAggregateInput
  }

  export type CityScalarWhereWithAggregatesInput = {
    AND?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    OR?: CityScalarWhereWithAggregatesInput[]
    NOT?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"City"> | string
    Name?: StringWithAggregatesFilter<"City"> | string
    Status?: StringWithAggregatesFilter<"City"> | string
    createdAt?: DateTimeWithAggregatesFilter<"City"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"City"> | Date | string
  }

  export type LocationWhereInput = {
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    id?: StringFilter<"Location"> | string
    Name?: StringFilter<"Location"> | string
    Status?: StringFilter<"Location"> | string
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    cityId?: StringFilter<"Location"> | string
    City?: XOR<CityScalarRelationFilter, CityWhereInput>
  }

  export type LocationOrderByWithRelationInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cityId?: SortOrder
    City?: CityOrderByWithRelationInput
    _relevance?: LocationOrderByRelevanceInput
  }

  export type LocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    Name?: StringFilter<"Location"> | string
    Status?: StringFilter<"Location"> | string
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    cityId?: StringFilter<"Location"> | string
    City?: XOR<CityScalarRelationFilter, CityWhereInput>
  }, "id">

  export type LocationOrderByWithAggregationInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cityId?: SortOrder
    _count?: LocationCountOrderByAggregateInput
    _max?: LocationMaxOrderByAggregateInput
    _min?: LocationMinOrderByAggregateInput
  }

  export type LocationScalarWhereWithAggregatesInput = {
    AND?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    OR?: LocationScalarWhereWithAggregatesInput[]
    NOT?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Location"> | string
    Name?: StringWithAggregatesFilter<"Location"> | string
    Status?: StringWithAggregatesFilter<"Location"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
    cityId?: StringWithAggregatesFilter<"Location"> | string
  }

  export type FacilityWhereInput = {
    AND?: FacilityWhereInput | FacilityWhereInput[]
    OR?: FacilityWhereInput[]
    NOT?: FacilityWhereInput | FacilityWhereInput[]
    id?: StringFilter<"Facility"> | string
    Name?: StringFilter<"Facility"> | string
    Status?: StringFilter<"Facility"> | string
    createdAt?: DateTimeFilter<"Facility"> | Date | string
    updatedAt?: DateTimeFilter<"Facility"> | Date | string
  }

  export type FacilityOrderByWithRelationInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: FacilityOrderByRelevanceInput
  }

  export type FacilityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FacilityWhereInput | FacilityWhereInput[]
    OR?: FacilityWhereInput[]
    NOT?: FacilityWhereInput | FacilityWhereInput[]
    Name?: StringFilter<"Facility"> | string
    Status?: StringFilter<"Facility"> | string
    createdAt?: DateTimeFilter<"Facility"> | Date | string
    updatedAt?: DateTimeFilter<"Facility"> | Date | string
  }, "id">

  export type FacilityOrderByWithAggregationInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FacilityCountOrderByAggregateInput
    _max?: FacilityMaxOrderByAggregateInput
    _min?: FacilityMinOrderByAggregateInput
  }

  export type FacilityScalarWhereWithAggregatesInput = {
    AND?: FacilityScalarWhereWithAggregatesInput | FacilityScalarWhereWithAggregatesInput[]
    OR?: FacilityScalarWhereWithAggregatesInput[]
    NOT?: FacilityScalarWhereWithAggregatesInput | FacilityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Facility"> | string
    Name?: StringWithAggregatesFilter<"Facility"> | string
    Status?: StringWithAggregatesFilter<"Facility"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Facility"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Facility"> | Date | string
  }

  export type AmenityWhereInput = {
    AND?: AmenityWhereInput | AmenityWhereInput[]
    OR?: AmenityWhereInput[]
    NOT?: AmenityWhereInput | AmenityWhereInput[]
    id?: StringFilter<"Amenity"> | string
    Name?: StringFilter<"Amenity"> | string
    Status?: StringFilter<"Amenity"> | string
    createdAt?: DateTimeFilter<"Amenity"> | Date | string
    updatedAt?: DateTimeFilter<"Amenity"> | Date | string
  }

  export type AmenityOrderByWithRelationInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: AmenityOrderByRelevanceInput
  }

  export type AmenityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AmenityWhereInput | AmenityWhereInput[]
    OR?: AmenityWhereInput[]
    NOT?: AmenityWhereInput | AmenityWhereInput[]
    Name?: StringFilter<"Amenity"> | string
    Status?: StringFilter<"Amenity"> | string
    createdAt?: DateTimeFilter<"Amenity"> | Date | string
    updatedAt?: DateTimeFilter<"Amenity"> | Date | string
  }, "id">

  export type AmenityOrderByWithAggregationInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AmenityCountOrderByAggregateInput
    _max?: AmenityMaxOrderByAggregateInput
    _min?: AmenityMinOrderByAggregateInput
  }

  export type AmenityScalarWhereWithAggregatesInput = {
    AND?: AmenityScalarWhereWithAggregatesInput | AmenityScalarWhereWithAggregatesInput[]
    OR?: AmenityScalarWhereWithAggregatesInput[]
    NOT?: AmenityScalarWhereWithAggregatesInput | AmenityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Amenity"> | string
    Name?: StringWithAggregatesFilter<"Amenity"> | string
    Status?: StringWithAggregatesFilter<"Amenity"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Amenity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Amenity"> | Date | string
  }

  export type FunctionalAreaWhereInput = {
    AND?: FunctionalAreaWhereInput | FunctionalAreaWhereInput[]
    OR?: FunctionalAreaWhereInput[]
    NOT?: FunctionalAreaWhereInput | FunctionalAreaWhereInput[]
    id?: StringFilter<"FunctionalArea"> | string
    Name?: StringFilter<"FunctionalArea"> | string
    Status?: StringFilter<"FunctionalArea"> | string
    createdAt?: DateTimeFilter<"FunctionalArea"> | Date | string
    updatedAt?: DateTimeFilter<"FunctionalArea"> | Date | string
  }

  export type FunctionalAreaOrderByWithRelationInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: FunctionalAreaOrderByRelevanceInput
  }

  export type FunctionalAreaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FunctionalAreaWhereInput | FunctionalAreaWhereInput[]
    OR?: FunctionalAreaWhereInput[]
    NOT?: FunctionalAreaWhereInput | FunctionalAreaWhereInput[]
    Name?: StringFilter<"FunctionalArea"> | string
    Status?: StringFilter<"FunctionalArea"> | string
    createdAt?: DateTimeFilter<"FunctionalArea"> | Date | string
    updatedAt?: DateTimeFilter<"FunctionalArea"> | Date | string
  }, "id">

  export type FunctionalAreaOrderByWithAggregationInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FunctionalAreaCountOrderByAggregateInput
    _max?: FunctionalAreaMaxOrderByAggregateInput
    _min?: FunctionalAreaMinOrderByAggregateInput
  }

  export type FunctionalAreaScalarWhereWithAggregatesInput = {
    AND?: FunctionalAreaScalarWhereWithAggregatesInput | FunctionalAreaScalarWhereWithAggregatesInput[]
    OR?: FunctionalAreaScalarWhereWithAggregatesInput[]
    NOT?: FunctionalAreaScalarWhereWithAggregatesInput | FunctionalAreaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FunctionalArea"> | string
    Name?: StringWithAggregatesFilter<"FunctionalArea"> | string
    Status?: StringWithAggregatesFilter<"FunctionalArea"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FunctionalArea"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FunctionalArea"> | Date | string
  }

  export type IndustryWhereInput = {
    AND?: IndustryWhereInput | IndustryWhereInput[]
    OR?: IndustryWhereInput[]
    NOT?: IndustryWhereInput | IndustryWhereInput[]
    id?: StringFilter<"Industry"> | string
    Name?: StringFilter<"Industry"> | string
    Status?: StringFilter<"Industry"> | string
    createdAt?: DateTimeFilter<"Industry"> | Date | string
    updatedAt?: DateTimeFilter<"Industry"> | Date | string
  }

  export type IndustryOrderByWithRelationInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: IndustryOrderByRelevanceInput
  }

  export type IndustryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IndustryWhereInput | IndustryWhereInput[]
    OR?: IndustryWhereInput[]
    NOT?: IndustryWhereInput | IndustryWhereInput[]
    Name?: StringFilter<"Industry"> | string
    Status?: StringFilter<"Industry"> | string
    createdAt?: DateTimeFilter<"Industry"> | Date | string
    updatedAt?: DateTimeFilter<"Industry"> | Date | string
  }, "id">

  export type IndustryOrderByWithAggregationInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IndustryCountOrderByAggregateInput
    _max?: IndustryMaxOrderByAggregateInput
    _min?: IndustryMinOrderByAggregateInput
  }

  export type IndustryScalarWhereWithAggregatesInput = {
    AND?: IndustryScalarWhereWithAggregatesInput | IndustryScalarWhereWithAggregatesInput[]
    OR?: IndustryScalarWhereWithAggregatesInput[]
    NOT?: IndustryScalarWhereWithAggregatesInput | IndustryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Industry"> | string
    Name?: StringWithAggregatesFilter<"Industry"> | string
    Status?: StringWithAggregatesFilter<"Industry"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Industry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Industry"> | Date | string
  }

  export type ReferenceWhereInput = {
    AND?: ReferenceWhereInput | ReferenceWhereInput[]
    OR?: ReferenceWhereInput[]
    NOT?: ReferenceWhereInput | ReferenceWhereInput[]
    id?: StringFilter<"Reference"> | string
    Name?: StringFilter<"Reference"> | string
    Status?: StringFilter<"Reference"> | string
    createdAt?: DateTimeFilter<"Reference"> | Date | string
    updatedAt?: DateTimeFilter<"Reference"> | Date | string
  }

  export type ReferenceOrderByWithRelationInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: ReferenceOrderByRelevanceInput
  }

  export type ReferenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReferenceWhereInput | ReferenceWhereInput[]
    OR?: ReferenceWhereInput[]
    NOT?: ReferenceWhereInput | ReferenceWhereInput[]
    Name?: StringFilter<"Reference"> | string
    Status?: StringFilter<"Reference"> | string
    createdAt?: DateTimeFilter<"Reference"> | Date | string
    updatedAt?: DateTimeFilter<"Reference"> | Date | string
  }, "id">

  export type ReferenceOrderByWithAggregationInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReferenceCountOrderByAggregateInput
    _max?: ReferenceMaxOrderByAggregateInput
    _min?: ReferenceMinOrderByAggregateInput
  }

  export type ReferenceScalarWhereWithAggregatesInput = {
    AND?: ReferenceScalarWhereWithAggregatesInput | ReferenceScalarWhereWithAggregatesInput[]
    OR?: ReferenceScalarWhereWithAggregatesInput[]
    NOT?: ReferenceScalarWhereWithAggregatesInput | ReferenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Reference"> | string
    Name?: StringWithAggregatesFilter<"Reference"> | string
    Status?: StringWithAggregatesFilter<"Reference"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Reference"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Reference"> | Date | string
  }

  export type ExpenseWhereInput = {
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    id?: StringFilter<"Expense"> | string
    Name?: StringFilter<"Expense"> | string
    Status?: StringFilter<"Expense"> | string
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
  }

  export type ExpenseOrderByWithRelationInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: ExpenseOrderByRelevanceInput
  }

  export type ExpenseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    Name?: StringFilter<"Expense"> | string
    Status?: StringFilter<"Expense"> | string
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
  }, "id">

  export type ExpenseOrderByWithAggregationInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExpenseCountOrderByAggregateInput
    _max?: ExpenseMaxOrderByAggregateInput
    _min?: ExpenseMinOrderByAggregateInput
  }

  export type ExpenseScalarWhereWithAggregatesInput = {
    AND?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    OR?: ExpenseScalarWhereWithAggregatesInput[]
    NOT?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Expense"> | string
    Name?: StringWithAggregatesFilter<"Expense"> | string
    Status?: StringWithAggregatesFilter<"Expense"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
  }

  export type IncomeWhereInput = {
    AND?: IncomeWhereInput | IncomeWhereInput[]
    OR?: IncomeWhereInput[]
    NOT?: IncomeWhereInput | IncomeWhereInput[]
    id?: StringFilter<"Income"> | string
    Name?: StringFilter<"Income"> | string
    Status?: StringFilter<"Income"> | string
    createdAt?: DateTimeFilter<"Income"> | Date | string
    updatedAt?: DateTimeFilter<"Income"> | Date | string
  }

  export type IncomeOrderByWithRelationInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: IncomeOrderByRelevanceInput
  }

  export type IncomeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IncomeWhereInput | IncomeWhereInput[]
    OR?: IncomeWhereInput[]
    NOT?: IncomeWhereInput | IncomeWhereInput[]
    Name?: StringFilter<"Income"> | string
    Status?: StringFilter<"Income"> | string
    createdAt?: DateTimeFilter<"Income"> | Date | string
    updatedAt?: DateTimeFilter<"Income"> | Date | string
  }, "id">

  export type IncomeOrderByWithAggregationInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IncomeCountOrderByAggregateInput
    _max?: IncomeMaxOrderByAggregateInput
    _min?: IncomeMinOrderByAggregateInput
  }

  export type IncomeScalarWhereWithAggregatesInput = {
    AND?: IncomeScalarWhereWithAggregatesInput | IncomeScalarWhereWithAggregatesInput[]
    OR?: IncomeScalarWhereWithAggregatesInput[]
    NOT?: IncomeScalarWhereWithAggregatesInput | IncomeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Income"> | string
    Name?: StringWithAggregatesFilter<"Income"> | string
    Status?: StringWithAggregatesFilter<"Income"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Income"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Income"> | Date | string
  }

  export type StatusTypeWhereInput = {
    AND?: StatusTypeWhereInput | StatusTypeWhereInput[]
    OR?: StatusTypeWhereInput[]
    NOT?: StatusTypeWhereInput | StatusTypeWhereInput[]
    id?: StringFilter<"StatusType"> | string
    Name?: StringFilter<"StatusType"> | string
    Status?: StringFilter<"StatusType"> | string
    createdAt?: DateTimeFilter<"StatusType"> | Date | string
    updatedAt?: DateTimeFilter<"StatusType"> | Date | string
  }

  export type StatusTypeOrderByWithRelationInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: StatusTypeOrderByRelevanceInput
  }

  export type StatusTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StatusTypeWhereInput | StatusTypeWhereInput[]
    OR?: StatusTypeWhereInput[]
    NOT?: StatusTypeWhereInput | StatusTypeWhereInput[]
    Name?: StringFilter<"StatusType"> | string
    Status?: StringFilter<"StatusType"> | string
    createdAt?: DateTimeFilter<"StatusType"> | Date | string
    updatedAt?: DateTimeFilter<"StatusType"> | Date | string
  }, "id">

  export type StatusTypeOrderByWithAggregationInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StatusTypeCountOrderByAggregateInput
    _max?: StatusTypeMaxOrderByAggregateInput
    _min?: StatusTypeMinOrderByAggregateInput
  }

  export type StatusTypeScalarWhereWithAggregatesInput = {
    AND?: StatusTypeScalarWhereWithAggregatesInput | StatusTypeScalarWhereWithAggregatesInput[]
    OR?: StatusTypeScalarWhereWithAggregatesInput[]
    NOT?: StatusTypeScalarWhereWithAggregatesInput | StatusTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StatusType"> | string
    Name?: StringWithAggregatesFilter<"StatusType"> | string
    Status?: StringWithAggregatesFilter<"StatusType"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StatusType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StatusType"> | Date | string
  }

  export type ContactStatusTypeWhereInput = {
    AND?: ContactStatusTypeWhereInput | ContactStatusTypeWhereInput[]
    OR?: ContactStatusTypeWhereInput[]
    NOT?: ContactStatusTypeWhereInput | ContactStatusTypeWhereInput[]
    id?: StringFilter<"ContactStatusType"> | string
    Name?: StringFilter<"ContactStatusType"> | string
    Status?: StringFilter<"ContactStatusType"> | string
    createdAt?: DateTimeFilter<"ContactStatusType"> | Date | string
    updatedAt?: DateTimeFilter<"ContactStatusType"> | Date | string
  }

  export type ContactStatusTypeOrderByWithRelationInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: ContactStatusTypeOrderByRelevanceInput
  }

  export type ContactStatusTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactStatusTypeWhereInput | ContactStatusTypeWhereInput[]
    OR?: ContactStatusTypeWhereInput[]
    NOT?: ContactStatusTypeWhereInput | ContactStatusTypeWhereInput[]
    Name?: StringFilter<"ContactStatusType"> | string
    Status?: StringFilter<"ContactStatusType"> | string
    createdAt?: DateTimeFilter<"ContactStatusType"> | Date | string
    updatedAt?: DateTimeFilter<"ContactStatusType"> | Date | string
  }, "id">

  export type ContactStatusTypeOrderByWithAggregationInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactStatusTypeCountOrderByAggregateInput
    _max?: ContactStatusTypeMaxOrderByAggregateInput
    _min?: ContactStatusTypeMinOrderByAggregateInput
  }

  export type ContactStatusTypeScalarWhereWithAggregatesInput = {
    AND?: ContactStatusTypeScalarWhereWithAggregatesInput | ContactStatusTypeScalarWhereWithAggregatesInput[]
    OR?: ContactStatusTypeScalarWhereWithAggregatesInput[]
    NOT?: ContactStatusTypeScalarWhereWithAggregatesInput | ContactStatusTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContactStatusType"> | string
    Name?: StringWithAggregatesFilter<"ContactStatusType"> | string
    Status?: StringWithAggregatesFilter<"ContactStatusType"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ContactStatusType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContactStatusType"> | Date | string
  }

  export type PaymentMethodWhereInput = {
    AND?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    OR?: PaymentMethodWhereInput[]
    NOT?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    id?: StringFilter<"PaymentMethod"> | string
    Name?: StringFilter<"PaymentMethod"> | string
    Status?: StringFilter<"PaymentMethod"> | string
    createdAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMethod"> | Date | string
  }

  export type PaymentMethodOrderByWithRelationInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: PaymentMethodOrderByRelevanceInput
  }

  export type PaymentMethodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    OR?: PaymentMethodWhereInput[]
    NOT?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    Name?: StringFilter<"PaymentMethod"> | string
    Status?: StringFilter<"PaymentMethod"> | string
    createdAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMethod"> | Date | string
  }, "id">

  export type PaymentMethodOrderByWithAggregationInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentMethodCountOrderByAggregateInput
    _max?: PaymentMethodMaxOrderByAggregateInput
    _min?: PaymentMethodMinOrderByAggregateInput
  }

  export type PaymentMethodScalarWhereWithAggregatesInput = {
    AND?: PaymentMethodScalarWhereWithAggregatesInput | PaymentMethodScalarWhereWithAggregatesInput[]
    OR?: PaymentMethodScalarWhereWithAggregatesInput[]
    NOT?: PaymentMethodScalarWhereWithAggregatesInput | PaymentMethodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentMethod"> | string
    Name?: StringWithAggregatesFilter<"PaymentMethod"> | string
    Status?: StringWithAggregatesFilter<"PaymentMethod"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentMethod"> | Date | string
  }

  export type TemplateWhereInput = {
    AND?: TemplateWhereInput | TemplateWhereInput[]
    OR?: TemplateWhereInput[]
    NOT?: TemplateWhereInput | TemplateWhereInput[]
    id?: StringFilter<"Template"> | string
    name?: StringFilter<"Template"> | string
    type?: StringFilter<"Template"> | string
    subject?: StringFilter<"Template"> | string
    body?: StringFilter<"Template"> | string
    description?: StringFilter<"Template"> | string
    whatsappImage?: JsonNullableFilter<"Template">
    createdBy?: StringFilter<"Template"> | string
    status?: StringFilter<"Template"> | string
    createdAt?: DateTimeFilter<"Template"> | Date | string
    updatedAt?: DateTimeFilter<"Template"> | Date | string
  }

  export type TemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    description?: SortOrder
    whatsappImage?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: TemplateOrderByRelevanceInput
  }

  export type TemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: TemplateWhereInput | TemplateWhereInput[]
    OR?: TemplateWhereInput[]
    NOT?: TemplateWhereInput | TemplateWhereInput[]
    type?: StringFilter<"Template"> | string
    subject?: StringFilter<"Template"> | string
    body?: StringFilter<"Template"> | string
    description?: StringFilter<"Template"> | string
    whatsappImage?: JsonNullableFilter<"Template">
    createdBy?: StringFilter<"Template"> | string
    status?: StringFilter<"Template"> | string
    createdAt?: DateTimeFilter<"Template"> | Date | string
    updatedAt?: DateTimeFilter<"Template"> | Date | string
  }, "id" | "name">

  export type TemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    description?: SortOrder
    whatsappImage?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TemplateCountOrderByAggregateInput
    _max?: TemplateMaxOrderByAggregateInput
    _min?: TemplateMinOrderByAggregateInput
  }

  export type TemplateScalarWhereWithAggregatesInput = {
    AND?: TemplateScalarWhereWithAggregatesInput | TemplateScalarWhereWithAggregatesInput[]
    OR?: TemplateScalarWhereWithAggregatesInput[]
    NOT?: TemplateScalarWhereWithAggregatesInput | TemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Template"> | string
    name?: StringWithAggregatesFilter<"Template"> | string
    type?: StringWithAggregatesFilter<"Template"> | string
    subject?: StringWithAggregatesFilter<"Template"> | string
    body?: StringWithAggregatesFilter<"Template"> | string
    description?: StringWithAggregatesFilter<"Template"> | string
    whatsappImage?: JsonNullableWithAggregatesFilter<"Template">
    createdBy?: StringWithAggregatesFilter<"Template"> | string
    status?: StringWithAggregatesFilter<"Template"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Template"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Template"> | Date | string
  }

  export type IncomeMarketingWhereInput = {
    AND?: IncomeMarketingWhereInput | IncomeMarketingWhereInput[]
    OR?: IncomeMarketingWhereInput[]
    NOT?: IncomeMarketingWhereInput | IncomeMarketingWhereInput[]
    id?: StringFilter<"IncomeMarketing"> | string
    Date?: StringNullableFilter<"IncomeMarketing"> | string | null
    PartyName?: StringNullableFilter<"IncomeMarketing"> | string | null
    User?: StringNullableFilter<"IncomeMarketing"> | string | null
    Income?: StringNullableFilter<"IncomeMarketing"> | string | null
    Amount?: StringNullableFilter<"IncomeMarketing"> | string | null
    DueAmount?: StringNullableFilter<"IncomeMarketing"> | string | null
    PaymentMethode?: StringNullableFilter<"IncomeMarketing"> | string | null
    Status?: StringFilter<"IncomeMarketing"> | string
    createdAt?: DateTimeFilter<"IncomeMarketing"> | Date | string
    updatedAt?: DateTimeFilter<"IncomeMarketing"> | Date | string
  }

  export type IncomeMarketingOrderByWithRelationInput = {
    id?: SortOrder
    Date?: SortOrderInput | SortOrder
    PartyName?: SortOrderInput | SortOrder
    User?: SortOrderInput | SortOrder
    Income?: SortOrderInput | SortOrder
    Amount?: SortOrderInput | SortOrder
    DueAmount?: SortOrderInput | SortOrder
    PaymentMethode?: SortOrderInput | SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: IncomeMarketingOrderByRelevanceInput
  }

  export type IncomeMarketingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IncomeMarketingWhereInput | IncomeMarketingWhereInput[]
    OR?: IncomeMarketingWhereInput[]
    NOT?: IncomeMarketingWhereInput | IncomeMarketingWhereInput[]
    Date?: StringNullableFilter<"IncomeMarketing"> | string | null
    PartyName?: StringNullableFilter<"IncomeMarketing"> | string | null
    User?: StringNullableFilter<"IncomeMarketing"> | string | null
    Income?: StringNullableFilter<"IncomeMarketing"> | string | null
    Amount?: StringNullableFilter<"IncomeMarketing"> | string | null
    DueAmount?: StringNullableFilter<"IncomeMarketing"> | string | null
    PaymentMethode?: StringNullableFilter<"IncomeMarketing"> | string | null
    Status?: StringFilter<"IncomeMarketing"> | string
    createdAt?: DateTimeFilter<"IncomeMarketing"> | Date | string
    updatedAt?: DateTimeFilter<"IncomeMarketing"> | Date | string
  }, "id">

  export type IncomeMarketingOrderByWithAggregationInput = {
    id?: SortOrder
    Date?: SortOrderInput | SortOrder
    PartyName?: SortOrderInput | SortOrder
    User?: SortOrderInput | SortOrder
    Income?: SortOrderInput | SortOrder
    Amount?: SortOrderInput | SortOrder
    DueAmount?: SortOrderInput | SortOrder
    PaymentMethode?: SortOrderInput | SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IncomeMarketingCountOrderByAggregateInput
    _max?: IncomeMarketingMaxOrderByAggregateInput
    _min?: IncomeMarketingMinOrderByAggregateInput
  }

  export type IncomeMarketingScalarWhereWithAggregatesInput = {
    AND?: IncomeMarketingScalarWhereWithAggregatesInput | IncomeMarketingScalarWhereWithAggregatesInput[]
    OR?: IncomeMarketingScalarWhereWithAggregatesInput[]
    NOT?: IncomeMarketingScalarWhereWithAggregatesInput | IncomeMarketingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IncomeMarketing"> | string
    Date?: StringNullableWithAggregatesFilter<"IncomeMarketing"> | string | null
    PartyName?: StringNullableWithAggregatesFilter<"IncomeMarketing"> | string | null
    User?: StringNullableWithAggregatesFilter<"IncomeMarketing"> | string | null
    Income?: StringNullableWithAggregatesFilter<"IncomeMarketing"> | string | null
    Amount?: StringNullableWithAggregatesFilter<"IncomeMarketing"> | string | null
    DueAmount?: StringNullableWithAggregatesFilter<"IncomeMarketing"> | string | null
    PaymentMethode?: StringNullableWithAggregatesFilter<"IncomeMarketing"> | string | null
    Status?: StringWithAggregatesFilter<"IncomeMarketing"> | string
    createdAt?: DateTimeWithAggregatesFilter<"IncomeMarketing"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"IncomeMarketing"> | Date | string
  }

  export type ExpenseMarketingWhereInput = {
    AND?: ExpenseMarketingWhereInput | ExpenseMarketingWhereInput[]
    OR?: ExpenseMarketingWhereInput[]
    NOT?: ExpenseMarketingWhereInput | ExpenseMarketingWhereInput[]
    id?: StringFilter<"ExpenseMarketing"> | string
    Date?: StringNullableFilter<"ExpenseMarketing"> | string | null
    PartyName?: StringNullableFilter<"ExpenseMarketing"> | string | null
    User?: StringNullableFilter<"ExpenseMarketing"> | string | null
    Expense?: StringNullableFilter<"ExpenseMarketing"> | string | null
    Amount?: StringNullableFilter<"ExpenseMarketing"> | string | null
    DueAmount?: StringNullableFilter<"ExpenseMarketing"> | string | null
    PaymentMethode?: StringNullableFilter<"ExpenseMarketing"> | string | null
    Status?: StringFilter<"ExpenseMarketing"> | string
    createdAt?: DateTimeFilter<"ExpenseMarketing"> | Date | string
    updatedAt?: DateTimeFilter<"ExpenseMarketing"> | Date | string
  }

  export type ExpenseMarketingOrderByWithRelationInput = {
    id?: SortOrder
    Date?: SortOrderInput | SortOrder
    PartyName?: SortOrderInput | SortOrder
    User?: SortOrderInput | SortOrder
    Expense?: SortOrderInput | SortOrder
    Amount?: SortOrderInput | SortOrder
    DueAmount?: SortOrderInput | SortOrder
    PaymentMethode?: SortOrderInput | SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: ExpenseMarketingOrderByRelevanceInput
  }

  export type ExpenseMarketingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExpenseMarketingWhereInput | ExpenseMarketingWhereInput[]
    OR?: ExpenseMarketingWhereInput[]
    NOT?: ExpenseMarketingWhereInput | ExpenseMarketingWhereInput[]
    Date?: StringNullableFilter<"ExpenseMarketing"> | string | null
    PartyName?: StringNullableFilter<"ExpenseMarketing"> | string | null
    User?: StringNullableFilter<"ExpenseMarketing"> | string | null
    Expense?: StringNullableFilter<"ExpenseMarketing"> | string | null
    Amount?: StringNullableFilter<"ExpenseMarketing"> | string | null
    DueAmount?: StringNullableFilter<"ExpenseMarketing"> | string | null
    PaymentMethode?: StringNullableFilter<"ExpenseMarketing"> | string | null
    Status?: StringFilter<"ExpenseMarketing"> | string
    createdAt?: DateTimeFilter<"ExpenseMarketing"> | Date | string
    updatedAt?: DateTimeFilter<"ExpenseMarketing"> | Date | string
  }, "id">

  export type ExpenseMarketingOrderByWithAggregationInput = {
    id?: SortOrder
    Date?: SortOrderInput | SortOrder
    PartyName?: SortOrderInput | SortOrder
    User?: SortOrderInput | SortOrder
    Expense?: SortOrderInput | SortOrder
    Amount?: SortOrderInput | SortOrder
    DueAmount?: SortOrderInput | SortOrder
    PaymentMethode?: SortOrderInput | SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExpenseMarketingCountOrderByAggregateInput
    _max?: ExpenseMarketingMaxOrderByAggregateInput
    _min?: ExpenseMarketingMinOrderByAggregateInput
  }

  export type ExpenseMarketingScalarWhereWithAggregatesInput = {
    AND?: ExpenseMarketingScalarWhereWithAggregatesInput | ExpenseMarketingScalarWhereWithAggregatesInput[]
    OR?: ExpenseMarketingScalarWhereWithAggregatesInput[]
    NOT?: ExpenseMarketingScalarWhereWithAggregatesInput | ExpenseMarketingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExpenseMarketing"> | string
    Date?: StringNullableWithAggregatesFilter<"ExpenseMarketing"> | string | null
    PartyName?: StringNullableWithAggregatesFilter<"ExpenseMarketing"> | string | null
    User?: StringNullableWithAggregatesFilter<"ExpenseMarketing"> | string | null
    Expense?: StringNullableWithAggregatesFilter<"ExpenseMarketing"> | string | null
    Amount?: StringNullableWithAggregatesFilter<"ExpenseMarketing"> | string | null
    DueAmount?: StringNullableWithAggregatesFilter<"ExpenseMarketing"> | string | null
    PaymentMethode?: StringNullableWithAggregatesFilter<"ExpenseMarketing"> | string | null
    Status?: StringWithAggregatesFilter<"ExpenseMarketing"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ExpenseMarketing"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExpenseMarketing"> | Date | string
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: StringFilter<"Task"> | string
    date?: StringNullableFilter<"Task"> | string | null
    Time?: StringNullableFilter<"Task"> | string | null
    Description?: StringNullableFilter<"Task"> | string | null
    User?: StringNullableFilter<"Task"> | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrderInput | SortOrder
    Time?: SortOrderInput | SortOrder
    Description?: SortOrderInput | SortOrder
    User?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: TaskOrderByRelevanceInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    date?: StringNullableFilter<"Task"> | string | null
    Time?: StringNullableFilter<"Task"> | string | null
    Description?: StringNullableFilter<"Task"> | string | null
    User?: StringNullableFilter<"Task"> | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
  }, "id">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrderInput | SortOrder
    Time?: SortOrderInput | SortOrder
    Description?: SortOrderInput | SortOrder
    User?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TaskCountOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Task"> | string
    date?: StringNullableWithAggregatesFilter<"Task"> | string | null
    Time?: StringNullableWithAggregatesFilter<"Task"> | string | null
    Description?: StringNullableWithAggregatesFilter<"Task"> | string | null
    User?: StringNullableWithAggregatesFilter<"Task"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
  }

  export type ScheduleWhereInput = {
    AND?: ScheduleWhereInput | ScheduleWhereInput[]
    OR?: ScheduleWhereInput[]
    NOT?: ScheduleWhereInput | ScheduleWhereInput[]
    id?: StringFilter<"Schedule"> | string
    date?: StringNullableFilter<"Schedule"> | string | null
    Time?: StringNullableFilter<"Schedule"> | string | null
    Description?: StringNullableFilter<"Schedule"> | string | null
    User?: StringNullableFilter<"Schedule"> | string | null
    createdAt?: DateTimeFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string
  }

  export type ScheduleOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrderInput | SortOrder
    Time?: SortOrderInput | SortOrder
    Description?: SortOrderInput | SortOrder
    User?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: ScheduleOrderByRelevanceInput
  }

  export type ScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScheduleWhereInput | ScheduleWhereInput[]
    OR?: ScheduleWhereInput[]
    NOT?: ScheduleWhereInput | ScheduleWhereInput[]
    date?: StringNullableFilter<"Schedule"> | string | null
    Time?: StringNullableFilter<"Schedule"> | string | null
    Description?: StringNullableFilter<"Schedule"> | string | null
    User?: StringNullableFilter<"Schedule"> | string | null
    createdAt?: DateTimeFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string
  }, "id">

  export type ScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrderInput | SortOrder
    Time?: SortOrderInput | SortOrder
    Description?: SortOrderInput | SortOrder
    User?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ScheduleCountOrderByAggregateInput
    _max?: ScheduleMaxOrderByAggregateInput
    _min?: ScheduleMinOrderByAggregateInput
  }

  export type ScheduleScalarWhereWithAggregatesInput = {
    AND?: ScheduleScalarWhereWithAggregatesInput | ScheduleScalarWhereWithAggregatesInput[]
    OR?: ScheduleScalarWhereWithAggregatesInput[]
    NOT?: ScheduleScalarWhereWithAggregatesInput | ScheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Schedule"> | string
    date?: StringNullableWithAggregatesFilter<"Schedule"> | string | null
    Time?: StringNullableWithAggregatesFilter<"Schedule"> | string | null
    Description?: StringNullableWithAggregatesFilter<"Schedule"> | string | null
    User?: StringNullableWithAggregatesFilter<"Schedule"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
  }

  export type CompanyProjectWhereInput = {
    AND?: CompanyProjectWhereInput | CompanyProjectWhereInput[]
    OR?: CompanyProjectWhereInput[]
    NOT?: CompanyProjectWhereInput | CompanyProjectWhereInput[]
    id?: StringFilter<"CompanyProject"> | string
    ProjectName?: StringFilter<"CompanyProject"> | string
    ProjectType?: StringNullableFilter<"CompanyProject"> | string | null
    ProjectStatus?: StringNullableFilter<"CompanyProject"> | string | null
    City?: StringNullableFilter<"CompanyProject"> | string | null
    Location?: StringNullableFilter<"CompanyProject"> | string | null
    Area?: StringNullableFilter<"CompanyProject"> | string | null
    Range?: StringNullableFilter<"CompanyProject"> | string | null
    Adderess?: StringNullableFilter<"CompanyProject"> | string | null
    Facillities?: StringNullableFilter<"CompanyProject"> | string | null
    Amenities?: StringNullableFilter<"CompanyProject"> | string | null
    Description?: StringNullableFilter<"CompanyProject"> | string | null
    Video?: StringNullableFilter<"CompanyProject"> | string | null
    GoogleMap?: StringNullableFilter<"CompanyProject"> | string | null
    CustomerImage?: JsonNullableFilter<"CompanyProject">
    SitePlan?: JsonNullableFilter<"CompanyProject">
    CreatedBy?: StringNullableFilter<"CompanyProject"> | string | null
    createdAt?: DateTimeFilter<"CompanyProject"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyProject"> | Date | string
  }

  export type CompanyProjectOrderByWithRelationInput = {
    id?: SortOrder
    ProjectName?: SortOrder
    ProjectType?: SortOrderInput | SortOrder
    ProjectStatus?: SortOrderInput | SortOrder
    City?: SortOrderInput | SortOrder
    Location?: SortOrderInput | SortOrder
    Area?: SortOrderInput | SortOrder
    Range?: SortOrderInput | SortOrder
    Adderess?: SortOrderInput | SortOrder
    Facillities?: SortOrderInput | SortOrder
    Amenities?: SortOrderInput | SortOrder
    Description?: SortOrderInput | SortOrder
    Video?: SortOrderInput | SortOrder
    GoogleMap?: SortOrderInput | SortOrder
    CustomerImage?: SortOrderInput | SortOrder
    SitePlan?: SortOrderInput | SortOrder
    CreatedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: CompanyProjectOrderByRelevanceInput
  }

  export type CompanyProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CompanyProjectWhereInput | CompanyProjectWhereInput[]
    OR?: CompanyProjectWhereInput[]
    NOT?: CompanyProjectWhereInput | CompanyProjectWhereInput[]
    ProjectName?: StringFilter<"CompanyProject"> | string
    ProjectType?: StringNullableFilter<"CompanyProject"> | string | null
    ProjectStatus?: StringNullableFilter<"CompanyProject"> | string | null
    City?: StringNullableFilter<"CompanyProject"> | string | null
    Location?: StringNullableFilter<"CompanyProject"> | string | null
    Area?: StringNullableFilter<"CompanyProject"> | string | null
    Range?: StringNullableFilter<"CompanyProject"> | string | null
    Adderess?: StringNullableFilter<"CompanyProject"> | string | null
    Facillities?: StringNullableFilter<"CompanyProject"> | string | null
    Amenities?: StringNullableFilter<"CompanyProject"> | string | null
    Description?: StringNullableFilter<"CompanyProject"> | string | null
    Video?: StringNullableFilter<"CompanyProject"> | string | null
    GoogleMap?: StringNullableFilter<"CompanyProject"> | string | null
    CustomerImage?: JsonNullableFilter<"CompanyProject">
    SitePlan?: JsonNullableFilter<"CompanyProject">
    CreatedBy?: StringNullableFilter<"CompanyProject"> | string | null
    createdAt?: DateTimeFilter<"CompanyProject"> | Date | string
    updatedAt?: DateTimeFilter<"CompanyProject"> | Date | string
  }, "id">

  export type CompanyProjectOrderByWithAggregationInput = {
    id?: SortOrder
    ProjectName?: SortOrder
    ProjectType?: SortOrderInput | SortOrder
    ProjectStatus?: SortOrderInput | SortOrder
    City?: SortOrderInput | SortOrder
    Location?: SortOrderInput | SortOrder
    Area?: SortOrderInput | SortOrder
    Range?: SortOrderInput | SortOrder
    Adderess?: SortOrderInput | SortOrder
    Facillities?: SortOrderInput | SortOrder
    Amenities?: SortOrderInput | SortOrder
    Description?: SortOrderInput | SortOrder
    Video?: SortOrderInput | SortOrder
    GoogleMap?: SortOrderInput | SortOrder
    CustomerImage?: SortOrderInput | SortOrder
    SitePlan?: SortOrderInput | SortOrder
    CreatedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyProjectCountOrderByAggregateInput
    _max?: CompanyProjectMaxOrderByAggregateInput
    _min?: CompanyProjectMinOrderByAggregateInput
  }

  export type CompanyProjectScalarWhereWithAggregatesInput = {
    AND?: CompanyProjectScalarWhereWithAggregatesInput | CompanyProjectScalarWhereWithAggregatesInput[]
    OR?: CompanyProjectScalarWhereWithAggregatesInput[]
    NOT?: CompanyProjectScalarWhereWithAggregatesInput | CompanyProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CompanyProject"> | string
    ProjectName?: StringWithAggregatesFilter<"CompanyProject"> | string
    ProjectType?: StringNullableWithAggregatesFilter<"CompanyProject"> | string | null
    ProjectStatus?: StringNullableWithAggregatesFilter<"CompanyProject"> | string | null
    City?: StringNullableWithAggregatesFilter<"CompanyProject"> | string | null
    Location?: StringNullableWithAggregatesFilter<"CompanyProject"> | string | null
    Area?: StringNullableWithAggregatesFilter<"CompanyProject"> | string | null
    Range?: StringNullableWithAggregatesFilter<"CompanyProject"> | string | null
    Adderess?: StringNullableWithAggregatesFilter<"CompanyProject"> | string | null
    Facillities?: StringNullableWithAggregatesFilter<"CompanyProject"> | string | null
    Amenities?: StringNullableWithAggregatesFilter<"CompanyProject"> | string | null
    Description?: StringNullableWithAggregatesFilter<"CompanyProject"> | string | null
    Video?: StringNullableWithAggregatesFilter<"CompanyProject"> | string | null
    GoogleMap?: StringNullableWithAggregatesFilter<"CompanyProject"> | string | null
    CustomerImage?: JsonNullableWithAggregatesFilter<"CompanyProject">
    SitePlan?: JsonNullableWithAggregatesFilter<"CompanyProject">
    CreatedBy?: StringNullableWithAggregatesFilter<"CompanyProject"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CompanyProject"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CompanyProject"> | Date | string
  }

  export type BuilderSliderWhereInput = {
    AND?: BuilderSliderWhereInput | BuilderSliderWhereInput[]
    OR?: BuilderSliderWhereInput[]
    NOT?: BuilderSliderWhereInput | BuilderSliderWhereInput[]
    id?: StringFilter<"BuilderSlider"> | string
    Image?: JsonNullableFilter<"BuilderSlider">
    Status?: StringFilter<"BuilderSlider"> | string
    createdAt?: DateTimeFilter<"BuilderSlider"> | Date | string
    updatedAt?: DateTimeFilter<"BuilderSlider"> | Date | string
  }

  export type BuilderSliderOrderByWithRelationInput = {
    id?: SortOrder
    Image?: SortOrderInput | SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: BuilderSliderOrderByRelevanceInput
  }

  export type BuilderSliderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BuilderSliderWhereInput | BuilderSliderWhereInput[]
    OR?: BuilderSliderWhereInput[]
    NOT?: BuilderSliderWhereInput | BuilderSliderWhereInput[]
    Image?: JsonNullableFilter<"BuilderSlider">
    Status?: StringFilter<"BuilderSlider"> | string
    createdAt?: DateTimeFilter<"BuilderSlider"> | Date | string
    updatedAt?: DateTimeFilter<"BuilderSlider"> | Date | string
  }, "id">

  export type BuilderSliderOrderByWithAggregationInput = {
    id?: SortOrder
    Image?: SortOrderInput | SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BuilderSliderCountOrderByAggregateInput
    _max?: BuilderSliderMaxOrderByAggregateInput
    _min?: BuilderSliderMinOrderByAggregateInput
  }

  export type BuilderSliderScalarWhereWithAggregatesInput = {
    AND?: BuilderSliderScalarWhereWithAggregatesInput | BuilderSliderScalarWhereWithAggregatesInput[]
    OR?: BuilderSliderScalarWhereWithAggregatesInput[]
    NOT?: BuilderSliderScalarWhereWithAggregatesInput | BuilderSliderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BuilderSlider"> | string
    Image?: JsonNullableWithAggregatesFilter<"BuilderSlider">
    Status?: StringWithAggregatesFilter<"BuilderSlider"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BuilderSlider"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BuilderSlider"> | Date | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    Campaign?: StringNullableFilter<"Customer"> | string | null
    CustomerType?: StringNullableFilter<"Customer"> | string | null
    CustomerSubType?: StringNullableFilter<"Customer"> | string | null
    customerName?: StringFilter<"Customer"> | string
    ContactNumber?: StringFilter<"Customer"> | string
    City?: StringNullableFilter<"Customer"> | string | null
    Location?: StringNullableFilter<"Customer"> | string | null
    Area?: StringNullableFilter<"Customer"> | string | null
    Adderess?: StringNullableFilter<"Customer"> | string | null
    Email?: StringNullableFilter<"Customer"> | string | null
    Facillities?: StringNullableFilter<"Customer"> | string | null
    ReferenceId?: StringNullableFilter<"Customer"> | string | null
    CustomerId?: StringNullableFilter<"Customer"> | string | null
    CustomerDate?: StringNullableFilter<"Customer"> | string | null
    CustomerYear?: StringNullableFilter<"Customer"> | string | null
    Other?: StringNullableFilter<"Customer"> | string | null
    Description?: StringNullableFilter<"Customer"> | string | null
    Video?: StringNullableFilter<"Customer"> | string | null
    Verified?: StringNullableFilter<"Customer"> | string | null
    GoogleMap?: StringNullableFilter<"Customer"> | string | null
    CustomerImage?: JsonNullableFilter<"Customer">
    SitePlan?: JsonNullableFilter<"Customer">
    isFavourite?: BoolFilter<"Customer"> | boolean
    AssignToId?: StringNullableFilter<"Customer"> | string | null
    CreatedById?: StringNullableFilter<"Customer"> | string | null
    isImported?: BoolFilter<"Customer"> | boolean
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    AssignTo?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    CreatedBy?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    followups?: FollowupListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    Campaign?: SortOrderInput | SortOrder
    CustomerType?: SortOrderInput | SortOrder
    CustomerSubType?: SortOrderInput | SortOrder
    customerName?: SortOrder
    ContactNumber?: SortOrder
    City?: SortOrderInput | SortOrder
    Location?: SortOrderInput | SortOrder
    Area?: SortOrderInput | SortOrder
    Adderess?: SortOrderInput | SortOrder
    Email?: SortOrderInput | SortOrder
    Facillities?: SortOrderInput | SortOrder
    ReferenceId?: SortOrderInput | SortOrder
    CustomerId?: SortOrderInput | SortOrder
    CustomerDate?: SortOrderInput | SortOrder
    CustomerYear?: SortOrderInput | SortOrder
    Other?: SortOrderInput | SortOrder
    Description?: SortOrderInput | SortOrder
    Video?: SortOrderInput | SortOrder
    Verified?: SortOrderInput | SortOrder
    GoogleMap?: SortOrderInput | SortOrder
    CustomerImage?: SortOrderInput | SortOrder
    SitePlan?: SortOrderInput | SortOrder
    isFavourite?: SortOrder
    AssignToId?: SortOrderInput | SortOrder
    CreatedById?: SortOrderInput | SortOrder
    isImported?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    AssignTo?: AdminOrderByWithRelationInput
    CreatedBy?: AdminOrderByWithRelationInput
    followups?: FollowupOrderByRelationAggregateInput
    _relevance?: CustomerOrderByRelevanceInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    Campaign?: StringNullableFilter<"Customer"> | string | null
    CustomerType?: StringNullableFilter<"Customer"> | string | null
    CustomerSubType?: StringNullableFilter<"Customer"> | string | null
    customerName?: StringFilter<"Customer"> | string
    ContactNumber?: StringFilter<"Customer"> | string
    City?: StringNullableFilter<"Customer"> | string | null
    Location?: StringNullableFilter<"Customer"> | string | null
    Area?: StringNullableFilter<"Customer"> | string | null
    Adderess?: StringNullableFilter<"Customer"> | string | null
    Email?: StringNullableFilter<"Customer"> | string | null
    Facillities?: StringNullableFilter<"Customer"> | string | null
    ReferenceId?: StringNullableFilter<"Customer"> | string | null
    CustomerId?: StringNullableFilter<"Customer"> | string | null
    CustomerDate?: StringNullableFilter<"Customer"> | string | null
    CustomerYear?: StringNullableFilter<"Customer"> | string | null
    Other?: StringNullableFilter<"Customer"> | string | null
    Description?: StringNullableFilter<"Customer"> | string | null
    Video?: StringNullableFilter<"Customer"> | string | null
    Verified?: StringNullableFilter<"Customer"> | string | null
    GoogleMap?: StringNullableFilter<"Customer"> | string | null
    CustomerImage?: JsonNullableFilter<"Customer">
    SitePlan?: JsonNullableFilter<"Customer">
    isFavourite?: BoolFilter<"Customer"> | boolean
    AssignToId?: StringNullableFilter<"Customer"> | string | null
    CreatedById?: StringNullableFilter<"Customer"> | string | null
    isImported?: BoolFilter<"Customer"> | boolean
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    AssignTo?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    CreatedBy?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    followups?: FollowupListRelationFilter
  }, "id">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    Campaign?: SortOrderInput | SortOrder
    CustomerType?: SortOrderInput | SortOrder
    CustomerSubType?: SortOrderInput | SortOrder
    customerName?: SortOrder
    ContactNumber?: SortOrder
    City?: SortOrderInput | SortOrder
    Location?: SortOrderInput | SortOrder
    Area?: SortOrderInput | SortOrder
    Adderess?: SortOrderInput | SortOrder
    Email?: SortOrderInput | SortOrder
    Facillities?: SortOrderInput | SortOrder
    ReferenceId?: SortOrderInput | SortOrder
    CustomerId?: SortOrderInput | SortOrder
    CustomerDate?: SortOrderInput | SortOrder
    CustomerYear?: SortOrderInput | SortOrder
    Other?: SortOrderInput | SortOrder
    Description?: SortOrderInput | SortOrder
    Video?: SortOrderInput | SortOrder
    Verified?: SortOrderInput | SortOrder
    GoogleMap?: SortOrderInput | SortOrder
    CustomerImage?: SortOrderInput | SortOrder
    SitePlan?: SortOrderInput | SortOrder
    isFavourite?: SortOrder
    AssignToId?: SortOrderInput | SortOrder
    CreatedById?: SortOrderInput | SortOrder
    isImported?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    Campaign?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    CustomerType?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    CustomerSubType?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    customerName?: StringWithAggregatesFilter<"Customer"> | string
    ContactNumber?: StringWithAggregatesFilter<"Customer"> | string
    City?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    Location?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    Area?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    Adderess?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    Email?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    Facillities?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    ReferenceId?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    CustomerId?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    CustomerDate?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    CustomerYear?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    Other?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    Description?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    Video?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    Verified?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    GoogleMap?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    CustomerImage?: JsonNullableWithAggregatesFilter<"Customer">
    SitePlan?: JsonNullableWithAggregatesFilter<"Customer">
    isFavourite?: BoolWithAggregatesFilter<"Customer"> | boolean
    AssignToId?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    CreatedById?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    isImported?: BoolWithAggregatesFilter<"Customer"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
  }

  export type FollowupWhereInput = {
    AND?: FollowupWhereInput | FollowupWhereInput[]
    OR?: FollowupWhereInput[]
    NOT?: FollowupWhereInput | FollowupWhereInput[]
    id?: StringFilter<"Followup"> | string
    customerId?: StringFilter<"Followup"> | string
    StartDate?: StringNullableFilter<"Followup"> | string | null
    StatusType?: StringNullableFilter<"Followup"> | string | null
    FollowupNextDate?: StringNullableFilter<"Followup"> | string | null
    Description?: StringNullableFilter<"Followup"> | string | null
    createdAt?: DateTimeFilter<"Followup"> | Date | string
    updatedAt?: DateTimeFilter<"Followup"> | Date | string
    contactId?: StringNullableFilter<"Followup"> | string | null
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
  }

  export type FollowupOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    StartDate?: SortOrderInput | SortOrder
    StatusType?: SortOrderInput | SortOrder
    FollowupNextDate?: SortOrderInput | SortOrder
    Description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contactId?: SortOrderInput | SortOrder
    customer?: CustomerOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
    _relevance?: FollowupOrderByRelevanceInput
  }

  export type FollowupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FollowupWhereInput | FollowupWhereInput[]
    OR?: FollowupWhereInput[]
    NOT?: FollowupWhereInput | FollowupWhereInput[]
    customerId?: StringFilter<"Followup"> | string
    StartDate?: StringNullableFilter<"Followup"> | string | null
    StatusType?: StringNullableFilter<"Followup"> | string | null
    FollowupNextDate?: StringNullableFilter<"Followup"> | string | null
    Description?: StringNullableFilter<"Followup"> | string | null
    createdAt?: DateTimeFilter<"Followup"> | Date | string
    updatedAt?: DateTimeFilter<"Followup"> | Date | string
    contactId?: StringNullableFilter<"Followup"> | string | null
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
  }, "id">

  export type FollowupOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    StartDate?: SortOrderInput | SortOrder
    StatusType?: SortOrderInput | SortOrder
    FollowupNextDate?: SortOrderInput | SortOrder
    Description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contactId?: SortOrderInput | SortOrder
    _count?: FollowupCountOrderByAggregateInput
    _max?: FollowupMaxOrderByAggregateInput
    _min?: FollowupMinOrderByAggregateInput
  }

  export type FollowupScalarWhereWithAggregatesInput = {
    AND?: FollowupScalarWhereWithAggregatesInput | FollowupScalarWhereWithAggregatesInput[]
    OR?: FollowupScalarWhereWithAggregatesInput[]
    NOT?: FollowupScalarWhereWithAggregatesInput | FollowupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Followup"> | string
    customerId?: StringWithAggregatesFilter<"Followup"> | string
    StartDate?: StringNullableWithAggregatesFilter<"Followup"> | string | null
    StatusType?: StringNullableWithAggregatesFilter<"Followup"> | string | null
    FollowupNextDate?: StringNullableWithAggregatesFilter<"Followup"> | string | null
    Description?: StringNullableWithAggregatesFilter<"Followup"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Followup"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Followup"> | Date | string
    contactId?: StringNullableWithAggregatesFilter<"Followup"> | string | null
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    id?: StringFilter<"Contact"> | string
    Campaign?: StringNullableFilter<"Contact"> | string | null
    Range?: StringNullableFilter<"Contact"> | string | null
    ContactNo?: StringNullableFilter<"Contact"> | string | null
    Location?: StringNullableFilter<"Contact"> | string | null
    ContactType?: StringNullableFilter<"Contact"> | string | null
    Name?: StringFilter<"Contact"> | string
    City?: StringNullableFilter<"Contact"> | string | null
    Address?: StringNullableFilter<"Contact"> | string | null
    ContactIndustry?: StringNullableFilter<"Contact"> | string | null
    ContactFunctionalArea?: StringNullableFilter<"Contact"> | string | null
    ReferenceId?: StringNullableFilter<"Contact"> | string | null
    Notes?: StringNullableFilter<"Contact"> | string | null
    Facilities?: StringNullableFilter<"Contact"> | string | null
    date?: StringNullableFilter<"Contact"> | string | null
    Email?: StringNullableFilter<"Contact"> | string | null
    CompanyName?: StringNullableFilter<"Contact"> | string | null
    Website?: StringNullableFilter<"Contact"> | string | null
    Status?: StringNullableFilter<"Contact"> | string | null
    Qualifications?: StringNullableFilter<"Contact"> | string | null
    isFavourite?: BoolFilter<"Contact"> | boolean
    isImported?: BoolFilter<"Contact"> | boolean
    AssignToId?: StringNullableFilter<"Contact"> | string | null
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    AssignTo?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    followups?: FollowupListRelationFilter
    contactFollowups?: ContactFollowupListRelationFilter
  }

  export type ContactOrderByWithRelationInput = {
    id?: SortOrder
    Campaign?: SortOrderInput | SortOrder
    Range?: SortOrderInput | SortOrder
    ContactNo?: SortOrderInput | SortOrder
    Location?: SortOrderInput | SortOrder
    ContactType?: SortOrderInput | SortOrder
    Name?: SortOrder
    City?: SortOrderInput | SortOrder
    Address?: SortOrderInput | SortOrder
    ContactIndustry?: SortOrderInput | SortOrder
    ContactFunctionalArea?: SortOrderInput | SortOrder
    ReferenceId?: SortOrderInput | SortOrder
    Notes?: SortOrderInput | SortOrder
    Facilities?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    Email?: SortOrderInput | SortOrder
    CompanyName?: SortOrderInput | SortOrder
    Website?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    Qualifications?: SortOrderInput | SortOrder
    isFavourite?: SortOrder
    isImported?: SortOrder
    AssignToId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    AssignTo?: AdminOrderByWithRelationInput
    followups?: FollowupOrderByRelationAggregateInput
    contactFollowups?: ContactFollowupOrderByRelationAggregateInput
    _relevance?: ContactOrderByRelevanceInput
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    Campaign?: StringNullableFilter<"Contact"> | string | null
    Range?: StringNullableFilter<"Contact"> | string | null
    ContactNo?: StringNullableFilter<"Contact"> | string | null
    Location?: StringNullableFilter<"Contact"> | string | null
    ContactType?: StringNullableFilter<"Contact"> | string | null
    Name?: StringFilter<"Contact"> | string
    City?: StringNullableFilter<"Contact"> | string | null
    Address?: StringNullableFilter<"Contact"> | string | null
    ContactIndustry?: StringNullableFilter<"Contact"> | string | null
    ContactFunctionalArea?: StringNullableFilter<"Contact"> | string | null
    ReferenceId?: StringNullableFilter<"Contact"> | string | null
    Notes?: StringNullableFilter<"Contact"> | string | null
    Facilities?: StringNullableFilter<"Contact"> | string | null
    date?: StringNullableFilter<"Contact"> | string | null
    Email?: StringNullableFilter<"Contact"> | string | null
    CompanyName?: StringNullableFilter<"Contact"> | string | null
    Website?: StringNullableFilter<"Contact"> | string | null
    Status?: StringNullableFilter<"Contact"> | string | null
    Qualifications?: StringNullableFilter<"Contact"> | string | null
    isFavourite?: BoolFilter<"Contact"> | boolean
    isImported?: BoolFilter<"Contact"> | boolean
    AssignToId?: StringNullableFilter<"Contact"> | string | null
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    AssignTo?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    followups?: FollowupListRelationFilter
    contactFollowups?: ContactFollowupListRelationFilter
  }, "id">

  export type ContactOrderByWithAggregationInput = {
    id?: SortOrder
    Campaign?: SortOrderInput | SortOrder
    Range?: SortOrderInput | SortOrder
    ContactNo?: SortOrderInput | SortOrder
    Location?: SortOrderInput | SortOrder
    ContactType?: SortOrderInput | SortOrder
    Name?: SortOrder
    City?: SortOrderInput | SortOrder
    Address?: SortOrderInput | SortOrder
    ContactIndustry?: SortOrderInput | SortOrder
    ContactFunctionalArea?: SortOrderInput | SortOrder
    ReferenceId?: SortOrderInput | SortOrder
    Notes?: SortOrderInput | SortOrder
    Facilities?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    Email?: SortOrderInput | SortOrder
    CompanyName?: SortOrderInput | SortOrder
    Website?: SortOrderInput | SortOrder
    Status?: SortOrderInput | SortOrder
    Qualifications?: SortOrderInput | SortOrder
    isFavourite?: SortOrder
    isImported?: SortOrder
    AssignToId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactCountOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contact"> | string
    Campaign?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    Range?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    ContactNo?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    Location?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    ContactType?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    Name?: StringWithAggregatesFilter<"Contact"> | string
    City?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    Address?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    ContactIndustry?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    ContactFunctionalArea?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    ReferenceId?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    Notes?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    Facilities?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    date?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    Email?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    CompanyName?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    Website?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    Status?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    Qualifications?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    isFavourite?: BoolWithAggregatesFilter<"Contact"> | boolean
    isImported?: BoolWithAggregatesFilter<"Contact"> | boolean
    AssignToId?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
  }

  export type ContactFollowupWhereInput = {
    AND?: ContactFollowupWhereInput | ContactFollowupWhereInput[]
    OR?: ContactFollowupWhereInput[]
    NOT?: ContactFollowupWhereInput | ContactFollowupWhereInput[]
    id?: StringFilter<"ContactFollowup"> | string
    contactId?: StringFilter<"ContactFollowup"> | string
    StartDate?: StringNullableFilter<"ContactFollowup"> | string | null
    StatusType?: StringNullableFilter<"ContactFollowup"> | string | null
    FollowupNextDate?: StringNullableFilter<"ContactFollowup"> | string | null
    Description?: StringNullableFilter<"ContactFollowup"> | string | null
    createdAt?: DateTimeFilter<"ContactFollowup"> | Date | string
    updatedAt?: DateTimeFilter<"ContactFollowup"> | Date | string
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
  }

  export type ContactFollowupOrderByWithRelationInput = {
    id?: SortOrder
    contactId?: SortOrder
    StartDate?: SortOrderInput | SortOrder
    StatusType?: SortOrderInput | SortOrder
    FollowupNextDate?: SortOrderInput | SortOrder
    Description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contact?: ContactOrderByWithRelationInput
    _relevance?: ContactFollowupOrderByRelevanceInput
  }

  export type ContactFollowupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactFollowupWhereInput | ContactFollowupWhereInput[]
    OR?: ContactFollowupWhereInput[]
    NOT?: ContactFollowupWhereInput | ContactFollowupWhereInput[]
    contactId?: StringFilter<"ContactFollowup"> | string
    StartDate?: StringNullableFilter<"ContactFollowup"> | string | null
    StatusType?: StringNullableFilter<"ContactFollowup"> | string | null
    FollowupNextDate?: StringNullableFilter<"ContactFollowup"> | string | null
    Description?: StringNullableFilter<"ContactFollowup"> | string | null
    createdAt?: DateTimeFilter<"ContactFollowup"> | Date | string
    updatedAt?: DateTimeFilter<"ContactFollowup"> | Date | string
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
  }, "id">

  export type ContactFollowupOrderByWithAggregationInput = {
    id?: SortOrder
    contactId?: SortOrder
    StartDate?: SortOrderInput | SortOrder
    StatusType?: SortOrderInput | SortOrder
    FollowupNextDate?: SortOrderInput | SortOrder
    Description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactFollowupCountOrderByAggregateInput
    _max?: ContactFollowupMaxOrderByAggregateInput
    _min?: ContactFollowupMinOrderByAggregateInput
  }

  export type ContactFollowupScalarWhereWithAggregatesInput = {
    AND?: ContactFollowupScalarWhereWithAggregatesInput | ContactFollowupScalarWhereWithAggregatesInput[]
    OR?: ContactFollowupScalarWhereWithAggregatesInput[]
    NOT?: ContactFollowupScalarWhereWithAggregatesInput | ContactFollowupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContactFollowup"> | string
    contactId?: StringWithAggregatesFilter<"ContactFollowup"> | string
    StartDate?: StringNullableWithAggregatesFilter<"ContactFollowup"> | string | null
    StatusType?: StringNullableWithAggregatesFilter<"ContactFollowup"> | string | null
    FollowupNextDate?: StringNullableWithAggregatesFilter<"ContactFollowup"> | string | null
    Description?: StringNullableWithAggregatesFilter<"ContactFollowup"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ContactFollowup"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContactFollowup"> | Date | string
  }

  export type RequestUserWhereInput = {
    AND?: RequestUserWhereInput | RequestUserWhereInput[]
    OR?: RequestUserWhereInput[]
    NOT?: RequestUserWhereInput | RequestUserWhereInput[]
    id?: StringFilter<"RequestUser"> | string
    name?: StringFilter<"RequestUser"> | string
    email?: StringFilter<"RequestUser"> | string
    password?: StringFilter<"RequestUser"> | string
  }

  export type RequestUserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    _relevance?: RequestUserOrderByRelevanceInput
  }

  export type RequestUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RequestUserWhereInput | RequestUserWhereInput[]
    OR?: RequestUserWhereInput[]
    NOT?: RequestUserWhereInput | RequestUserWhereInput[]
    name?: StringFilter<"RequestUser"> | string
    email?: StringFilter<"RequestUser"> | string
    password?: StringFilter<"RequestUser"> | string
  }, "id">

  export type RequestUserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    _count?: RequestUserCountOrderByAggregateInput
    _max?: RequestUserMaxOrderByAggregateInput
    _min?: RequestUserMinOrderByAggregateInput
  }

  export type RequestUserScalarWhereWithAggregatesInput = {
    AND?: RequestUserScalarWhereWithAggregatesInput | RequestUserScalarWhereWithAggregatesInput[]
    OR?: RequestUserScalarWhereWithAggregatesInput[]
    NOT?: RequestUserScalarWhereWithAggregatesInput | RequestUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RequestUser"> | string
    name?: StringWithAggregatesFilter<"RequestUser"> | string
    email?: StringWithAggregatesFilter<"RequestUser"> | string
    password?: StringWithAggregatesFilter<"RequestUser"> | string
  }

  export type AdminCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.Role
    city?: string | null
    phone?: string | null
    status?: $Enums.AdminStatus
    AddressLine1?: string | null
    AddressLine2?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByRef?: AdminCreateNestedOneWithoutCreatedAdminsInput
    createdAdmins?: AdminCreateNestedManyWithoutCreatedByRefInput
    assignedCustomers?: CustomerCreateNestedManyWithoutAssignToInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatedByInput
    assignedContact?: ContactCreateNestedManyWithoutAssignToInput
  }

  export type AdminUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.Role
    city?: string | null
    phone?: string | null
    status?: $Enums.AdminStatus
    AddressLine1?: string | null
    AddressLine2?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdAdmins?: AdminUncheckedCreateNestedManyWithoutCreatedByRefInput
    assignedCustomers?: CustomerUncheckedCreateNestedManyWithoutAssignToInput
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatedByInput
    assignedContact?: ContactUncheckedCreateNestedManyWithoutAssignToInput
  }

  export type AdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    AddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    AddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByRef?: AdminUpdateOneWithoutCreatedAdminsNestedInput
    createdAdmins?: AdminUpdateManyWithoutCreatedByRefNestedInput
    assignedCustomers?: CustomerUpdateManyWithoutAssignToNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatedByNestedInput
    assignedContact?: ContactUpdateManyWithoutAssignToNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    AddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    AddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAdmins?: AdminUncheckedUpdateManyWithoutCreatedByRefNestedInput
    assignedCustomers?: CustomerUncheckedUpdateManyWithoutAssignToNestedInput
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedContact?: ContactUncheckedUpdateManyWithoutAssignToNestedInput
  }

  export type AdminCreateManyInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.Role
    city?: string | null
    phone?: string | null
    status?: $Enums.AdminStatus
    AddressLine1?: string | null
    AddressLine2?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    AddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    AddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    AddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    AddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignCreateInput = {
    id?: string
    Name: string
    Status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    types?: TypeCreateNestedManyWithoutCampaignInput
    subTypes?: SubTypeCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateInput = {
    id?: string
    Name: string
    Status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    types?: TypeUncheckedCreateNestedManyWithoutCampaignInput
    subTypes?: SubTypeUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    types?: TypeUpdateManyWithoutCampaignNestedInput
    subTypes?: SubTypeUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    types?: TypeUncheckedUpdateManyWithoutCampaignNestedInput
    subTypes?: SubTypeUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateManyInput = {
    id?: string
    Name: string
    Status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TypeCreateInput = {
    id?: string
    Name?: string
    Status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    Campaign: CampaignCreateNestedOneWithoutTypesInput
    subTypes?: SubTypeCreateNestedManyWithoutCustomerTypeInput
  }

  export type TypeUncheckedCreateInput = {
    id?: string
    Name?: string
    Status?: $Enums.Status
    campaignId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subTypes?: SubTypeUncheckedCreateNestedManyWithoutCustomerTypeInput
  }

  export type TypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Campaign?: CampaignUpdateOneRequiredWithoutTypesNestedInput
    subTypes?: SubTypeUpdateManyWithoutCustomerTypeNestedInput
  }

  export type TypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    campaignId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subTypes?: SubTypeUncheckedUpdateManyWithoutCustomerTypeNestedInput
  }

  export type TypeCreateManyInput = {
    id?: string
    Name?: string
    Status?: $Enums.Status
    campaignId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    campaignId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubTypeCreateInput = {
    id?: string
    Name: string
    Status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Campaign: CampaignCreateNestedOneWithoutSubTypesInput
    CustomerType: TypeCreateNestedOneWithoutSubTypesInput
  }

  export type SubTypeUncheckedCreateInput = {
    id?: string
    Name: string
    Status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    campaignId: string
    customerTypeId: string
  }

  export type SubTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Campaign?: CampaignUpdateOneRequiredWithoutSubTypesNestedInput
    CustomerType?: TypeUpdateOneRequiredWithoutSubTypesNestedInput
  }

  export type SubTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaignId?: StringFieldUpdateOperationsInput | string
    customerTypeId?: StringFieldUpdateOperationsInput | string
  }

  export type SubTypeCreateManyInput = {
    id?: string
    Name: string
    Status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    campaignId: string
    customerTypeId: string
  }

  export type SubTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaignId?: StringFieldUpdateOperationsInput | string
    customerTypeId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactCampaignCreateInput = {
    id?: string
    Name: string
    Status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    contactTypes?: ContactTypeCreateNestedManyWithoutCampaignInput
  }

  export type ContactCampaignUncheckedCreateInput = {
    id?: string
    Name: string
    Status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    contactTypes?: ContactTypeUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type ContactCampaignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactTypes?: ContactTypeUpdateManyWithoutCampaignNestedInput
  }

  export type ContactCampaignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactTypes?: ContactTypeUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type ContactCampaignCreateManyInput = {
    id?: string
    Name: string
    Status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactCampaignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCampaignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactTypeCreateInput = {
    id?: string
    Name?: string
    Status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    Campaign: ContactCampaignCreateNestedOneWithoutContactTypesInput
  }

  export type ContactTypeUncheckedCreateInput = {
    id?: string
    Name?: string
    Status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    campaignId: string
  }

  export type ContactTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Campaign?: ContactCampaignUpdateOneRequiredWithoutContactTypesNestedInput
  }

  export type ContactTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaignId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactTypeCreateManyInput = {
    id?: string
    Name?: string
    Status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    campaignId: string
  }

  export type ContactTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaignId?: StringFieldUpdateOperationsInput | string
  }

  export type CityCreateInput = {
    id?: string
    Name: string
    Status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateInput = {
    id?: string
    Name: string
    Status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    locations?: LocationUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    locations?: LocationUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CityCreateManyInput = {
    id?: string
    Name: string
    Status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationCreateInput = {
    id?: string
    Name?: string
    Status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    City: CityCreateNestedOneWithoutLocationsInput
  }

  export type LocationUncheckedCreateInput = {
    id?: string
    Name?: string
    Status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cityId: string
  }

  export type LocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    City?: CityUpdateOneRequiredWithoutLocationsNestedInput
  }

  export type LocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cityId?: StringFieldUpdateOperationsInput | string
  }

  export type LocationCreateManyInput = {
    id?: string
    Name?: string
    Status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cityId: string
  }

  export type LocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cityId?: StringFieldUpdateOperationsInput | string
  }

  export type FacilityCreateInput = {
    id?: string
    Name: string
    Status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacilityUncheckedCreateInput = {
    id?: string
    Name: string
    Status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacilityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityCreateManyInput = {
    id?: string
    Name: string
    Status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FacilityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FacilityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenityCreateInput = {
    id?: string
    Name: string
    Status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmenityUncheckedCreateInput = {
    id?: string
    Name: string
    Status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmenityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenityCreateManyInput = {
    id?: string
    Name: string
    Status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmenityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FunctionalAreaCreateInput = {
    id?: string
    Name: string
    Status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FunctionalAreaUncheckedCreateInput = {
    id?: string
    Name: string
    Status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FunctionalAreaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FunctionalAreaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FunctionalAreaCreateManyInput = {
    id?: string
    Name: string
    Status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FunctionalAreaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FunctionalAreaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndustryCreateInput = {
    id?: string
    Name: string
    Status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IndustryUncheckedCreateInput = {
    id?: string
    Name: string
    Status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IndustryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndustryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndustryCreateManyInput = {
    id?: string
    Name: string
    Status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IndustryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndustryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferenceCreateInput = {
    id?: string
    Name: string
    Status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferenceUncheckedCreateInput = {
    id?: string
    Name: string
    Status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferenceCreateManyInput = {
    id?: string
    Name: string
    Status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCreateInput = {
    id?: string
    Name: string
    Status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseUncheckedCreateInput = {
    id?: string
    Name: string
    Status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseCreateManyInput = {
    id?: string
    Name: string
    Status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncomeCreateInput = {
    id?: string
    Name: string
    Status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncomeUncheckedCreateInput = {
    id?: string
    Name: string
    Status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncomeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncomeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncomeCreateManyInput = {
    id?: string
    Name: string
    Status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncomeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncomeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusTypeCreateInput = {
    id?: string
    Name: string
    Status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StatusTypeUncheckedCreateInput = {
    id?: string
    Name: string
    Status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StatusTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusTypeCreateManyInput = {
    id?: string
    Name: string
    Status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StatusTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactStatusTypeCreateInput = {
    id?: string
    Name: string
    Status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactStatusTypeUncheckedCreateInput = {
    id?: string
    Name: string
    Status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactStatusTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactStatusTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactStatusTypeCreateManyInput = {
    id?: string
    Name: string
    Status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactStatusTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactStatusTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodCreateInput = {
    id?: string
    Name?: string
    Status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodUncheckedCreateInput = {
    id?: string
    Name?: string
    Status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodCreateManyInput = {
    id?: string
    Name?: string
    Status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentMethodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentMethodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateCreateInput = {
    id?: string
    name: string
    type: string
    subject?: string
    body: string
    description?: string
    whatsappImage?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    subject?: string
    body: string
    description?: string
    whatsappImage?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    whatsappImage?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    whatsappImage?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateCreateManyInput = {
    id?: string
    name: string
    type: string
    subject?: string
    body: string
    description?: string
    whatsappImage?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    whatsappImage?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    whatsappImage?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncomeMarketingCreateInput = {
    id?: string
    Date?: string | null
    PartyName?: string | null
    User?: string | null
    Income?: string | null
    Amount?: string | null
    DueAmount?: string | null
    PaymentMethode?: string | null
    Status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncomeMarketingUncheckedCreateInput = {
    id?: string
    Date?: string | null
    PartyName?: string | null
    User?: string | null
    Income?: string | null
    Amount?: string | null
    DueAmount?: string | null
    PaymentMethode?: string | null
    Status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncomeMarketingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Date?: NullableStringFieldUpdateOperationsInput | string | null
    PartyName?: NullableStringFieldUpdateOperationsInput | string | null
    User?: NullableStringFieldUpdateOperationsInput | string | null
    Income?: NullableStringFieldUpdateOperationsInput | string | null
    Amount?: NullableStringFieldUpdateOperationsInput | string | null
    DueAmount?: NullableStringFieldUpdateOperationsInput | string | null
    PaymentMethode?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncomeMarketingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Date?: NullableStringFieldUpdateOperationsInput | string | null
    PartyName?: NullableStringFieldUpdateOperationsInput | string | null
    User?: NullableStringFieldUpdateOperationsInput | string | null
    Income?: NullableStringFieldUpdateOperationsInput | string | null
    Amount?: NullableStringFieldUpdateOperationsInput | string | null
    DueAmount?: NullableStringFieldUpdateOperationsInput | string | null
    PaymentMethode?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncomeMarketingCreateManyInput = {
    id?: string
    Date?: string | null
    PartyName?: string | null
    User?: string | null
    Income?: string | null
    Amount?: string | null
    DueAmount?: string | null
    PaymentMethode?: string | null
    Status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncomeMarketingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    Date?: NullableStringFieldUpdateOperationsInput | string | null
    PartyName?: NullableStringFieldUpdateOperationsInput | string | null
    User?: NullableStringFieldUpdateOperationsInput | string | null
    Income?: NullableStringFieldUpdateOperationsInput | string | null
    Amount?: NullableStringFieldUpdateOperationsInput | string | null
    DueAmount?: NullableStringFieldUpdateOperationsInput | string | null
    PaymentMethode?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncomeMarketingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    Date?: NullableStringFieldUpdateOperationsInput | string | null
    PartyName?: NullableStringFieldUpdateOperationsInput | string | null
    User?: NullableStringFieldUpdateOperationsInput | string | null
    Income?: NullableStringFieldUpdateOperationsInput | string | null
    Amount?: NullableStringFieldUpdateOperationsInput | string | null
    DueAmount?: NullableStringFieldUpdateOperationsInput | string | null
    PaymentMethode?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseMarketingCreateInput = {
    id?: string
    Date?: string | null
    PartyName?: string | null
    User?: string | null
    Expense?: string | null
    Amount?: string | null
    DueAmount?: string | null
    PaymentMethode?: string | null
    Status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseMarketingUncheckedCreateInput = {
    id?: string
    Date?: string | null
    PartyName?: string | null
    User?: string | null
    Expense?: string | null
    Amount?: string | null
    DueAmount?: string | null
    PaymentMethode?: string | null
    Status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseMarketingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Date?: NullableStringFieldUpdateOperationsInput | string | null
    PartyName?: NullableStringFieldUpdateOperationsInput | string | null
    User?: NullableStringFieldUpdateOperationsInput | string | null
    Expense?: NullableStringFieldUpdateOperationsInput | string | null
    Amount?: NullableStringFieldUpdateOperationsInput | string | null
    DueAmount?: NullableStringFieldUpdateOperationsInput | string | null
    PaymentMethode?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseMarketingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Date?: NullableStringFieldUpdateOperationsInput | string | null
    PartyName?: NullableStringFieldUpdateOperationsInput | string | null
    User?: NullableStringFieldUpdateOperationsInput | string | null
    Expense?: NullableStringFieldUpdateOperationsInput | string | null
    Amount?: NullableStringFieldUpdateOperationsInput | string | null
    DueAmount?: NullableStringFieldUpdateOperationsInput | string | null
    PaymentMethode?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseMarketingCreateManyInput = {
    id?: string
    Date?: string | null
    PartyName?: string | null
    User?: string | null
    Expense?: string | null
    Amount?: string | null
    DueAmount?: string | null
    PaymentMethode?: string | null
    Status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExpenseMarketingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    Date?: NullableStringFieldUpdateOperationsInput | string | null
    PartyName?: NullableStringFieldUpdateOperationsInput | string | null
    User?: NullableStringFieldUpdateOperationsInput | string | null
    Expense?: NullableStringFieldUpdateOperationsInput | string | null
    Amount?: NullableStringFieldUpdateOperationsInput | string | null
    DueAmount?: NullableStringFieldUpdateOperationsInput | string | null
    PaymentMethode?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExpenseMarketingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    Date?: NullableStringFieldUpdateOperationsInput | string | null
    PartyName?: NullableStringFieldUpdateOperationsInput | string | null
    User?: NullableStringFieldUpdateOperationsInput | string | null
    Expense?: NullableStringFieldUpdateOperationsInput | string | null
    Amount?: NullableStringFieldUpdateOperationsInput | string | null
    DueAmount?: NullableStringFieldUpdateOperationsInput | string | null
    PaymentMethode?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateInput = {
    id?: string
    date?: string | null
    Time?: string | null
    Description?: string | null
    User?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUncheckedCreateInput = {
    id?: string
    date?: string | null
    Time?: string | null
    Description?: string | null
    User?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: NullableStringFieldUpdateOperationsInput | string | null
    Time?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    User?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: NullableStringFieldUpdateOperationsInput | string | null
    Time?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    User?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateManyInput = {
    id?: string
    date?: string | null
    Time?: string | null
    Description?: string | null
    User?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: NullableStringFieldUpdateOperationsInput | string | null
    Time?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    User?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: NullableStringFieldUpdateOperationsInput | string | null
    Time?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    User?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleCreateInput = {
    id?: string
    date?: string | null
    Time?: string | null
    Description?: string | null
    User?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleUncheckedCreateInput = {
    id?: string
    date?: string | null
    Time?: string | null
    Description?: string | null
    User?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: NullableStringFieldUpdateOperationsInput | string | null
    Time?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    User?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: NullableStringFieldUpdateOperationsInput | string | null
    Time?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    User?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleCreateManyInput = {
    id?: string
    date?: string | null
    Time?: string | null
    Description?: string | null
    User?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: NullableStringFieldUpdateOperationsInput | string | null
    Time?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    User?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: NullableStringFieldUpdateOperationsInput | string | null
    Time?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    User?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyProjectCreateInput = {
    id?: string
    ProjectName: string
    ProjectType?: string | null
    ProjectStatus?: string | null
    City?: string | null
    Location?: string | null
    Area?: string | null
    Range?: string | null
    Adderess?: string | null
    Facillities?: string | null
    Amenities?: string | null
    Description?: string | null
    Video?: string | null
    GoogleMap?: string | null
    CustomerImage?: NullableJsonNullValueInput | InputJsonValue
    SitePlan?: NullableJsonNullValueInput | InputJsonValue
    CreatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyProjectUncheckedCreateInput = {
    id?: string
    ProjectName: string
    ProjectType?: string | null
    ProjectStatus?: string | null
    City?: string | null
    Location?: string | null
    Area?: string | null
    Range?: string | null
    Adderess?: string | null
    Facillities?: string | null
    Amenities?: string | null
    Description?: string | null
    Video?: string | null
    GoogleMap?: string | null
    CustomerImage?: NullableJsonNullValueInput | InputJsonValue
    SitePlan?: NullableJsonNullValueInput | InputJsonValue
    CreatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ProjectName?: StringFieldUpdateOperationsInput | string
    ProjectType?: NullableStringFieldUpdateOperationsInput | string | null
    ProjectStatus?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    Area?: NullableStringFieldUpdateOperationsInput | string | null
    Range?: NullableStringFieldUpdateOperationsInput | string | null
    Adderess?: NullableStringFieldUpdateOperationsInput | string | null
    Facillities?: NullableStringFieldUpdateOperationsInput | string | null
    Amenities?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Video?: NullableStringFieldUpdateOperationsInput | string | null
    GoogleMap?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerImage?: NullableJsonNullValueInput | InputJsonValue
    SitePlan?: NullableJsonNullValueInput | InputJsonValue
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ProjectName?: StringFieldUpdateOperationsInput | string
    ProjectType?: NullableStringFieldUpdateOperationsInput | string | null
    ProjectStatus?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    Area?: NullableStringFieldUpdateOperationsInput | string | null
    Range?: NullableStringFieldUpdateOperationsInput | string | null
    Adderess?: NullableStringFieldUpdateOperationsInput | string | null
    Facillities?: NullableStringFieldUpdateOperationsInput | string | null
    Amenities?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Video?: NullableStringFieldUpdateOperationsInput | string | null
    GoogleMap?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerImage?: NullableJsonNullValueInput | InputJsonValue
    SitePlan?: NullableJsonNullValueInput | InputJsonValue
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyProjectCreateManyInput = {
    id?: string
    ProjectName: string
    ProjectType?: string | null
    ProjectStatus?: string | null
    City?: string | null
    Location?: string | null
    Area?: string | null
    Range?: string | null
    Adderess?: string | null
    Facillities?: string | null
    Amenities?: string | null
    Description?: string | null
    Video?: string | null
    GoogleMap?: string | null
    CustomerImage?: NullableJsonNullValueInput | InputJsonValue
    SitePlan?: NullableJsonNullValueInput | InputJsonValue
    CreatedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ProjectName?: StringFieldUpdateOperationsInput | string
    ProjectType?: NullableStringFieldUpdateOperationsInput | string | null
    ProjectStatus?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    Area?: NullableStringFieldUpdateOperationsInput | string | null
    Range?: NullableStringFieldUpdateOperationsInput | string | null
    Adderess?: NullableStringFieldUpdateOperationsInput | string | null
    Facillities?: NullableStringFieldUpdateOperationsInput | string | null
    Amenities?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Video?: NullableStringFieldUpdateOperationsInput | string | null
    GoogleMap?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerImage?: NullableJsonNullValueInput | InputJsonValue
    SitePlan?: NullableJsonNullValueInput | InputJsonValue
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ProjectName?: StringFieldUpdateOperationsInput | string
    ProjectType?: NullableStringFieldUpdateOperationsInput | string | null
    ProjectStatus?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    Area?: NullableStringFieldUpdateOperationsInput | string | null
    Range?: NullableStringFieldUpdateOperationsInput | string | null
    Adderess?: NullableStringFieldUpdateOperationsInput | string | null
    Facillities?: NullableStringFieldUpdateOperationsInput | string | null
    Amenities?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Video?: NullableStringFieldUpdateOperationsInput | string | null
    GoogleMap?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerImage?: NullableJsonNullValueInput | InputJsonValue
    SitePlan?: NullableJsonNullValueInput | InputJsonValue
    CreatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuilderSliderCreateInput = {
    id?: string
    Image?: NullableJsonNullValueInput | InputJsonValue
    Status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuilderSliderUncheckedCreateInput = {
    id?: string
    Image?: NullableJsonNullValueInput | InputJsonValue
    Status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuilderSliderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Image?: NullableJsonNullValueInput | InputJsonValue
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuilderSliderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Image?: NullableJsonNullValueInput | InputJsonValue
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuilderSliderCreateManyInput = {
    id?: string
    Image?: NullableJsonNullValueInput | InputJsonValue
    Status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuilderSliderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    Image?: NullableJsonNullValueInput | InputJsonValue
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuilderSliderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    Image?: NullableJsonNullValueInput | InputJsonValue
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    id?: string
    Campaign?: string | null
    CustomerType?: string | null
    CustomerSubType?: string | null
    customerName: string
    ContactNumber: string
    City?: string | null
    Location?: string | null
    Area?: string | null
    Adderess?: string | null
    Email?: string | null
    Facillities?: string | null
    ReferenceId?: string | null
    CustomerId?: string | null
    CustomerDate?: string | null
    CustomerYear?: string | null
    Other?: string | null
    Description?: string | null
    Video?: string | null
    Verified?: string | null
    GoogleMap?: string | null
    CustomerImage?: NullableJsonNullValueInput | InputJsonValue
    SitePlan?: NullableJsonNullValueInput | InputJsonValue
    isFavourite?: boolean
    isImported?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    AssignTo?: AdminCreateNestedOneWithoutAssignedCustomersInput
    CreatedBy?: AdminCreateNestedOneWithoutCreatedCustomersInput
    followups?: FollowupCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    Campaign?: string | null
    CustomerType?: string | null
    CustomerSubType?: string | null
    customerName: string
    ContactNumber: string
    City?: string | null
    Location?: string | null
    Area?: string | null
    Adderess?: string | null
    Email?: string | null
    Facillities?: string | null
    ReferenceId?: string | null
    CustomerId?: string | null
    CustomerDate?: string | null
    CustomerYear?: string | null
    Other?: string | null
    Description?: string | null
    Video?: string | null
    Verified?: string | null
    GoogleMap?: string | null
    CustomerImage?: NullableJsonNullValueInput | InputJsonValue
    SitePlan?: NullableJsonNullValueInput | InputJsonValue
    isFavourite?: boolean
    AssignToId?: string | null
    CreatedById?: string | null
    isImported?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    followups?: FollowupUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Campaign?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerType?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerSubType?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    ContactNumber?: StringFieldUpdateOperationsInput | string
    City?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    Area?: NullableStringFieldUpdateOperationsInput | string | null
    Adderess?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Facillities?: NullableStringFieldUpdateOperationsInput | string | null
    ReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerDate?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerYear?: NullableStringFieldUpdateOperationsInput | string | null
    Other?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Video?: NullableStringFieldUpdateOperationsInput | string | null
    Verified?: NullableStringFieldUpdateOperationsInput | string | null
    GoogleMap?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerImage?: NullableJsonNullValueInput | InputJsonValue
    SitePlan?: NullableJsonNullValueInput | InputJsonValue
    isFavourite?: BoolFieldUpdateOperationsInput | boolean
    isImported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AssignTo?: AdminUpdateOneWithoutAssignedCustomersNestedInput
    CreatedBy?: AdminUpdateOneWithoutCreatedCustomersNestedInput
    followups?: FollowupUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Campaign?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerType?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerSubType?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    ContactNumber?: StringFieldUpdateOperationsInput | string
    City?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    Area?: NullableStringFieldUpdateOperationsInput | string | null
    Adderess?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Facillities?: NullableStringFieldUpdateOperationsInput | string | null
    ReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerDate?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerYear?: NullableStringFieldUpdateOperationsInput | string | null
    Other?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Video?: NullableStringFieldUpdateOperationsInput | string | null
    Verified?: NullableStringFieldUpdateOperationsInput | string | null
    GoogleMap?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerImage?: NullableJsonNullValueInput | InputJsonValue
    SitePlan?: NullableJsonNullValueInput | InputJsonValue
    isFavourite?: BoolFieldUpdateOperationsInput | boolean
    AssignToId?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isImported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followups?: FollowupUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    Campaign?: string | null
    CustomerType?: string | null
    CustomerSubType?: string | null
    customerName: string
    ContactNumber: string
    City?: string | null
    Location?: string | null
    Area?: string | null
    Adderess?: string | null
    Email?: string | null
    Facillities?: string | null
    ReferenceId?: string | null
    CustomerId?: string | null
    CustomerDate?: string | null
    CustomerYear?: string | null
    Other?: string | null
    Description?: string | null
    Video?: string | null
    Verified?: string | null
    GoogleMap?: string | null
    CustomerImage?: NullableJsonNullValueInput | InputJsonValue
    SitePlan?: NullableJsonNullValueInput | InputJsonValue
    isFavourite?: boolean
    AssignToId?: string | null
    CreatedById?: string | null
    isImported?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    Campaign?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerType?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerSubType?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    ContactNumber?: StringFieldUpdateOperationsInput | string
    City?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    Area?: NullableStringFieldUpdateOperationsInput | string | null
    Adderess?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Facillities?: NullableStringFieldUpdateOperationsInput | string | null
    ReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerDate?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerYear?: NullableStringFieldUpdateOperationsInput | string | null
    Other?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Video?: NullableStringFieldUpdateOperationsInput | string | null
    Verified?: NullableStringFieldUpdateOperationsInput | string | null
    GoogleMap?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerImage?: NullableJsonNullValueInput | InputJsonValue
    SitePlan?: NullableJsonNullValueInput | InputJsonValue
    isFavourite?: BoolFieldUpdateOperationsInput | boolean
    isImported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    Campaign?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerType?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerSubType?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    ContactNumber?: StringFieldUpdateOperationsInput | string
    City?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    Area?: NullableStringFieldUpdateOperationsInput | string | null
    Adderess?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Facillities?: NullableStringFieldUpdateOperationsInput | string | null
    ReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerDate?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerYear?: NullableStringFieldUpdateOperationsInput | string | null
    Other?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Video?: NullableStringFieldUpdateOperationsInput | string | null
    Verified?: NullableStringFieldUpdateOperationsInput | string | null
    GoogleMap?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerImage?: NullableJsonNullValueInput | InputJsonValue
    SitePlan?: NullableJsonNullValueInput | InputJsonValue
    isFavourite?: BoolFieldUpdateOperationsInput | boolean
    AssignToId?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isImported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowupCreateInput = {
    id?: string
    StartDate?: string | null
    StatusType?: string | null
    FollowupNextDate?: string | null
    Description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutFollowupsInput
    contact?: ContactCreateNestedOneWithoutFollowupsInput
  }

  export type FollowupUncheckedCreateInput = {
    id?: string
    customerId: string
    StartDate?: string | null
    StatusType?: string | null
    FollowupNextDate?: string | null
    Description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contactId?: string | null
  }

  export type FollowupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    StartDate?: NullableStringFieldUpdateOperationsInput | string | null
    StatusType?: NullableStringFieldUpdateOperationsInput | string | null
    FollowupNextDate?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutFollowupsNestedInput
    contact?: ContactUpdateOneWithoutFollowupsNestedInput
  }

  export type FollowupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    StartDate?: NullableStringFieldUpdateOperationsInput | string | null
    StatusType?: NullableStringFieldUpdateOperationsInput | string | null
    FollowupNextDate?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FollowupCreateManyInput = {
    id?: string
    customerId: string
    StartDate?: string | null
    StatusType?: string | null
    FollowupNextDate?: string | null
    Description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contactId?: string | null
  }

  export type FollowupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    StartDate?: NullableStringFieldUpdateOperationsInput | string | null
    StatusType?: NullableStringFieldUpdateOperationsInput | string | null
    FollowupNextDate?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    StartDate?: NullableStringFieldUpdateOperationsInput | string | null
    StatusType?: NullableStringFieldUpdateOperationsInput | string | null
    FollowupNextDate?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactCreateInput = {
    id?: string
    Campaign?: string | null
    Range?: string | null
    ContactNo?: string | null
    Location?: string | null
    ContactType?: string | null
    Name?: string
    City?: string | null
    Address?: string | null
    ContactIndustry?: string | null
    ContactFunctionalArea?: string | null
    ReferenceId?: string | null
    Notes?: string | null
    Facilities?: string | null
    date?: string | null
    Email?: string | null
    CompanyName?: string | null
    Website?: string | null
    Status?: string | null
    Qualifications?: string | null
    isFavourite?: boolean
    isImported?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    AssignTo?: AdminCreateNestedOneWithoutAssignedContactInput
    followups?: FollowupCreateNestedManyWithoutContactInput
    contactFollowups?: ContactFollowupCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateInput = {
    id?: string
    Campaign?: string | null
    Range?: string | null
    ContactNo?: string | null
    Location?: string | null
    ContactType?: string | null
    Name?: string
    City?: string | null
    Address?: string | null
    ContactIndustry?: string | null
    ContactFunctionalArea?: string | null
    ReferenceId?: string | null
    Notes?: string | null
    Facilities?: string | null
    date?: string | null
    Email?: string | null
    CompanyName?: string | null
    Website?: string | null
    Status?: string | null
    Qualifications?: string | null
    isFavourite?: boolean
    isImported?: boolean
    AssignToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    followups?: FollowupUncheckedCreateNestedManyWithoutContactInput
    contactFollowups?: ContactFollowupUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Campaign?: NullableStringFieldUpdateOperationsInput | string | null
    Range?: NullableStringFieldUpdateOperationsInput | string | null
    ContactNo?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    ContactType?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: StringFieldUpdateOperationsInput | string
    City?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    ContactIndustry?: NullableStringFieldUpdateOperationsInput | string | null
    ContactFunctionalArea?: NullableStringFieldUpdateOperationsInput | string | null
    ReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Facilities?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyName?: NullableStringFieldUpdateOperationsInput | string | null
    Website?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    isFavourite?: BoolFieldUpdateOperationsInput | boolean
    isImported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AssignTo?: AdminUpdateOneWithoutAssignedContactNestedInput
    followups?: FollowupUpdateManyWithoutContactNestedInput
    contactFollowups?: ContactFollowupUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    Campaign?: NullableStringFieldUpdateOperationsInput | string | null
    Range?: NullableStringFieldUpdateOperationsInput | string | null
    ContactNo?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    ContactType?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: StringFieldUpdateOperationsInput | string
    City?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    ContactIndustry?: NullableStringFieldUpdateOperationsInput | string | null
    ContactFunctionalArea?: NullableStringFieldUpdateOperationsInput | string | null
    ReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Facilities?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyName?: NullableStringFieldUpdateOperationsInput | string | null
    Website?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    isFavourite?: BoolFieldUpdateOperationsInput | boolean
    isImported?: BoolFieldUpdateOperationsInput | boolean
    AssignToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followups?: FollowupUncheckedUpdateManyWithoutContactNestedInput
    contactFollowups?: ContactFollowupUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactCreateManyInput = {
    id?: string
    Campaign?: string | null
    Range?: string | null
    ContactNo?: string | null
    Location?: string | null
    ContactType?: string | null
    Name?: string
    City?: string | null
    Address?: string | null
    ContactIndustry?: string | null
    ContactFunctionalArea?: string | null
    ReferenceId?: string | null
    Notes?: string | null
    Facilities?: string | null
    date?: string | null
    Email?: string | null
    CompanyName?: string | null
    Website?: string | null
    Status?: string | null
    Qualifications?: string | null
    isFavourite?: boolean
    isImported?: boolean
    AssignToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    Campaign?: NullableStringFieldUpdateOperationsInput | string | null
    Range?: NullableStringFieldUpdateOperationsInput | string | null
    ContactNo?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    ContactType?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: StringFieldUpdateOperationsInput | string
    City?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    ContactIndustry?: NullableStringFieldUpdateOperationsInput | string | null
    ContactFunctionalArea?: NullableStringFieldUpdateOperationsInput | string | null
    ReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Facilities?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyName?: NullableStringFieldUpdateOperationsInput | string | null
    Website?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    isFavourite?: BoolFieldUpdateOperationsInput | boolean
    isImported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    Campaign?: NullableStringFieldUpdateOperationsInput | string | null
    Range?: NullableStringFieldUpdateOperationsInput | string | null
    ContactNo?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    ContactType?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: StringFieldUpdateOperationsInput | string
    City?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    ContactIndustry?: NullableStringFieldUpdateOperationsInput | string | null
    ContactFunctionalArea?: NullableStringFieldUpdateOperationsInput | string | null
    ReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Facilities?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyName?: NullableStringFieldUpdateOperationsInput | string | null
    Website?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    isFavourite?: BoolFieldUpdateOperationsInput | boolean
    isImported?: BoolFieldUpdateOperationsInput | boolean
    AssignToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactFollowupCreateInput = {
    id?: string
    StartDate?: string | null
    StatusType?: string | null
    FollowupNextDate?: string | null
    Description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: ContactCreateNestedOneWithoutContactFollowupsInput
  }

  export type ContactFollowupUncheckedCreateInput = {
    id?: string
    contactId: string
    StartDate?: string | null
    StatusType?: string | null
    FollowupNextDate?: string | null
    Description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactFollowupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    StartDate?: NullableStringFieldUpdateOperationsInput | string | null
    StatusType?: NullableStringFieldUpdateOperationsInput | string | null
    FollowupNextDate?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutContactFollowupsNestedInput
  }

  export type ContactFollowupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    StartDate?: NullableStringFieldUpdateOperationsInput | string | null
    StatusType?: NullableStringFieldUpdateOperationsInput | string | null
    FollowupNextDate?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactFollowupCreateManyInput = {
    id?: string
    contactId: string
    StartDate?: string | null
    StatusType?: string | null
    FollowupNextDate?: string | null
    Description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactFollowupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    StartDate?: NullableStringFieldUpdateOperationsInput | string | null
    StatusType?: NullableStringFieldUpdateOperationsInput | string | null
    FollowupNextDate?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactFollowupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    StartDate?: NullableStringFieldUpdateOperationsInput | string | null
    StatusType?: NullableStringFieldUpdateOperationsInput | string | null
    FollowupNextDate?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequestUserCreateInput = {
    id?: string
    name: string
    email: string
    password: string
  }

  export type RequestUserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    password: string
  }

  export type RequestUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type RequestUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type RequestUserCreateManyInput = {
    id?: string
    name: string
    email: string
    password: string
  }

  export type RequestUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type RequestUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumAdminStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminStatus | EnumAdminStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdminStatus[]
    notIn?: $Enums.AdminStatus[]
    not?: NestedEnumAdminStatusFilter<$PrismaModel> | $Enums.AdminStatus
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AdminNullableScalarRelationFilter = {
    is?: AdminWhereInput | null
    isNot?: AdminWhereInput | null
  }

  export type AdminListRelationFilter = {
    every?: AdminWhereInput
    some?: AdminWhereInput
    none?: AdminWhereInput
  }

  export type CustomerListRelationFilter = {
    every?: CustomerWhereInput
    some?: CustomerWhereInput
    none?: CustomerWhereInput
  }

  export type ContactListRelationFilter = {
    every?: ContactWhereInput
    some?: ContactWhereInput
    none?: ContactWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AdminOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminOrderByRelevanceInput = {
    fields: AdminOrderByRelevanceFieldEnum | AdminOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    city?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    AddressLine1?: SortOrder
    AddressLine2?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    city?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    AddressLine1?: SortOrder
    AddressLine2?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    city?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    AddressLine1?: SortOrder
    AddressLine2?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumAdminStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminStatus | EnumAdminStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdminStatus[]
    notIn?: $Enums.AdminStatus[]
    not?: NestedEnumAdminStatusWithAggregatesFilter<$PrismaModel> | $Enums.AdminStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminStatusFilter<$PrismaModel>
    _max?: NestedEnumAdminStatusFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[]
    notIn?: $Enums.Status[]
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type TypeListRelationFilter = {
    every?: TypeWhereInput
    some?: TypeWhereInput
    none?: TypeWhereInput
  }

  export type SubTypeListRelationFilter = {
    every?: SubTypeWhereInput
    some?: SubTypeWhereInput
    none?: SubTypeWhereInput
  }

  export type TypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignOrderByRelevanceInput = {
    fields: CampaignOrderByRelevanceFieldEnum | CampaignOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CampaignCountOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignMinOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[]
    notIn?: $Enums.Status[]
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type CampaignScalarRelationFilter = {
    is?: CampaignWhereInput
    isNot?: CampaignWhereInput
  }

  export type TypeOrderByRelevanceInput = {
    fields: TypeOrderByRelevanceFieldEnum | TypeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TypeCountOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    campaignId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TypeMaxOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    campaignId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TypeMinOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    campaignId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TypeScalarRelationFilter = {
    is?: TypeWhereInput
    isNot?: TypeWhereInput
  }

  export type SubTypeOrderByRelevanceInput = {
    fields: SubTypeOrderByRelevanceFieldEnum | SubTypeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SubTypeCountOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaignId?: SortOrder
    customerTypeId?: SortOrder
  }

  export type SubTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaignId?: SortOrder
    customerTypeId?: SortOrder
  }

  export type SubTypeMinOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaignId?: SortOrder
    customerTypeId?: SortOrder
  }

  export type ContactTypeListRelationFilter = {
    every?: ContactTypeWhereInput
    some?: ContactTypeWhereInput
    none?: ContactTypeWhereInput
  }

  export type ContactTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactCampaignOrderByRelevanceInput = {
    fields: ContactCampaignOrderByRelevanceFieldEnum | ContactCampaignOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ContactCampaignCountOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactCampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactCampaignMinOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactCampaignScalarRelationFilter = {
    is?: ContactCampaignWhereInput
    isNot?: ContactCampaignWhereInput
  }

  export type ContactTypeOrderByRelevanceInput = {
    fields: ContactTypeOrderByRelevanceFieldEnum | ContactTypeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ContactTypeCountOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaignId?: SortOrder
  }

  export type ContactTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaignId?: SortOrder
  }

  export type ContactTypeMinOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaignId?: SortOrder
  }

  export type LocationListRelationFilter = {
    every?: LocationWhereInput
    some?: LocationWhereInput
    none?: LocationWhereInput
  }

  export type LocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CityOrderByRelevanceInput = {
    fields: CityOrderByRelevanceFieldEnum | CityOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CityCountOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CityMaxOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CityMinOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CityScalarRelationFilter = {
    is?: CityWhereInput
    isNot?: CityWhereInput
  }

  export type LocationOrderByRelevanceInput = {
    fields: LocationOrderByRelevanceFieldEnum | LocationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type LocationCountOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cityId?: SortOrder
  }

  export type LocationMaxOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cityId?: SortOrder
  }

  export type LocationMinOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cityId?: SortOrder
  }

  export type FacilityOrderByRelevanceInput = {
    fields: FacilityOrderByRelevanceFieldEnum | FacilityOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FacilityCountOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacilityMaxOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FacilityMinOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmenityOrderByRelevanceInput = {
    fields: AmenityOrderByRelevanceFieldEnum | AmenityOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AmenityCountOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmenityMaxOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AmenityMinOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FunctionalAreaOrderByRelevanceInput = {
    fields: FunctionalAreaOrderByRelevanceFieldEnum | FunctionalAreaOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FunctionalAreaCountOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FunctionalAreaMaxOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FunctionalAreaMinOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IndustryOrderByRelevanceInput = {
    fields: IndustryOrderByRelevanceFieldEnum | IndustryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type IndustryCountOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IndustryMaxOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IndustryMinOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferenceOrderByRelevanceInput = {
    fields: ReferenceOrderByRelevanceFieldEnum | ReferenceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ReferenceCountOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReferenceMinOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseOrderByRelevanceInput = {
    fields: ExpenseOrderByRelevanceFieldEnum | ExpenseOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ExpenseCountOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseMaxOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseMinOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IncomeOrderByRelevanceInput = {
    fields: IncomeOrderByRelevanceFieldEnum | IncomeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type IncomeCountOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IncomeMaxOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IncomeMinOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StatusTypeOrderByRelevanceInput = {
    fields: StatusTypeOrderByRelevanceFieldEnum | StatusTypeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StatusTypeCountOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StatusTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StatusTypeMinOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactStatusTypeOrderByRelevanceInput = {
    fields: ContactStatusTypeOrderByRelevanceFieldEnum | ContactStatusTypeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ContactStatusTypeCountOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactStatusTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactStatusTypeMinOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodOrderByRelevanceInput = {
    fields: PaymentMethodOrderByRelevanceFieldEnum | PaymentMethodOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PaymentMethodCountOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodMaxOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMethodMinOrderByAggregateInput = {
    id?: SortOrder
    Name?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type TemplateOrderByRelevanceInput = {
    fields: TemplateOrderByRelevanceFieldEnum | TemplateOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    description?: SortOrder
    whatsappImage?: SortOrder
    createdBy?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    description?: SortOrder
    createdBy?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    body?: SortOrder
    description?: SortOrder
    createdBy?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type IncomeMarketingOrderByRelevanceInput = {
    fields: IncomeMarketingOrderByRelevanceFieldEnum | IncomeMarketingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type IncomeMarketingCountOrderByAggregateInput = {
    id?: SortOrder
    Date?: SortOrder
    PartyName?: SortOrder
    User?: SortOrder
    Income?: SortOrder
    Amount?: SortOrder
    DueAmount?: SortOrder
    PaymentMethode?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IncomeMarketingMaxOrderByAggregateInput = {
    id?: SortOrder
    Date?: SortOrder
    PartyName?: SortOrder
    User?: SortOrder
    Income?: SortOrder
    Amount?: SortOrder
    DueAmount?: SortOrder
    PaymentMethode?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IncomeMarketingMinOrderByAggregateInput = {
    id?: SortOrder
    Date?: SortOrder
    PartyName?: SortOrder
    User?: SortOrder
    Income?: SortOrder
    Amount?: SortOrder
    DueAmount?: SortOrder
    PaymentMethode?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseMarketingOrderByRelevanceInput = {
    fields: ExpenseMarketingOrderByRelevanceFieldEnum | ExpenseMarketingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ExpenseMarketingCountOrderByAggregateInput = {
    id?: SortOrder
    Date?: SortOrder
    PartyName?: SortOrder
    User?: SortOrder
    Expense?: SortOrder
    Amount?: SortOrder
    DueAmount?: SortOrder
    PaymentMethode?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseMarketingMaxOrderByAggregateInput = {
    id?: SortOrder
    Date?: SortOrder
    PartyName?: SortOrder
    User?: SortOrder
    Expense?: SortOrder
    Amount?: SortOrder
    DueAmount?: SortOrder
    PaymentMethode?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExpenseMarketingMinOrderByAggregateInput = {
    id?: SortOrder
    Date?: SortOrder
    PartyName?: SortOrder
    User?: SortOrder
    Expense?: SortOrder
    Amount?: SortOrder
    DueAmount?: SortOrder
    PaymentMethode?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskOrderByRelevanceInput = {
    fields: TaskOrderByRelevanceFieldEnum | TaskOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    Time?: SortOrder
    Description?: SortOrder
    User?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    Time?: SortOrder
    Description?: SortOrder
    User?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    Time?: SortOrder
    Description?: SortOrder
    User?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduleOrderByRelevanceInput = {
    fields: ScheduleOrderByRelevanceFieldEnum | ScheduleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    Time?: SortOrder
    Description?: SortOrder
    User?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    Time?: SortOrder
    Description?: SortOrder
    User?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    Time?: SortOrder
    Description?: SortOrder
    User?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyProjectOrderByRelevanceInput = {
    fields: CompanyProjectOrderByRelevanceFieldEnum | CompanyProjectOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CompanyProjectCountOrderByAggregateInput = {
    id?: SortOrder
    ProjectName?: SortOrder
    ProjectType?: SortOrder
    ProjectStatus?: SortOrder
    City?: SortOrder
    Location?: SortOrder
    Area?: SortOrder
    Range?: SortOrder
    Adderess?: SortOrder
    Facillities?: SortOrder
    Amenities?: SortOrder
    Description?: SortOrder
    Video?: SortOrder
    GoogleMap?: SortOrder
    CustomerImage?: SortOrder
    SitePlan?: SortOrder
    CreatedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    ProjectName?: SortOrder
    ProjectType?: SortOrder
    ProjectStatus?: SortOrder
    City?: SortOrder
    Location?: SortOrder
    Area?: SortOrder
    Range?: SortOrder
    Adderess?: SortOrder
    Facillities?: SortOrder
    Amenities?: SortOrder
    Description?: SortOrder
    Video?: SortOrder
    GoogleMap?: SortOrder
    CreatedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyProjectMinOrderByAggregateInput = {
    id?: SortOrder
    ProjectName?: SortOrder
    ProjectType?: SortOrder
    ProjectStatus?: SortOrder
    City?: SortOrder
    Location?: SortOrder
    Area?: SortOrder
    Range?: SortOrder
    Adderess?: SortOrder
    Facillities?: SortOrder
    Amenities?: SortOrder
    Description?: SortOrder
    Video?: SortOrder
    GoogleMap?: SortOrder
    CreatedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuilderSliderOrderByRelevanceInput = {
    fields: BuilderSliderOrderByRelevanceFieldEnum | BuilderSliderOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BuilderSliderCountOrderByAggregateInput = {
    id?: SortOrder
    Image?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuilderSliderMaxOrderByAggregateInput = {
    id?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuilderSliderMinOrderByAggregateInput = {
    id?: SortOrder
    Status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type FollowupListRelationFilter = {
    every?: FollowupWhereInput
    some?: FollowupWhereInput
    none?: FollowupWhereInput
  }

  export type FollowupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerOrderByRelevanceInput = {
    fields: CustomerOrderByRelevanceFieldEnum | CustomerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    Campaign?: SortOrder
    CustomerType?: SortOrder
    CustomerSubType?: SortOrder
    customerName?: SortOrder
    ContactNumber?: SortOrder
    City?: SortOrder
    Location?: SortOrder
    Area?: SortOrder
    Adderess?: SortOrder
    Email?: SortOrder
    Facillities?: SortOrder
    ReferenceId?: SortOrder
    CustomerId?: SortOrder
    CustomerDate?: SortOrder
    CustomerYear?: SortOrder
    Other?: SortOrder
    Description?: SortOrder
    Video?: SortOrder
    Verified?: SortOrder
    GoogleMap?: SortOrder
    CustomerImage?: SortOrder
    SitePlan?: SortOrder
    isFavourite?: SortOrder
    AssignToId?: SortOrder
    CreatedById?: SortOrder
    isImported?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    Campaign?: SortOrder
    CustomerType?: SortOrder
    CustomerSubType?: SortOrder
    customerName?: SortOrder
    ContactNumber?: SortOrder
    City?: SortOrder
    Location?: SortOrder
    Area?: SortOrder
    Adderess?: SortOrder
    Email?: SortOrder
    Facillities?: SortOrder
    ReferenceId?: SortOrder
    CustomerId?: SortOrder
    CustomerDate?: SortOrder
    CustomerYear?: SortOrder
    Other?: SortOrder
    Description?: SortOrder
    Video?: SortOrder
    Verified?: SortOrder
    GoogleMap?: SortOrder
    isFavourite?: SortOrder
    AssignToId?: SortOrder
    CreatedById?: SortOrder
    isImported?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    Campaign?: SortOrder
    CustomerType?: SortOrder
    CustomerSubType?: SortOrder
    customerName?: SortOrder
    ContactNumber?: SortOrder
    City?: SortOrder
    Location?: SortOrder
    Area?: SortOrder
    Adderess?: SortOrder
    Email?: SortOrder
    Facillities?: SortOrder
    ReferenceId?: SortOrder
    CustomerId?: SortOrder
    CustomerDate?: SortOrder
    CustomerYear?: SortOrder
    Other?: SortOrder
    Description?: SortOrder
    Video?: SortOrder
    Verified?: SortOrder
    GoogleMap?: SortOrder
    isFavourite?: SortOrder
    AssignToId?: SortOrder
    CreatedById?: SortOrder
    isImported?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type CustomerScalarRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type ContactNullableScalarRelationFilter = {
    is?: ContactWhereInput | null
    isNot?: ContactWhereInput | null
  }

  export type FollowupOrderByRelevanceInput = {
    fields: FollowupOrderByRelevanceFieldEnum | FollowupOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FollowupCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    StartDate?: SortOrder
    StatusType?: SortOrder
    FollowupNextDate?: SortOrder
    Description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contactId?: SortOrder
  }

  export type FollowupMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    StartDate?: SortOrder
    StatusType?: SortOrder
    FollowupNextDate?: SortOrder
    Description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contactId?: SortOrder
  }

  export type FollowupMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    StartDate?: SortOrder
    StatusType?: SortOrder
    FollowupNextDate?: SortOrder
    Description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contactId?: SortOrder
  }

  export type ContactFollowupListRelationFilter = {
    every?: ContactFollowupWhereInput
    some?: ContactFollowupWhereInput
    none?: ContactFollowupWhereInput
  }

  export type ContactFollowupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactOrderByRelevanceInput = {
    fields: ContactOrderByRelevanceFieldEnum | ContactOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ContactCountOrderByAggregateInput = {
    id?: SortOrder
    Campaign?: SortOrder
    Range?: SortOrder
    ContactNo?: SortOrder
    Location?: SortOrder
    ContactType?: SortOrder
    Name?: SortOrder
    City?: SortOrder
    Address?: SortOrder
    ContactIndustry?: SortOrder
    ContactFunctionalArea?: SortOrder
    ReferenceId?: SortOrder
    Notes?: SortOrder
    Facilities?: SortOrder
    date?: SortOrder
    Email?: SortOrder
    CompanyName?: SortOrder
    Website?: SortOrder
    Status?: SortOrder
    Qualifications?: SortOrder
    isFavourite?: SortOrder
    isImported?: SortOrder
    AssignToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    id?: SortOrder
    Campaign?: SortOrder
    Range?: SortOrder
    ContactNo?: SortOrder
    Location?: SortOrder
    ContactType?: SortOrder
    Name?: SortOrder
    City?: SortOrder
    Address?: SortOrder
    ContactIndustry?: SortOrder
    ContactFunctionalArea?: SortOrder
    ReferenceId?: SortOrder
    Notes?: SortOrder
    Facilities?: SortOrder
    date?: SortOrder
    Email?: SortOrder
    CompanyName?: SortOrder
    Website?: SortOrder
    Status?: SortOrder
    Qualifications?: SortOrder
    isFavourite?: SortOrder
    isImported?: SortOrder
    AssignToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    id?: SortOrder
    Campaign?: SortOrder
    Range?: SortOrder
    ContactNo?: SortOrder
    Location?: SortOrder
    ContactType?: SortOrder
    Name?: SortOrder
    City?: SortOrder
    Address?: SortOrder
    ContactIndustry?: SortOrder
    ContactFunctionalArea?: SortOrder
    ReferenceId?: SortOrder
    Notes?: SortOrder
    Facilities?: SortOrder
    date?: SortOrder
    Email?: SortOrder
    CompanyName?: SortOrder
    Website?: SortOrder
    Status?: SortOrder
    Qualifications?: SortOrder
    isFavourite?: SortOrder
    isImported?: SortOrder
    AssignToId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactScalarRelationFilter = {
    is?: ContactWhereInput
    isNot?: ContactWhereInput
  }

  export type ContactFollowupOrderByRelevanceInput = {
    fields: ContactFollowupOrderByRelevanceFieldEnum | ContactFollowupOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ContactFollowupCountOrderByAggregateInput = {
    id?: SortOrder
    contactId?: SortOrder
    StartDate?: SortOrder
    StatusType?: SortOrder
    FollowupNextDate?: SortOrder
    Description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactFollowupMaxOrderByAggregateInput = {
    id?: SortOrder
    contactId?: SortOrder
    StartDate?: SortOrder
    StatusType?: SortOrder
    FollowupNextDate?: SortOrder
    Description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactFollowupMinOrderByAggregateInput = {
    id?: SortOrder
    contactId?: SortOrder
    StartDate?: SortOrder
    StatusType?: SortOrder
    FollowupNextDate?: SortOrder
    Description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RequestUserOrderByRelevanceInput = {
    fields: RequestUserOrderByRelevanceFieldEnum | RequestUserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RequestUserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type RequestUserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type RequestUserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type AdminCreateNestedOneWithoutCreatedAdminsInput = {
    create?: XOR<AdminCreateWithoutCreatedAdminsInput, AdminUncheckedCreateWithoutCreatedAdminsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutCreatedAdminsInput
    connect?: AdminWhereUniqueInput
  }

  export type AdminCreateNestedManyWithoutCreatedByRefInput = {
    create?: XOR<AdminCreateWithoutCreatedByRefInput, AdminUncheckedCreateWithoutCreatedByRefInput> | AdminCreateWithoutCreatedByRefInput[] | AdminUncheckedCreateWithoutCreatedByRefInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutCreatedByRefInput | AdminCreateOrConnectWithoutCreatedByRefInput[]
    createMany?: AdminCreateManyCreatedByRefInputEnvelope
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type CustomerCreateNestedManyWithoutAssignToInput = {
    create?: XOR<CustomerCreateWithoutAssignToInput, CustomerUncheckedCreateWithoutAssignToInput> | CustomerCreateWithoutAssignToInput[] | CustomerUncheckedCreateWithoutAssignToInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutAssignToInput | CustomerCreateOrConnectWithoutAssignToInput[]
    createMany?: CustomerCreateManyAssignToInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type CustomerCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<CustomerCreateWithoutCreatedByInput, CustomerUncheckedCreateWithoutCreatedByInput> | CustomerCreateWithoutCreatedByInput[] | CustomerUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutCreatedByInput | CustomerCreateOrConnectWithoutCreatedByInput[]
    createMany?: CustomerCreateManyCreatedByInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type ContactCreateNestedManyWithoutAssignToInput = {
    create?: XOR<ContactCreateWithoutAssignToInput, ContactUncheckedCreateWithoutAssignToInput> | ContactCreateWithoutAssignToInput[] | ContactUncheckedCreateWithoutAssignToInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutAssignToInput | ContactCreateOrConnectWithoutAssignToInput[]
    createMany?: ContactCreateManyAssignToInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type AdminUncheckedCreateNestedManyWithoutCreatedByRefInput = {
    create?: XOR<AdminCreateWithoutCreatedByRefInput, AdminUncheckedCreateWithoutCreatedByRefInput> | AdminCreateWithoutCreatedByRefInput[] | AdminUncheckedCreateWithoutCreatedByRefInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutCreatedByRefInput | AdminCreateOrConnectWithoutCreatedByRefInput[]
    createMany?: AdminCreateManyCreatedByRefInputEnvelope
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedManyWithoutAssignToInput = {
    create?: XOR<CustomerCreateWithoutAssignToInput, CustomerUncheckedCreateWithoutAssignToInput> | CustomerCreateWithoutAssignToInput[] | CustomerUncheckedCreateWithoutAssignToInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutAssignToInput | CustomerCreateOrConnectWithoutAssignToInput[]
    createMany?: CustomerCreateManyAssignToInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<CustomerCreateWithoutCreatedByInput, CustomerUncheckedCreateWithoutCreatedByInput> | CustomerCreateWithoutCreatedByInput[] | CustomerUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutCreatedByInput | CustomerCreateOrConnectWithoutCreatedByInput[]
    createMany?: CustomerCreateManyCreatedByInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutAssignToInput = {
    create?: XOR<ContactCreateWithoutAssignToInput, ContactUncheckedCreateWithoutAssignToInput> | ContactCreateWithoutAssignToInput[] | ContactUncheckedCreateWithoutAssignToInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutAssignToInput | ContactCreateOrConnectWithoutAssignToInput[]
    createMany?: ContactCreateManyAssignToInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumAdminStatusFieldUpdateOperationsInput = {
    set?: $Enums.AdminStatus
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AdminUpdateOneWithoutCreatedAdminsNestedInput = {
    create?: XOR<AdminCreateWithoutCreatedAdminsInput, AdminUncheckedCreateWithoutCreatedAdminsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutCreatedAdminsInput
    upsert?: AdminUpsertWithoutCreatedAdminsInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutCreatedAdminsInput, AdminUpdateWithoutCreatedAdminsInput>, AdminUncheckedUpdateWithoutCreatedAdminsInput>
  }

  export type AdminUpdateManyWithoutCreatedByRefNestedInput = {
    create?: XOR<AdminCreateWithoutCreatedByRefInput, AdminUncheckedCreateWithoutCreatedByRefInput> | AdminCreateWithoutCreatedByRefInput[] | AdminUncheckedCreateWithoutCreatedByRefInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutCreatedByRefInput | AdminCreateOrConnectWithoutCreatedByRefInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutCreatedByRefInput | AdminUpsertWithWhereUniqueWithoutCreatedByRefInput[]
    createMany?: AdminCreateManyCreatedByRefInputEnvelope
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutCreatedByRefInput | AdminUpdateWithWhereUniqueWithoutCreatedByRefInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutCreatedByRefInput | AdminUpdateManyWithWhereWithoutCreatedByRefInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type CustomerUpdateManyWithoutAssignToNestedInput = {
    create?: XOR<CustomerCreateWithoutAssignToInput, CustomerUncheckedCreateWithoutAssignToInput> | CustomerCreateWithoutAssignToInput[] | CustomerUncheckedCreateWithoutAssignToInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutAssignToInput | CustomerCreateOrConnectWithoutAssignToInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutAssignToInput | CustomerUpsertWithWhereUniqueWithoutAssignToInput[]
    createMany?: CustomerCreateManyAssignToInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutAssignToInput | CustomerUpdateWithWhereUniqueWithoutAssignToInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutAssignToInput | CustomerUpdateManyWithWhereWithoutAssignToInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type CustomerUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<CustomerCreateWithoutCreatedByInput, CustomerUncheckedCreateWithoutCreatedByInput> | CustomerCreateWithoutCreatedByInput[] | CustomerUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutCreatedByInput | CustomerCreateOrConnectWithoutCreatedByInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutCreatedByInput | CustomerUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: CustomerCreateManyCreatedByInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutCreatedByInput | CustomerUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutCreatedByInput | CustomerUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type ContactUpdateManyWithoutAssignToNestedInput = {
    create?: XOR<ContactCreateWithoutAssignToInput, ContactUncheckedCreateWithoutAssignToInput> | ContactCreateWithoutAssignToInput[] | ContactUncheckedCreateWithoutAssignToInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutAssignToInput | ContactCreateOrConnectWithoutAssignToInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutAssignToInput | ContactUpsertWithWhereUniqueWithoutAssignToInput[]
    createMany?: ContactCreateManyAssignToInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutAssignToInput | ContactUpdateWithWhereUniqueWithoutAssignToInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutAssignToInput | ContactUpdateManyWithWhereWithoutAssignToInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type AdminUncheckedUpdateManyWithoutCreatedByRefNestedInput = {
    create?: XOR<AdminCreateWithoutCreatedByRefInput, AdminUncheckedCreateWithoutCreatedByRefInput> | AdminCreateWithoutCreatedByRefInput[] | AdminUncheckedCreateWithoutCreatedByRefInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutCreatedByRefInput | AdminCreateOrConnectWithoutCreatedByRefInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutCreatedByRefInput | AdminUpsertWithWhereUniqueWithoutCreatedByRefInput[]
    createMany?: AdminCreateManyCreatedByRefInputEnvelope
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutCreatedByRefInput | AdminUpdateWithWhereUniqueWithoutCreatedByRefInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutCreatedByRefInput | AdminUpdateManyWithWhereWithoutCreatedByRefInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateManyWithoutAssignToNestedInput = {
    create?: XOR<CustomerCreateWithoutAssignToInput, CustomerUncheckedCreateWithoutAssignToInput> | CustomerCreateWithoutAssignToInput[] | CustomerUncheckedCreateWithoutAssignToInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutAssignToInput | CustomerCreateOrConnectWithoutAssignToInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutAssignToInput | CustomerUpsertWithWhereUniqueWithoutAssignToInput[]
    createMany?: CustomerCreateManyAssignToInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutAssignToInput | CustomerUpdateWithWhereUniqueWithoutAssignToInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutAssignToInput | CustomerUpdateManyWithWhereWithoutAssignToInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<CustomerCreateWithoutCreatedByInput, CustomerUncheckedCreateWithoutCreatedByInput> | CustomerCreateWithoutCreatedByInput[] | CustomerUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutCreatedByInput | CustomerCreateOrConnectWithoutCreatedByInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutCreatedByInput | CustomerUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: CustomerCreateManyCreatedByInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutCreatedByInput | CustomerUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutCreatedByInput | CustomerUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutAssignToNestedInput = {
    create?: XOR<ContactCreateWithoutAssignToInput, ContactUncheckedCreateWithoutAssignToInput> | ContactCreateWithoutAssignToInput[] | ContactUncheckedCreateWithoutAssignToInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutAssignToInput | ContactCreateOrConnectWithoutAssignToInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutAssignToInput | ContactUpsertWithWhereUniqueWithoutAssignToInput[]
    createMany?: ContactCreateManyAssignToInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutAssignToInput | ContactUpdateWithWhereUniqueWithoutAssignToInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutAssignToInput | ContactUpdateManyWithWhereWithoutAssignToInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type TypeCreateNestedManyWithoutCampaignInput = {
    create?: XOR<TypeCreateWithoutCampaignInput, TypeUncheckedCreateWithoutCampaignInput> | TypeCreateWithoutCampaignInput[] | TypeUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: TypeCreateOrConnectWithoutCampaignInput | TypeCreateOrConnectWithoutCampaignInput[]
    createMany?: TypeCreateManyCampaignInputEnvelope
    connect?: TypeWhereUniqueInput | TypeWhereUniqueInput[]
  }

  export type SubTypeCreateNestedManyWithoutCampaignInput = {
    create?: XOR<SubTypeCreateWithoutCampaignInput, SubTypeUncheckedCreateWithoutCampaignInput> | SubTypeCreateWithoutCampaignInput[] | SubTypeUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: SubTypeCreateOrConnectWithoutCampaignInput | SubTypeCreateOrConnectWithoutCampaignInput[]
    createMany?: SubTypeCreateManyCampaignInputEnvelope
    connect?: SubTypeWhereUniqueInput | SubTypeWhereUniqueInput[]
  }

  export type TypeUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<TypeCreateWithoutCampaignInput, TypeUncheckedCreateWithoutCampaignInput> | TypeCreateWithoutCampaignInput[] | TypeUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: TypeCreateOrConnectWithoutCampaignInput | TypeCreateOrConnectWithoutCampaignInput[]
    createMany?: TypeCreateManyCampaignInputEnvelope
    connect?: TypeWhereUniqueInput | TypeWhereUniqueInput[]
  }

  export type SubTypeUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<SubTypeCreateWithoutCampaignInput, SubTypeUncheckedCreateWithoutCampaignInput> | SubTypeCreateWithoutCampaignInput[] | SubTypeUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: SubTypeCreateOrConnectWithoutCampaignInput | SubTypeCreateOrConnectWithoutCampaignInput[]
    createMany?: SubTypeCreateManyCampaignInputEnvelope
    connect?: SubTypeWhereUniqueInput | SubTypeWhereUniqueInput[]
  }

  export type EnumStatusFieldUpdateOperationsInput = {
    set?: $Enums.Status
  }

  export type TypeUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<TypeCreateWithoutCampaignInput, TypeUncheckedCreateWithoutCampaignInput> | TypeCreateWithoutCampaignInput[] | TypeUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: TypeCreateOrConnectWithoutCampaignInput | TypeCreateOrConnectWithoutCampaignInput[]
    upsert?: TypeUpsertWithWhereUniqueWithoutCampaignInput | TypeUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: TypeCreateManyCampaignInputEnvelope
    set?: TypeWhereUniqueInput | TypeWhereUniqueInput[]
    disconnect?: TypeWhereUniqueInput | TypeWhereUniqueInput[]
    delete?: TypeWhereUniqueInput | TypeWhereUniqueInput[]
    connect?: TypeWhereUniqueInput | TypeWhereUniqueInput[]
    update?: TypeUpdateWithWhereUniqueWithoutCampaignInput | TypeUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: TypeUpdateManyWithWhereWithoutCampaignInput | TypeUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: TypeScalarWhereInput | TypeScalarWhereInput[]
  }

  export type SubTypeUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<SubTypeCreateWithoutCampaignInput, SubTypeUncheckedCreateWithoutCampaignInput> | SubTypeCreateWithoutCampaignInput[] | SubTypeUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: SubTypeCreateOrConnectWithoutCampaignInput | SubTypeCreateOrConnectWithoutCampaignInput[]
    upsert?: SubTypeUpsertWithWhereUniqueWithoutCampaignInput | SubTypeUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: SubTypeCreateManyCampaignInputEnvelope
    set?: SubTypeWhereUniqueInput | SubTypeWhereUniqueInput[]
    disconnect?: SubTypeWhereUniqueInput | SubTypeWhereUniqueInput[]
    delete?: SubTypeWhereUniqueInput | SubTypeWhereUniqueInput[]
    connect?: SubTypeWhereUniqueInput | SubTypeWhereUniqueInput[]
    update?: SubTypeUpdateWithWhereUniqueWithoutCampaignInput | SubTypeUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: SubTypeUpdateManyWithWhereWithoutCampaignInput | SubTypeUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: SubTypeScalarWhereInput | SubTypeScalarWhereInput[]
  }

  export type TypeUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<TypeCreateWithoutCampaignInput, TypeUncheckedCreateWithoutCampaignInput> | TypeCreateWithoutCampaignInput[] | TypeUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: TypeCreateOrConnectWithoutCampaignInput | TypeCreateOrConnectWithoutCampaignInput[]
    upsert?: TypeUpsertWithWhereUniqueWithoutCampaignInput | TypeUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: TypeCreateManyCampaignInputEnvelope
    set?: TypeWhereUniqueInput | TypeWhereUniqueInput[]
    disconnect?: TypeWhereUniqueInput | TypeWhereUniqueInput[]
    delete?: TypeWhereUniqueInput | TypeWhereUniqueInput[]
    connect?: TypeWhereUniqueInput | TypeWhereUniqueInput[]
    update?: TypeUpdateWithWhereUniqueWithoutCampaignInput | TypeUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: TypeUpdateManyWithWhereWithoutCampaignInput | TypeUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: TypeScalarWhereInput | TypeScalarWhereInput[]
  }

  export type SubTypeUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<SubTypeCreateWithoutCampaignInput, SubTypeUncheckedCreateWithoutCampaignInput> | SubTypeCreateWithoutCampaignInput[] | SubTypeUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: SubTypeCreateOrConnectWithoutCampaignInput | SubTypeCreateOrConnectWithoutCampaignInput[]
    upsert?: SubTypeUpsertWithWhereUniqueWithoutCampaignInput | SubTypeUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: SubTypeCreateManyCampaignInputEnvelope
    set?: SubTypeWhereUniqueInput | SubTypeWhereUniqueInput[]
    disconnect?: SubTypeWhereUniqueInput | SubTypeWhereUniqueInput[]
    delete?: SubTypeWhereUniqueInput | SubTypeWhereUniqueInput[]
    connect?: SubTypeWhereUniqueInput | SubTypeWhereUniqueInput[]
    update?: SubTypeUpdateWithWhereUniqueWithoutCampaignInput | SubTypeUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: SubTypeUpdateManyWithWhereWithoutCampaignInput | SubTypeUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: SubTypeScalarWhereInput | SubTypeScalarWhereInput[]
  }

  export type CampaignCreateNestedOneWithoutTypesInput = {
    create?: XOR<CampaignCreateWithoutTypesInput, CampaignUncheckedCreateWithoutTypesInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutTypesInput
    connect?: CampaignWhereUniqueInput
  }

  export type SubTypeCreateNestedManyWithoutCustomerTypeInput = {
    create?: XOR<SubTypeCreateWithoutCustomerTypeInput, SubTypeUncheckedCreateWithoutCustomerTypeInput> | SubTypeCreateWithoutCustomerTypeInput[] | SubTypeUncheckedCreateWithoutCustomerTypeInput[]
    connectOrCreate?: SubTypeCreateOrConnectWithoutCustomerTypeInput | SubTypeCreateOrConnectWithoutCustomerTypeInput[]
    createMany?: SubTypeCreateManyCustomerTypeInputEnvelope
    connect?: SubTypeWhereUniqueInput | SubTypeWhereUniqueInput[]
  }

  export type SubTypeUncheckedCreateNestedManyWithoutCustomerTypeInput = {
    create?: XOR<SubTypeCreateWithoutCustomerTypeInput, SubTypeUncheckedCreateWithoutCustomerTypeInput> | SubTypeCreateWithoutCustomerTypeInput[] | SubTypeUncheckedCreateWithoutCustomerTypeInput[]
    connectOrCreate?: SubTypeCreateOrConnectWithoutCustomerTypeInput | SubTypeCreateOrConnectWithoutCustomerTypeInput[]
    createMany?: SubTypeCreateManyCustomerTypeInputEnvelope
    connect?: SubTypeWhereUniqueInput | SubTypeWhereUniqueInput[]
  }

  export type CampaignUpdateOneRequiredWithoutTypesNestedInput = {
    create?: XOR<CampaignCreateWithoutTypesInput, CampaignUncheckedCreateWithoutTypesInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutTypesInput
    upsert?: CampaignUpsertWithoutTypesInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutTypesInput, CampaignUpdateWithoutTypesInput>, CampaignUncheckedUpdateWithoutTypesInput>
  }

  export type SubTypeUpdateManyWithoutCustomerTypeNestedInput = {
    create?: XOR<SubTypeCreateWithoutCustomerTypeInput, SubTypeUncheckedCreateWithoutCustomerTypeInput> | SubTypeCreateWithoutCustomerTypeInput[] | SubTypeUncheckedCreateWithoutCustomerTypeInput[]
    connectOrCreate?: SubTypeCreateOrConnectWithoutCustomerTypeInput | SubTypeCreateOrConnectWithoutCustomerTypeInput[]
    upsert?: SubTypeUpsertWithWhereUniqueWithoutCustomerTypeInput | SubTypeUpsertWithWhereUniqueWithoutCustomerTypeInput[]
    createMany?: SubTypeCreateManyCustomerTypeInputEnvelope
    set?: SubTypeWhereUniqueInput | SubTypeWhereUniqueInput[]
    disconnect?: SubTypeWhereUniqueInput | SubTypeWhereUniqueInput[]
    delete?: SubTypeWhereUniqueInput | SubTypeWhereUniqueInput[]
    connect?: SubTypeWhereUniqueInput | SubTypeWhereUniqueInput[]
    update?: SubTypeUpdateWithWhereUniqueWithoutCustomerTypeInput | SubTypeUpdateWithWhereUniqueWithoutCustomerTypeInput[]
    updateMany?: SubTypeUpdateManyWithWhereWithoutCustomerTypeInput | SubTypeUpdateManyWithWhereWithoutCustomerTypeInput[]
    deleteMany?: SubTypeScalarWhereInput | SubTypeScalarWhereInput[]
  }

  export type SubTypeUncheckedUpdateManyWithoutCustomerTypeNestedInput = {
    create?: XOR<SubTypeCreateWithoutCustomerTypeInput, SubTypeUncheckedCreateWithoutCustomerTypeInput> | SubTypeCreateWithoutCustomerTypeInput[] | SubTypeUncheckedCreateWithoutCustomerTypeInput[]
    connectOrCreate?: SubTypeCreateOrConnectWithoutCustomerTypeInput | SubTypeCreateOrConnectWithoutCustomerTypeInput[]
    upsert?: SubTypeUpsertWithWhereUniqueWithoutCustomerTypeInput | SubTypeUpsertWithWhereUniqueWithoutCustomerTypeInput[]
    createMany?: SubTypeCreateManyCustomerTypeInputEnvelope
    set?: SubTypeWhereUniqueInput | SubTypeWhereUniqueInput[]
    disconnect?: SubTypeWhereUniqueInput | SubTypeWhereUniqueInput[]
    delete?: SubTypeWhereUniqueInput | SubTypeWhereUniqueInput[]
    connect?: SubTypeWhereUniqueInput | SubTypeWhereUniqueInput[]
    update?: SubTypeUpdateWithWhereUniqueWithoutCustomerTypeInput | SubTypeUpdateWithWhereUniqueWithoutCustomerTypeInput[]
    updateMany?: SubTypeUpdateManyWithWhereWithoutCustomerTypeInput | SubTypeUpdateManyWithWhereWithoutCustomerTypeInput[]
    deleteMany?: SubTypeScalarWhereInput | SubTypeScalarWhereInput[]
  }

  export type CampaignCreateNestedOneWithoutSubTypesInput = {
    create?: XOR<CampaignCreateWithoutSubTypesInput, CampaignUncheckedCreateWithoutSubTypesInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutSubTypesInput
    connect?: CampaignWhereUniqueInput
  }

  export type TypeCreateNestedOneWithoutSubTypesInput = {
    create?: XOR<TypeCreateWithoutSubTypesInput, TypeUncheckedCreateWithoutSubTypesInput>
    connectOrCreate?: TypeCreateOrConnectWithoutSubTypesInput
    connect?: TypeWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutSubTypesNestedInput = {
    create?: XOR<CampaignCreateWithoutSubTypesInput, CampaignUncheckedCreateWithoutSubTypesInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutSubTypesInput
    upsert?: CampaignUpsertWithoutSubTypesInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutSubTypesInput, CampaignUpdateWithoutSubTypesInput>, CampaignUncheckedUpdateWithoutSubTypesInput>
  }

  export type TypeUpdateOneRequiredWithoutSubTypesNestedInput = {
    create?: XOR<TypeCreateWithoutSubTypesInput, TypeUncheckedCreateWithoutSubTypesInput>
    connectOrCreate?: TypeCreateOrConnectWithoutSubTypesInput
    upsert?: TypeUpsertWithoutSubTypesInput
    connect?: TypeWhereUniqueInput
    update?: XOR<XOR<TypeUpdateToOneWithWhereWithoutSubTypesInput, TypeUpdateWithoutSubTypesInput>, TypeUncheckedUpdateWithoutSubTypesInput>
  }

  export type ContactTypeCreateNestedManyWithoutCampaignInput = {
    create?: XOR<ContactTypeCreateWithoutCampaignInput, ContactTypeUncheckedCreateWithoutCampaignInput> | ContactTypeCreateWithoutCampaignInput[] | ContactTypeUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: ContactTypeCreateOrConnectWithoutCampaignInput | ContactTypeCreateOrConnectWithoutCampaignInput[]
    createMany?: ContactTypeCreateManyCampaignInputEnvelope
    connect?: ContactTypeWhereUniqueInput | ContactTypeWhereUniqueInput[]
  }

  export type ContactTypeUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<ContactTypeCreateWithoutCampaignInput, ContactTypeUncheckedCreateWithoutCampaignInput> | ContactTypeCreateWithoutCampaignInput[] | ContactTypeUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: ContactTypeCreateOrConnectWithoutCampaignInput | ContactTypeCreateOrConnectWithoutCampaignInput[]
    createMany?: ContactTypeCreateManyCampaignInputEnvelope
    connect?: ContactTypeWhereUniqueInput | ContactTypeWhereUniqueInput[]
  }

  export type ContactTypeUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<ContactTypeCreateWithoutCampaignInput, ContactTypeUncheckedCreateWithoutCampaignInput> | ContactTypeCreateWithoutCampaignInput[] | ContactTypeUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: ContactTypeCreateOrConnectWithoutCampaignInput | ContactTypeCreateOrConnectWithoutCampaignInput[]
    upsert?: ContactTypeUpsertWithWhereUniqueWithoutCampaignInput | ContactTypeUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: ContactTypeCreateManyCampaignInputEnvelope
    set?: ContactTypeWhereUniqueInput | ContactTypeWhereUniqueInput[]
    disconnect?: ContactTypeWhereUniqueInput | ContactTypeWhereUniqueInput[]
    delete?: ContactTypeWhereUniqueInput | ContactTypeWhereUniqueInput[]
    connect?: ContactTypeWhereUniqueInput | ContactTypeWhereUniqueInput[]
    update?: ContactTypeUpdateWithWhereUniqueWithoutCampaignInput | ContactTypeUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: ContactTypeUpdateManyWithWhereWithoutCampaignInput | ContactTypeUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: ContactTypeScalarWhereInput | ContactTypeScalarWhereInput[]
  }

  export type ContactTypeUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<ContactTypeCreateWithoutCampaignInput, ContactTypeUncheckedCreateWithoutCampaignInput> | ContactTypeCreateWithoutCampaignInput[] | ContactTypeUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: ContactTypeCreateOrConnectWithoutCampaignInput | ContactTypeCreateOrConnectWithoutCampaignInput[]
    upsert?: ContactTypeUpsertWithWhereUniqueWithoutCampaignInput | ContactTypeUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: ContactTypeCreateManyCampaignInputEnvelope
    set?: ContactTypeWhereUniqueInput | ContactTypeWhereUniqueInput[]
    disconnect?: ContactTypeWhereUniqueInput | ContactTypeWhereUniqueInput[]
    delete?: ContactTypeWhereUniqueInput | ContactTypeWhereUniqueInput[]
    connect?: ContactTypeWhereUniqueInput | ContactTypeWhereUniqueInput[]
    update?: ContactTypeUpdateWithWhereUniqueWithoutCampaignInput | ContactTypeUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: ContactTypeUpdateManyWithWhereWithoutCampaignInput | ContactTypeUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: ContactTypeScalarWhereInput | ContactTypeScalarWhereInput[]
  }

  export type ContactCampaignCreateNestedOneWithoutContactTypesInput = {
    create?: XOR<ContactCampaignCreateWithoutContactTypesInput, ContactCampaignUncheckedCreateWithoutContactTypesInput>
    connectOrCreate?: ContactCampaignCreateOrConnectWithoutContactTypesInput
    connect?: ContactCampaignWhereUniqueInput
  }

  export type ContactCampaignUpdateOneRequiredWithoutContactTypesNestedInput = {
    create?: XOR<ContactCampaignCreateWithoutContactTypesInput, ContactCampaignUncheckedCreateWithoutContactTypesInput>
    connectOrCreate?: ContactCampaignCreateOrConnectWithoutContactTypesInput
    upsert?: ContactCampaignUpsertWithoutContactTypesInput
    connect?: ContactCampaignWhereUniqueInput
    update?: XOR<XOR<ContactCampaignUpdateToOneWithWhereWithoutContactTypesInput, ContactCampaignUpdateWithoutContactTypesInput>, ContactCampaignUncheckedUpdateWithoutContactTypesInput>
  }

  export type LocationCreateNestedManyWithoutCityInput = {
    create?: XOR<LocationCreateWithoutCityInput, LocationUncheckedCreateWithoutCityInput> | LocationCreateWithoutCityInput[] | LocationUncheckedCreateWithoutCityInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutCityInput | LocationCreateOrConnectWithoutCityInput[]
    createMany?: LocationCreateManyCityInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type LocationUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<LocationCreateWithoutCityInput, LocationUncheckedCreateWithoutCityInput> | LocationCreateWithoutCityInput[] | LocationUncheckedCreateWithoutCityInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutCityInput | LocationCreateOrConnectWithoutCityInput[]
    createMany?: LocationCreateManyCityInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type LocationUpdateManyWithoutCityNestedInput = {
    create?: XOR<LocationCreateWithoutCityInput, LocationUncheckedCreateWithoutCityInput> | LocationCreateWithoutCityInput[] | LocationUncheckedCreateWithoutCityInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutCityInput | LocationCreateOrConnectWithoutCityInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutCityInput | LocationUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: LocationCreateManyCityInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutCityInput | LocationUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutCityInput | LocationUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type LocationUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<LocationCreateWithoutCityInput, LocationUncheckedCreateWithoutCityInput> | LocationCreateWithoutCityInput[] | LocationUncheckedCreateWithoutCityInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutCityInput | LocationCreateOrConnectWithoutCityInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutCityInput | LocationUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: LocationCreateManyCityInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutCityInput | LocationUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutCityInput | LocationUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type CityCreateNestedOneWithoutLocationsInput = {
    create?: XOR<CityCreateWithoutLocationsInput, CityUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: CityCreateOrConnectWithoutLocationsInput
    connect?: CityWhereUniqueInput
  }

  export type CityUpdateOneRequiredWithoutLocationsNestedInput = {
    create?: XOR<CityCreateWithoutLocationsInput, CityUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: CityCreateOrConnectWithoutLocationsInput
    upsert?: CityUpsertWithoutLocationsInput
    connect?: CityWhereUniqueInput
    update?: XOR<XOR<CityUpdateToOneWithWhereWithoutLocationsInput, CityUpdateWithoutLocationsInput>, CityUncheckedUpdateWithoutLocationsInput>
  }

  export type AdminCreateNestedOneWithoutAssignedCustomersInput = {
    create?: XOR<AdminCreateWithoutAssignedCustomersInput, AdminUncheckedCreateWithoutAssignedCustomersInput>
    connectOrCreate?: AdminCreateOrConnectWithoutAssignedCustomersInput
    connect?: AdminWhereUniqueInput
  }

  export type AdminCreateNestedOneWithoutCreatedCustomersInput = {
    create?: XOR<AdminCreateWithoutCreatedCustomersInput, AdminUncheckedCreateWithoutCreatedCustomersInput>
    connectOrCreate?: AdminCreateOrConnectWithoutCreatedCustomersInput
    connect?: AdminWhereUniqueInput
  }

  export type FollowupCreateNestedManyWithoutCustomerInput = {
    create?: XOR<FollowupCreateWithoutCustomerInput, FollowupUncheckedCreateWithoutCustomerInput> | FollowupCreateWithoutCustomerInput[] | FollowupUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: FollowupCreateOrConnectWithoutCustomerInput | FollowupCreateOrConnectWithoutCustomerInput[]
    createMany?: FollowupCreateManyCustomerInputEnvelope
    connect?: FollowupWhereUniqueInput | FollowupWhereUniqueInput[]
  }

  export type FollowupUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<FollowupCreateWithoutCustomerInput, FollowupUncheckedCreateWithoutCustomerInput> | FollowupCreateWithoutCustomerInput[] | FollowupUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: FollowupCreateOrConnectWithoutCustomerInput | FollowupCreateOrConnectWithoutCustomerInput[]
    createMany?: FollowupCreateManyCustomerInputEnvelope
    connect?: FollowupWhereUniqueInput | FollowupWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type AdminUpdateOneWithoutAssignedCustomersNestedInput = {
    create?: XOR<AdminCreateWithoutAssignedCustomersInput, AdminUncheckedCreateWithoutAssignedCustomersInput>
    connectOrCreate?: AdminCreateOrConnectWithoutAssignedCustomersInput
    upsert?: AdminUpsertWithoutAssignedCustomersInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutAssignedCustomersInput, AdminUpdateWithoutAssignedCustomersInput>, AdminUncheckedUpdateWithoutAssignedCustomersInput>
  }

  export type AdminUpdateOneWithoutCreatedCustomersNestedInput = {
    create?: XOR<AdminCreateWithoutCreatedCustomersInput, AdminUncheckedCreateWithoutCreatedCustomersInput>
    connectOrCreate?: AdminCreateOrConnectWithoutCreatedCustomersInput
    upsert?: AdminUpsertWithoutCreatedCustomersInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutCreatedCustomersInput, AdminUpdateWithoutCreatedCustomersInput>, AdminUncheckedUpdateWithoutCreatedCustomersInput>
  }

  export type FollowupUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<FollowupCreateWithoutCustomerInput, FollowupUncheckedCreateWithoutCustomerInput> | FollowupCreateWithoutCustomerInput[] | FollowupUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: FollowupCreateOrConnectWithoutCustomerInput | FollowupCreateOrConnectWithoutCustomerInput[]
    upsert?: FollowupUpsertWithWhereUniqueWithoutCustomerInput | FollowupUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: FollowupCreateManyCustomerInputEnvelope
    set?: FollowupWhereUniqueInput | FollowupWhereUniqueInput[]
    disconnect?: FollowupWhereUniqueInput | FollowupWhereUniqueInput[]
    delete?: FollowupWhereUniqueInput | FollowupWhereUniqueInput[]
    connect?: FollowupWhereUniqueInput | FollowupWhereUniqueInput[]
    update?: FollowupUpdateWithWhereUniqueWithoutCustomerInput | FollowupUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: FollowupUpdateManyWithWhereWithoutCustomerInput | FollowupUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: FollowupScalarWhereInput | FollowupScalarWhereInput[]
  }

  export type FollowupUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<FollowupCreateWithoutCustomerInput, FollowupUncheckedCreateWithoutCustomerInput> | FollowupCreateWithoutCustomerInput[] | FollowupUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: FollowupCreateOrConnectWithoutCustomerInput | FollowupCreateOrConnectWithoutCustomerInput[]
    upsert?: FollowupUpsertWithWhereUniqueWithoutCustomerInput | FollowupUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: FollowupCreateManyCustomerInputEnvelope
    set?: FollowupWhereUniqueInput | FollowupWhereUniqueInput[]
    disconnect?: FollowupWhereUniqueInput | FollowupWhereUniqueInput[]
    delete?: FollowupWhereUniqueInput | FollowupWhereUniqueInput[]
    connect?: FollowupWhereUniqueInput | FollowupWhereUniqueInput[]
    update?: FollowupUpdateWithWhereUniqueWithoutCustomerInput | FollowupUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: FollowupUpdateManyWithWhereWithoutCustomerInput | FollowupUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: FollowupScalarWhereInput | FollowupScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutFollowupsInput = {
    create?: XOR<CustomerCreateWithoutFollowupsInput, CustomerUncheckedCreateWithoutFollowupsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutFollowupsInput
    connect?: CustomerWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutFollowupsInput = {
    create?: XOR<ContactCreateWithoutFollowupsInput, ContactUncheckedCreateWithoutFollowupsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutFollowupsInput
    connect?: ContactWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutFollowupsNestedInput = {
    create?: XOR<CustomerCreateWithoutFollowupsInput, CustomerUncheckedCreateWithoutFollowupsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutFollowupsInput
    upsert?: CustomerUpsertWithoutFollowupsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutFollowupsInput, CustomerUpdateWithoutFollowupsInput>, CustomerUncheckedUpdateWithoutFollowupsInput>
  }

  export type ContactUpdateOneWithoutFollowupsNestedInput = {
    create?: XOR<ContactCreateWithoutFollowupsInput, ContactUncheckedCreateWithoutFollowupsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutFollowupsInput
    upsert?: ContactUpsertWithoutFollowupsInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutFollowupsInput, ContactUpdateWithoutFollowupsInput>, ContactUncheckedUpdateWithoutFollowupsInput>
  }

  export type AdminCreateNestedOneWithoutAssignedContactInput = {
    create?: XOR<AdminCreateWithoutAssignedContactInput, AdminUncheckedCreateWithoutAssignedContactInput>
    connectOrCreate?: AdminCreateOrConnectWithoutAssignedContactInput
    connect?: AdminWhereUniqueInput
  }

  export type FollowupCreateNestedManyWithoutContactInput = {
    create?: XOR<FollowupCreateWithoutContactInput, FollowupUncheckedCreateWithoutContactInput> | FollowupCreateWithoutContactInput[] | FollowupUncheckedCreateWithoutContactInput[]
    connectOrCreate?: FollowupCreateOrConnectWithoutContactInput | FollowupCreateOrConnectWithoutContactInput[]
    createMany?: FollowupCreateManyContactInputEnvelope
    connect?: FollowupWhereUniqueInput | FollowupWhereUniqueInput[]
  }

  export type ContactFollowupCreateNestedManyWithoutContactInput = {
    create?: XOR<ContactFollowupCreateWithoutContactInput, ContactFollowupUncheckedCreateWithoutContactInput> | ContactFollowupCreateWithoutContactInput[] | ContactFollowupUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactFollowupCreateOrConnectWithoutContactInput | ContactFollowupCreateOrConnectWithoutContactInput[]
    createMany?: ContactFollowupCreateManyContactInputEnvelope
    connect?: ContactFollowupWhereUniqueInput | ContactFollowupWhereUniqueInput[]
  }

  export type FollowupUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<FollowupCreateWithoutContactInput, FollowupUncheckedCreateWithoutContactInput> | FollowupCreateWithoutContactInput[] | FollowupUncheckedCreateWithoutContactInput[]
    connectOrCreate?: FollowupCreateOrConnectWithoutContactInput | FollowupCreateOrConnectWithoutContactInput[]
    createMany?: FollowupCreateManyContactInputEnvelope
    connect?: FollowupWhereUniqueInput | FollowupWhereUniqueInput[]
  }

  export type ContactFollowupUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<ContactFollowupCreateWithoutContactInput, ContactFollowupUncheckedCreateWithoutContactInput> | ContactFollowupCreateWithoutContactInput[] | ContactFollowupUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactFollowupCreateOrConnectWithoutContactInput | ContactFollowupCreateOrConnectWithoutContactInput[]
    createMany?: ContactFollowupCreateManyContactInputEnvelope
    connect?: ContactFollowupWhereUniqueInput | ContactFollowupWhereUniqueInput[]
  }

  export type AdminUpdateOneWithoutAssignedContactNestedInput = {
    create?: XOR<AdminCreateWithoutAssignedContactInput, AdminUncheckedCreateWithoutAssignedContactInput>
    connectOrCreate?: AdminCreateOrConnectWithoutAssignedContactInput
    upsert?: AdminUpsertWithoutAssignedContactInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutAssignedContactInput, AdminUpdateWithoutAssignedContactInput>, AdminUncheckedUpdateWithoutAssignedContactInput>
  }

  export type FollowupUpdateManyWithoutContactNestedInput = {
    create?: XOR<FollowupCreateWithoutContactInput, FollowupUncheckedCreateWithoutContactInput> | FollowupCreateWithoutContactInput[] | FollowupUncheckedCreateWithoutContactInput[]
    connectOrCreate?: FollowupCreateOrConnectWithoutContactInput | FollowupCreateOrConnectWithoutContactInput[]
    upsert?: FollowupUpsertWithWhereUniqueWithoutContactInput | FollowupUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: FollowupCreateManyContactInputEnvelope
    set?: FollowupWhereUniqueInput | FollowupWhereUniqueInput[]
    disconnect?: FollowupWhereUniqueInput | FollowupWhereUniqueInput[]
    delete?: FollowupWhereUniqueInput | FollowupWhereUniqueInput[]
    connect?: FollowupWhereUniqueInput | FollowupWhereUniqueInput[]
    update?: FollowupUpdateWithWhereUniqueWithoutContactInput | FollowupUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: FollowupUpdateManyWithWhereWithoutContactInput | FollowupUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: FollowupScalarWhereInput | FollowupScalarWhereInput[]
  }

  export type ContactFollowupUpdateManyWithoutContactNestedInput = {
    create?: XOR<ContactFollowupCreateWithoutContactInput, ContactFollowupUncheckedCreateWithoutContactInput> | ContactFollowupCreateWithoutContactInput[] | ContactFollowupUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactFollowupCreateOrConnectWithoutContactInput | ContactFollowupCreateOrConnectWithoutContactInput[]
    upsert?: ContactFollowupUpsertWithWhereUniqueWithoutContactInput | ContactFollowupUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ContactFollowupCreateManyContactInputEnvelope
    set?: ContactFollowupWhereUniqueInput | ContactFollowupWhereUniqueInput[]
    disconnect?: ContactFollowupWhereUniqueInput | ContactFollowupWhereUniqueInput[]
    delete?: ContactFollowupWhereUniqueInput | ContactFollowupWhereUniqueInput[]
    connect?: ContactFollowupWhereUniqueInput | ContactFollowupWhereUniqueInput[]
    update?: ContactFollowupUpdateWithWhereUniqueWithoutContactInput | ContactFollowupUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ContactFollowupUpdateManyWithWhereWithoutContactInput | ContactFollowupUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ContactFollowupScalarWhereInput | ContactFollowupScalarWhereInput[]
  }

  export type FollowupUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<FollowupCreateWithoutContactInput, FollowupUncheckedCreateWithoutContactInput> | FollowupCreateWithoutContactInput[] | FollowupUncheckedCreateWithoutContactInput[]
    connectOrCreate?: FollowupCreateOrConnectWithoutContactInput | FollowupCreateOrConnectWithoutContactInput[]
    upsert?: FollowupUpsertWithWhereUniqueWithoutContactInput | FollowupUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: FollowupCreateManyContactInputEnvelope
    set?: FollowupWhereUniqueInput | FollowupWhereUniqueInput[]
    disconnect?: FollowupWhereUniqueInput | FollowupWhereUniqueInput[]
    delete?: FollowupWhereUniqueInput | FollowupWhereUniqueInput[]
    connect?: FollowupWhereUniqueInput | FollowupWhereUniqueInput[]
    update?: FollowupUpdateWithWhereUniqueWithoutContactInput | FollowupUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: FollowupUpdateManyWithWhereWithoutContactInput | FollowupUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: FollowupScalarWhereInput | FollowupScalarWhereInput[]
  }

  export type ContactFollowupUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<ContactFollowupCreateWithoutContactInput, ContactFollowupUncheckedCreateWithoutContactInput> | ContactFollowupCreateWithoutContactInput[] | ContactFollowupUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactFollowupCreateOrConnectWithoutContactInput | ContactFollowupCreateOrConnectWithoutContactInput[]
    upsert?: ContactFollowupUpsertWithWhereUniqueWithoutContactInput | ContactFollowupUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ContactFollowupCreateManyContactInputEnvelope
    set?: ContactFollowupWhereUniqueInput | ContactFollowupWhereUniqueInput[]
    disconnect?: ContactFollowupWhereUniqueInput | ContactFollowupWhereUniqueInput[]
    delete?: ContactFollowupWhereUniqueInput | ContactFollowupWhereUniqueInput[]
    connect?: ContactFollowupWhereUniqueInput | ContactFollowupWhereUniqueInput[]
    update?: ContactFollowupUpdateWithWhereUniqueWithoutContactInput | ContactFollowupUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ContactFollowupUpdateManyWithWhereWithoutContactInput | ContactFollowupUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ContactFollowupScalarWhereInput | ContactFollowupScalarWhereInput[]
  }

  export type ContactCreateNestedOneWithoutContactFollowupsInput = {
    create?: XOR<ContactCreateWithoutContactFollowupsInput, ContactUncheckedCreateWithoutContactFollowupsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutContactFollowupsInput
    connect?: ContactWhereUniqueInput
  }

  export type ContactUpdateOneRequiredWithoutContactFollowupsNestedInput = {
    create?: XOR<ContactCreateWithoutContactFollowupsInput, ContactUncheckedCreateWithoutContactFollowupsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutContactFollowupsInput
    upsert?: ContactUpsertWithoutContactFollowupsInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutContactFollowupsInput, ContactUpdateWithoutContactFollowupsInput>, ContactUncheckedUpdateWithoutContactFollowupsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumAdminStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminStatus | EnumAdminStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdminStatus[]
    notIn?: $Enums.AdminStatus[]
    not?: NestedEnumAdminStatusFilter<$PrismaModel> | $Enums.AdminStatus
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[]
    notIn?: $Enums.Role[]
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumAdminStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminStatus | EnumAdminStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdminStatus[]
    notIn?: $Enums.AdminStatus[]
    not?: NestedEnumAdminStatusWithAggregatesFilter<$PrismaModel> | $Enums.AdminStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminStatusFilter<$PrismaModel>
    _max?: NestedEnumAdminStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[]
    notIn?: $Enums.Status[]
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type NestedEnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[]
    notIn?: $Enums.Status[]
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type AdminCreateWithoutCreatedAdminsInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.Role
    city?: string | null
    phone?: string | null
    status?: $Enums.AdminStatus
    AddressLine1?: string | null
    AddressLine2?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByRef?: AdminCreateNestedOneWithoutCreatedAdminsInput
    assignedCustomers?: CustomerCreateNestedManyWithoutAssignToInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatedByInput
    assignedContact?: ContactCreateNestedManyWithoutAssignToInput
  }

  export type AdminUncheckedCreateWithoutCreatedAdminsInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.Role
    city?: string | null
    phone?: string | null
    status?: $Enums.AdminStatus
    AddressLine1?: string | null
    AddressLine2?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedCustomers?: CustomerUncheckedCreateNestedManyWithoutAssignToInput
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatedByInput
    assignedContact?: ContactUncheckedCreateNestedManyWithoutAssignToInput
  }

  export type AdminCreateOrConnectWithoutCreatedAdminsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutCreatedAdminsInput, AdminUncheckedCreateWithoutCreatedAdminsInput>
  }

  export type AdminCreateWithoutCreatedByRefInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.Role
    city?: string | null
    phone?: string | null
    status?: $Enums.AdminStatus
    AddressLine1?: string | null
    AddressLine2?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdAdmins?: AdminCreateNestedManyWithoutCreatedByRefInput
    assignedCustomers?: CustomerCreateNestedManyWithoutAssignToInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatedByInput
    assignedContact?: ContactCreateNestedManyWithoutAssignToInput
  }

  export type AdminUncheckedCreateWithoutCreatedByRefInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.Role
    city?: string | null
    phone?: string | null
    status?: $Enums.AdminStatus
    AddressLine1?: string | null
    AddressLine2?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdAdmins?: AdminUncheckedCreateNestedManyWithoutCreatedByRefInput
    assignedCustomers?: CustomerUncheckedCreateNestedManyWithoutAssignToInput
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatedByInput
    assignedContact?: ContactUncheckedCreateNestedManyWithoutAssignToInput
  }

  export type AdminCreateOrConnectWithoutCreatedByRefInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutCreatedByRefInput, AdminUncheckedCreateWithoutCreatedByRefInput>
  }

  export type AdminCreateManyCreatedByRefInputEnvelope = {
    data: AdminCreateManyCreatedByRefInput | AdminCreateManyCreatedByRefInput[]
    skipDuplicates?: boolean
  }

  export type CustomerCreateWithoutAssignToInput = {
    id?: string
    Campaign?: string | null
    CustomerType?: string | null
    CustomerSubType?: string | null
    customerName: string
    ContactNumber: string
    City?: string | null
    Location?: string | null
    Area?: string | null
    Adderess?: string | null
    Email?: string | null
    Facillities?: string | null
    ReferenceId?: string | null
    CustomerId?: string | null
    CustomerDate?: string | null
    CustomerYear?: string | null
    Other?: string | null
    Description?: string | null
    Video?: string | null
    Verified?: string | null
    GoogleMap?: string | null
    CustomerImage?: NullableJsonNullValueInput | InputJsonValue
    SitePlan?: NullableJsonNullValueInput | InputJsonValue
    isFavourite?: boolean
    isImported?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    CreatedBy?: AdminCreateNestedOneWithoutCreatedCustomersInput
    followups?: FollowupCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutAssignToInput = {
    id?: string
    Campaign?: string | null
    CustomerType?: string | null
    CustomerSubType?: string | null
    customerName: string
    ContactNumber: string
    City?: string | null
    Location?: string | null
    Area?: string | null
    Adderess?: string | null
    Email?: string | null
    Facillities?: string | null
    ReferenceId?: string | null
    CustomerId?: string | null
    CustomerDate?: string | null
    CustomerYear?: string | null
    Other?: string | null
    Description?: string | null
    Video?: string | null
    Verified?: string | null
    GoogleMap?: string | null
    CustomerImage?: NullableJsonNullValueInput | InputJsonValue
    SitePlan?: NullableJsonNullValueInput | InputJsonValue
    isFavourite?: boolean
    CreatedById?: string | null
    isImported?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    followups?: FollowupUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutAssignToInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutAssignToInput, CustomerUncheckedCreateWithoutAssignToInput>
  }

  export type CustomerCreateManyAssignToInputEnvelope = {
    data: CustomerCreateManyAssignToInput | CustomerCreateManyAssignToInput[]
    skipDuplicates?: boolean
  }

  export type CustomerCreateWithoutCreatedByInput = {
    id?: string
    Campaign?: string | null
    CustomerType?: string | null
    CustomerSubType?: string | null
    customerName: string
    ContactNumber: string
    City?: string | null
    Location?: string | null
    Area?: string | null
    Adderess?: string | null
    Email?: string | null
    Facillities?: string | null
    ReferenceId?: string | null
    CustomerId?: string | null
    CustomerDate?: string | null
    CustomerYear?: string | null
    Other?: string | null
    Description?: string | null
    Video?: string | null
    Verified?: string | null
    GoogleMap?: string | null
    CustomerImage?: NullableJsonNullValueInput | InputJsonValue
    SitePlan?: NullableJsonNullValueInput | InputJsonValue
    isFavourite?: boolean
    isImported?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    AssignTo?: AdminCreateNestedOneWithoutAssignedCustomersInput
    followups?: FollowupCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutCreatedByInput = {
    id?: string
    Campaign?: string | null
    CustomerType?: string | null
    CustomerSubType?: string | null
    customerName: string
    ContactNumber: string
    City?: string | null
    Location?: string | null
    Area?: string | null
    Adderess?: string | null
    Email?: string | null
    Facillities?: string | null
    ReferenceId?: string | null
    CustomerId?: string | null
    CustomerDate?: string | null
    CustomerYear?: string | null
    Other?: string | null
    Description?: string | null
    Video?: string | null
    Verified?: string | null
    GoogleMap?: string | null
    CustomerImage?: NullableJsonNullValueInput | InputJsonValue
    SitePlan?: NullableJsonNullValueInput | InputJsonValue
    isFavourite?: boolean
    AssignToId?: string | null
    isImported?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    followups?: FollowupUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutCreatedByInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutCreatedByInput, CustomerUncheckedCreateWithoutCreatedByInput>
  }

  export type CustomerCreateManyCreatedByInputEnvelope = {
    data: CustomerCreateManyCreatedByInput | CustomerCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutAssignToInput = {
    id?: string
    Campaign?: string | null
    Range?: string | null
    ContactNo?: string | null
    Location?: string | null
    ContactType?: string | null
    Name?: string
    City?: string | null
    Address?: string | null
    ContactIndustry?: string | null
    ContactFunctionalArea?: string | null
    ReferenceId?: string | null
    Notes?: string | null
    Facilities?: string | null
    date?: string | null
    Email?: string | null
    CompanyName?: string | null
    Website?: string | null
    Status?: string | null
    Qualifications?: string | null
    isFavourite?: boolean
    isImported?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    followups?: FollowupCreateNestedManyWithoutContactInput
    contactFollowups?: ContactFollowupCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutAssignToInput = {
    id?: string
    Campaign?: string | null
    Range?: string | null
    ContactNo?: string | null
    Location?: string | null
    ContactType?: string | null
    Name?: string
    City?: string | null
    Address?: string | null
    ContactIndustry?: string | null
    ContactFunctionalArea?: string | null
    ReferenceId?: string | null
    Notes?: string | null
    Facilities?: string | null
    date?: string | null
    Email?: string | null
    CompanyName?: string | null
    Website?: string | null
    Status?: string | null
    Qualifications?: string | null
    isFavourite?: boolean
    isImported?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    followups?: FollowupUncheckedCreateNestedManyWithoutContactInput
    contactFollowups?: ContactFollowupUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutAssignToInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutAssignToInput, ContactUncheckedCreateWithoutAssignToInput>
  }

  export type ContactCreateManyAssignToInputEnvelope = {
    data: ContactCreateManyAssignToInput | ContactCreateManyAssignToInput[]
    skipDuplicates?: boolean
  }

  export type AdminUpsertWithoutCreatedAdminsInput = {
    update: XOR<AdminUpdateWithoutCreatedAdminsInput, AdminUncheckedUpdateWithoutCreatedAdminsInput>
    create: XOR<AdminCreateWithoutCreatedAdminsInput, AdminUncheckedCreateWithoutCreatedAdminsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutCreatedAdminsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutCreatedAdminsInput, AdminUncheckedUpdateWithoutCreatedAdminsInput>
  }

  export type AdminUpdateWithoutCreatedAdminsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    AddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    AddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByRef?: AdminUpdateOneWithoutCreatedAdminsNestedInput
    assignedCustomers?: CustomerUpdateManyWithoutAssignToNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatedByNestedInput
    assignedContact?: ContactUpdateManyWithoutAssignToNestedInput
  }

  export type AdminUncheckedUpdateWithoutCreatedAdminsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    AddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    AddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedCustomers?: CustomerUncheckedUpdateManyWithoutAssignToNestedInput
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedContact?: ContactUncheckedUpdateManyWithoutAssignToNestedInput
  }

  export type AdminUpsertWithWhereUniqueWithoutCreatedByRefInput = {
    where: AdminWhereUniqueInput
    update: XOR<AdminUpdateWithoutCreatedByRefInput, AdminUncheckedUpdateWithoutCreatedByRefInput>
    create: XOR<AdminCreateWithoutCreatedByRefInput, AdminUncheckedCreateWithoutCreatedByRefInput>
  }

  export type AdminUpdateWithWhereUniqueWithoutCreatedByRefInput = {
    where: AdminWhereUniqueInput
    data: XOR<AdminUpdateWithoutCreatedByRefInput, AdminUncheckedUpdateWithoutCreatedByRefInput>
  }

  export type AdminUpdateManyWithWhereWithoutCreatedByRefInput = {
    where: AdminScalarWhereInput
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyWithoutCreatedByRefInput>
  }

  export type AdminScalarWhereInput = {
    AND?: AdminScalarWhereInput | AdminScalarWhereInput[]
    OR?: AdminScalarWhereInput[]
    NOT?: AdminScalarWhereInput | AdminScalarWhereInput[]
    id?: StringFilter<"Admin"> | string
    name?: StringFilter<"Admin"> | string
    email?: StringFilter<"Admin"> | string
    password?: StringFilter<"Admin"> | string
    role?: EnumRoleFilter<"Admin"> | $Enums.Role
    city?: StringNullableFilter<"Admin"> | string | null
    phone?: StringNullableFilter<"Admin"> | string | null
    status?: EnumAdminStatusFilter<"Admin"> | $Enums.AdminStatus
    AddressLine1?: StringNullableFilter<"Admin"> | string | null
    AddressLine2?: StringNullableFilter<"Admin"> | string | null
    createdBy?: StringNullableFilter<"Admin"> | string | null
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
  }

  export type CustomerUpsertWithWhereUniqueWithoutAssignToInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutAssignToInput, CustomerUncheckedUpdateWithoutAssignToInput>
    create: XOR<CustomerCreateWithoutAssignToInput, CustomerUncheckedCreateWithoutAssignToInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutAssignToInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutAssignToInput, CustomerUncheckedUpdateWithoutAssignToInput>
  }

  export type CustomerUpdateManyWithWhereWithoutAssignToInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutAssignToInput>
  }

  export type CustomerScalarWhereInput = {
    AND?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    OR?: CustomerScalarWhereInput[]
    NOT?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    id?: StringFilter<"Customer"> | string
    Campaign?: StringNullableFilter<"Customer"> | string | null
    CustomerType?: StringNullableFilter<"Customer"> | string | null
    CustomerSubType?: StringNullableFilter<"Customer"> | string | null
    customerName?: StringFilter<"Customer"> | string
    ContactNumber?: StringFilter<"Customer"> | string
    City?: StringNullableFilter<"Customer"> | string | null
    Location?: StringNullableFilter<"Customer"> | string | null
    Area?: StringNullableFilter<"Customer"> | string | null
    Adderess?: StringNullableFilter<"Customer"> | string | null
    Email?: StringNullableFilter<"Customer"> | string | null
    Facillities?: StringNullableFilter<"Customer"> | string | null
    ReferenceId?: StringNullableFilter<"Customer"> | string | null
    CustomerId?: StringNullableFilter<"Customer"> | string | null
    CustomerDate?: StringNullableFilter<"Customer"> | string | null
    CustomerYear?: StringNullableFilter<"Customer"> | string | null
    Other?: StringNullableFilter<"Customer"> | string | null
    Description?: StringNullableFilter<"Customer"> | string | null
    Video?: StringNullableFilter<"Customer"> | string | null
    Verified?: StringNullableFilter<"Customer"> | string | null
    GoogleMap?: StringNullableFilter<"Customer"> | string | null
    CustomerImage?: JsonNullableFilter<"Customer">
    SitePlan?: JsonNullableFilter<"Customer">
    isFavourite?: BoolFilter<"Customer"> | boolean
    AssignToId?: StringNullableFilter<"Customer"> | string | null
    CreatedById?: StringNullableFilter<"Customer"> | string | null
    isImported?: BoolFilter<"Customer"> | boolean
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
  }

  export type CustomerUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutCreatedByInput, CustomerUncheckedUpdateWithoutCreatedByInput>
    create: XOR<CustomerCreateWithoutCreatedByInput, CustomerUncheckedCreateWithoutCreatedByInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutCreatedByInput, CustomerUncheckedUpdateWithoutCreatedByInput>
  }

  export type CustomerUpdateManyWithWhereWithoutCreatedByInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type ContactUpsertWithWhereUniqueWithoutAssignToInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutAssignToInput, ContactUncheckedUpdateWithoutAssignToInput>
    create: XOR<ContactCreateWithoutAssignToInput, ContactUncheckedCreateWithoutAssignToInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutAssignToInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutAssignToInput, ContactUncheckedUpdateWithoutAssignToInput>
  }

  export type ContactUpdateManyWithWhereWithoutAssignToInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutAssignToInput>
  }

  export type ContactScalarWhereInput = {
    AND?: ContactScalarWhereInput | ContactScalarWhereInput[]
    OR?: ContactScalarWhereInput[]
    NOT?: ContactScalarWhereInput | ContactScalarWhereInput[]
    id?: StringFilter<"Contact"> | string
    Campaign?: StringNullableFilter<"Contact"> | string | null
    Range?: StringNullableFilter<"Contact"> | string | null
    ContactNo?: StringNullableFilter<"Contact"> | string | null
    Location?: StringNullableFilter<"Contact"> | string | null
    ContactType?: StringNullableFilter<"Contact"> | string | null
    Name?: StringFilter<"Contact"> | string
    City?: StringNullableFilter<"Contact"> | string | null
    Address?: StringNullableFilter<"Contact"> | string | null
    ContactIndustry?: StringNullableFilter<"Contact"> | string | null
    ContactFunctionalArea?: StringNullableFilter<"Contact"> | string | null
    ReferenceId?: StringNullableFilter<"Contact"> | string | null
    Notes?: StringNullableFilter<"Contact"> | string | null
    Facilities?: StringNullableFilter<"Contact"> | string | null
    date?: StringNullableFilter<"Contact"> | string | null
    Email?: StringNullableFilter<"Contact"> | string | null
    CompanyName?: StringNullableFilter<"Contact"> | string | null
    Website?: StringNullableFilter<"Contact"> | string | null
    Status?: StringNullableFilter<"Contact"> | string | null
    Qualifications?: StringNullableFilter<"Contact"> | string | null
    isFavourite?: BoolFilter<"Contact"> | boolean
    isImported?: BoolFilter<"Contact"> | boolean
    AssignToId?: StringNullableFilter<"Contact"> | string | null
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
  }

  export type TypeCreateWithoutCampaignInput = {
    id?: string
    Name?: string
    Status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    subTypes?: SubTypeCreateNestedManyWithoutCustomerTypeInput
  }

  export type TypeUncheckedCreateWithoutCampaignInput = {
    id?: string
    Name?: string
    Status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    subTypes?: SubTypeUncheckedCreateNestedManyWithoutCustomerTypeInput
  }

  export type TypeCreateOrConnectWithoutCampaignInput = {
    where: TypeWhereUniqueInput
    create: XOR<TypeCreateWithoutCampaignInput, TypeUncheckedCreateWithoutCampaignInput>
  }

  export type TypeCreateManyCampaignInputEnvelope = {
    data: TypeCreateManyCampaignInput | TypeCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type SubTypeCreateWithoutCampaignInput = {
    id?: string
    Name: string
    Status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    CustomerType: TypeCreateNestedOneWithoutSubTypesInput
  }

  export type SubTypeUncheckedCreateWithoutCampaignInput = {
    id?: string
    Name: string
    Status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customerTypeId: string
  }

  export type SubTypeCreateOrConnectWithoutCampaignInput = {
    where: SubTypeWhereUniqueInput
    create: XOR<SubTypeCreateWithoutCampaignInput, SubTypeUncheckedCreateWithoutCampaignInput>
  }

  export type SubTypeCreateManyCampaignInputEnvelope = {
    data: SubTypeCreateManyCampaignInput | SubTypeCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type TypeUpsertWithWhereUniqueWithoutCampaignInput = {
    where: TypeWhereUniqueInput
    update: XOR<TypeUpdateWithoutCampaignInput, TypeUncheckedUpdateWithoutCampaignInput>
    create: XOR<TypeCreateWithoutCampaignInput, TypeUncheckedCreateWithoutCampaignInput>
  }

  export type TypeUpdateWithWhereUniqueWithoutCampaignInput = {
    where: TypeWhereUniqueInput
    data: XOR<TypeUpdateWithoutCampaignInput, TypeUncheckedUpdateWithoutCampaignInput>
  }

  export type TypeUpdateManyWithWhereWithoutCampaignInput = {
    where: TypeScalarWhereInput
    data: XOR<TypeUpdateManyMutationInput, TypeUncheckedUpdateManyWithoutCampaignInput>
  }

  export type TypeScalarWhereInput = {
    AND?: TypeScalarWhereInput | TypeScalarWhereInput[]
    OR?: TypeScalarWhereInput[]
    NOT?: TypeScalarWhereInput | TypeScalarWhereInput[]
    id?: StringFilter<"Type"> | string
    Name?: StringFilter<"Type"> | string
    Status?: EnumStatusFilter<"Type"> | $Enums.Status
    campaignId?: StringFilter<"Type"> | string
    createdAt?: DateTimeFilter<"Type"> | Date | string
    updatedAt?: DateTimeFilter<"Type"> | Date | string
  }

  export type SubTypeUpsertWithWhereUniqueWithoutCampaignInput = {
    where: SubTypeWhereUniqueInput
    update: XOR<SubTypeUpdateWithoutCampaignInput, SubTypeUncheckedUpdateWithoutCampaignInput>
    create: XOR<SubTypeCreateWithoutCampaignInput, SubTypeUncheckedCreateWithoutCampaignInput>
  }

  export type SubTypeUpdateWithWhereUniqueWithoutCampaignInput = {
    where: SubTypeWhereUniqueInput
    data: XOR<SubTypeUpdateWithoutCampaignInput, SubTypeUncheckedUpdateWithoutCampaignInput>
  }

  export type SubTypeUpdateManyWithWhereWithoutCampaignInput = {
    where: SubTypeScalarWhereInput
    data: XOR<SubTypeUpdateManyMutationInput, SubTypeUncheckedUpdateManyWithoutCampaignInput>
  }

  export type SubTypeScalarWhereInput = {
    AND?: SubTypeScalarWhereInput | SubTypeScalarWhereInput[]
    OR?: SubTypeScalarWhereInput[]
    NOT?: SubTypeScalarWhereInput | SubTypeScalarWhereInput[]
    id?: StringFilter<"SubType"> | string
    Name?: StringFilter<"SubType"> | string
    Status?: StringFilter<"SubType"> | string
    createdAt?: DateTimeFilter<"SubType"> | Date | string
    updatedAt?: DateTimeFilter<"SubType"> | Date | string
    campaignId?: StringFilter<"SubType"> | string
    customerTypeId?: StringFilter<"SubType"> | string
  }

  export type CampaignCreateWithoutTypesInput = {
    id?: string
    Name: string
    Status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    subTypes?: SubTypeCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutTypesInput = {
    id?: string
    Name: string
    Status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    subTypes?: SubTypeUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutTypesInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutTypesInput, CampaignUncheckedCreateWithoutTypesInput>
  }

  export type SubTypeCreateWithoutCustomerTypeInput = {
    id?: string
    Name: string
    Status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Campaign: CampaignCreateNestedOneWithoutSubTypesInput
  }

  export type SubTypeUncheckedCreateWithoutCustomerTypeInput = {
    id?: string
    Name: string
    Status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    campaignId: string
  }

  export type SubTypeCreateOrConnectWithoutCustomerTypeInput = {
    where: SubTypeWhereUniqueInput
    create: XOR<SubTypeCreateWithoutCustomerTypeInput, SubTypeUncheckedCreateWithoutCustomerTypeInput>
  }

  export type SubTypeCreateManyCustomerTypeInputEnvelope = {
    data: SubTypeCreateManyCustomerTypeInput | SubTypeCreateManyCustomerTypeInput[]
    skipDuplicates?: boolean
  }

  export type CampaignUpsertWithoutTypesInput = {
    update: XOR<CampaignUpdateWithoutTypesInput, CampaignUncheckedUpdateWithoutTypesInput>
    create: XOR<CampaignCreateWithoutTypesInput, CampaignUncheckedCreateWithoutTypesInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutTypesInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutTypesInput, CampaignUncheckedUpdateWithoutTypesInput>
  }

  export type CampaignUpdateWithoutTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subTypes?: SubTypeUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subTypes?: SubTypeUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type SubTypeUpsertWithWhereUniqueWithoutCustomerTypeInput = {
    where: SubTypeWhereUniqueInput
    update: XOR<SubTypeUpdateWithoutCustomerTypeInput, SubTypeUncheckedUpdateWithoutCustomerTypeInput>
    create: XOR<SubTypeCreateWithoutCustomerTypeInput, SubTypeUncheckedCreateWithoutCustomerTypeInput>
  }

  export type SubTypeUpdateWithWhereUniqueWithoutCustomerTypeInput = {
    where: SubTypeWhereUniqueInput
    data: XOR<SubTypeUpdateWithoutCustomerTypeInput, SubTypeUncheckedUpdateWithoutCustomerTypeInput>
  }

  export type SubTypeUpdateManyWithWhereWithoutCustomerTypeInput = {
    where: SubTypeScalarWhereInput
    data: XOR<SubTypeUpdateManyMutationInput, SubTypeUncheckedUpdateManyWithoutCustomerTypeInput>
  }

  export type CampaignCreateWithoutSubTypesInput = {
    id?: string
    Name: string
    Status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    types?: TypeCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutSubTypesInput = {
    id?: string
    Name: string
    Status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    types?: TypeUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutSubTypesInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutSubTypesInput, CampaignUncheckedCreateWithoutSubTypesInput>
  }

  export type TypeCreateWithoutSubTypesInput = {
    id?: string
    Name?: string
    Status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    Campaign: CampaignCreateNestedOneWithoutTypesInput
  }

  export type TypeUncheckedCreateWithoutSubTypesInput = {
    id?: string
    Name?: string
    Status?: $Enums.Status
    campaignId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TypeCreateOrConnectWithoutSubTypesInput = {
    where: TypeWhereUniqueInput
    create: XOR<TypeCreateWithoutSubTypesInput, TypeUncheckedCreateWithoutSubTypesInput>
  }

  export type CampaignUpsertWithoutSubTypesInput = {
    update: XOR<CampaignUpdateWithoutSubTypesInput, CampaignUncheckedUpdateWithoutSubTypesInput>
    create: XOR<CampaignCreateWithoutSubTypesInput, CampaignUncheckedCreateWithoutSubTypesInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutSubTypesInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutSubTypesInput, CampaignUncheckedUpdateWithoutSubTypesInput>
  }

  export type CampaignUpdateWithoutSubTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    types?: TypeUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutSubTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    types?: TypeUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type TypeUpsertWithoutSubTypesInput = {
    update: XOR<TypeUpdateWithoutSubTypesInput, TypeUncheckedUpdateWithoutSubTypesInput>
    create: XOR<TypeCreateWithoutSubTypesInput, TypeUncheckedCreateWithoutSubTypesInput>
    where?: TypeWhereInput
  }

  export type TypeUpdateToOneWithWhereWithoutSubTypesInput = {
    where?: TypeWhereInput
    data: XOR<TypeUpdateWithoutSubTypesInput, TypeUncheckedUpdateWithoutSubTypesInput>
  }

  export type TypeUpdateWithoutSubTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Campaign?: CampaignUpdateOneRequiredWithoutTypesNestedInput
  }

  export type TypeUncheckedUpdateWithoutSubTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    campaignId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactTypeCreateWithoutCampaignInput = {
    id?: string
    Name?: string
    Status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactTypeUncheckedCreateWithoutCampaignInput = {
    id?: string
    Name?: string
    Status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactTypeCreateOrConnectWithoutCampaignInput = {
    where: ContactTypeWhereUniqueInput
    create: XOR<ContactTypeCreateWithoutCampaignInput, ContactTypeUncheckedCreateWithoutCampaignInput>
  }

  export type ContactTypeCreateManyCampaignInputEnvelope = {
    data: ContactTypeCreateManyCampaignInput | ContactTypeCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type ContactTypeUpsertWithWhereUniqueWithoutCampaignInput = {
    where: ContactTypeWhereUniqueInput
    update: XOR<ContactTypeUpdateWithoutCampaignInput, ContactTypeUncheckedUpdateWithoutCampaignInput>
    create: XOR<ContactTypeCreateWithoutCampaignInput, ContactTypeUncheckedCreateWithoutCampaignInput>
  }

  export type ContactTypeUpdateWithWhereUniqueWithoutCampaignInput = {
    where: ContactTypeWhereUniqueInput
    data: XOR<ContactTypeUpdateWithoutCampaignInput, ContactTypeUncheckedUpdateWithoutCampaignInput>
  }

  export type ContactTypeUpdateManyWithWhereWithoutCampaignInput = {
    where: ContactTypeScalarWhereInput
    data: XOR<ContactTypeUpdateManyMutationInput, ContactTypeUncheckedUpdateManyWithoutCampaignInput>
  }

  export type ContactTypeScalarWhereInput = {
    AND?: ContactTypeScalarWhereInput | ContactTypeScalarWhereInput[]
    OR?: ContactTypeScalarWhereInput[]
    NOT?: ContactTypeScalarWhereInput | ContactTypeScalarWhereInput[]
    id?: StringFilter<"ContactType"> | string
    Name?: StringFilter<"ContactType"> | string
    Status?: EnumStatusFilter<"ContactType"> | $Enums.Status
    createdAt?: DateTimeFilter<"ContactType"> | Date | string
    updatedAt?: DateTimeFilter<"ContactType"> | Date | string
    campaignId?: StringFilter<"ContactType"> | string
  }

  export type ContactCampaignCreateWithoutContactTypesInput = {
    id?: string
    Name: string
    Status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactCampaignUncheckedCreateWithoutContactTypesInput = {
    id?: string
    Name: string
    Status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactCampaignCreateOrConnectWithoutContactTypesInput = {
    where: ContactCampaignWhereUniqueInput
    create: XOR<ContactCampaignCreateWithoutContactTypesInput, ContactCampaignUncheckedCreateWithoutContactTypesInput>
  }

  export type ContactCampaignUpsertWithoutContactTypesInput = {
    update: XOR<ContactCampaignUpdateWithoutContactTypesInput, ContactCampaignUncheckedUpdateWithoutContactTypesInput>
    create: XOR<ContactCampaignCreateWithoutContactTypesInput, ContactCampaignUncheckedCreateWithoutContactTypesInput>
    where?: ContactCampaignWhereInput
  }

  export type ContactCampaignUpdateToOneWithWhereWithoutContactTypesInput = {
    where?: ContactCampaignWhereInput
    data: XOR<ContactCampaignUpdateWithoutContactTypesInput, ContactCampaignUncheckedUpdateWithoutContactTypesInput>
  }

  export type ContactCampaignUpdateWithoutContactTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCampaignUncheckedUpdateWithoutContactTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationCreateWithoutCityInput = {
    id?: string
    Name?: string
    Status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationUncheckedCreateWithoutCityInput = {
    id?: string
    Name?: string
    Status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationCreateOrConnectWithoutCityInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutCityInput, LocationUncheckedCreateWithoutCityInput>
  }

  export type LocationCreateManyCityInputEnvelope = {
    data: LocationCreateManyCityInput | LocationCreateManyCityInput[]
    skipDuplicates?: boolean
  }

  export type LocationUpsertWithWhereUniqueWithoutCityInput = {
    where: LocationWhereUniqueInput
    update: XOR<LocationUpdateWithoutCityInput, LocationUncheckedUpdateWithoutCityInput>
    create: XOR<LocationCreateWithoutCityInput, LocationUncheckedCreateWithoutCityInput>
  }

  export type LocationUpdateWithWhereUniqueWithoutCityInput = {
    where: LocationWhereUniqueInput
    data: XOR<LocationUpdateWithoutCityInput, LocationUncheckedUpdateWithoutCityInput>
  }

  export type LocationUpdateManyWithWhereWithoutCityInput = {
    where: LocationScalarWhereInput
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyWithoutCityInput>
  }

  export type LocationScalarWhereInput = {
    AND?: LocationScalarWhereInput | LocationScalarWhereInput[]
    OR?: LocationScalarWhereInput[]
    NOT?: LocationScalarWhereInput | LocationScalarWhereInput[]
    id?: StringFilter<"Location"> | string
    Name?: StringFilter<"Location"> | string
    Status?: StringFilter<"Location"> | string
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    cityId?: StringFilter<"Location"> | string
  }

  export type CityCreateWithoutLocationsInput = {
    id?: string
    Name: string
    Status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CityUncheckedCreateWithoutLocationsInput = {
    id?: string
    Name: string
    Status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CityCreateOrConnectWithoutLocationsInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutLocationsInput, CityUncheckedCreateWithoutLocationsInput>
  }

  export type CityUpsertWithoutLocationsInput = {
    update: XOR<CityUpdateWithoutLocationsInput, CityUncheckedUpdateWithoutLocationsInput>
    create: XOR<CityCreateWithoutLocationsInput, CityUncheckedCreateWithoutLocationsInput>
    where?: CityWhereInput
  }

  export type CityUpdateToOneWithWhereWithoutLocationsInput = {
    where?: CityWhereInput
    data: XOR<CityUpdateWithoutLocationsInput, CityUncheckedUpdateWithoutLocationsInput>
  }

  export type CityUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CityUncheckedUpdateWithoutLocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCreateWithoutAssignedCustomersInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.Role
    city?: string | null
    phone?: string | null
    status?: $Enums.AdminStatus
    AddressLine1?: string | null
    AddressLine2?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByRef?: AdminCreateNestedOneWithoutCreatedAdminsInput
    createdAdmins?: AdminCreateNestedManyWithoutCreatedByRefInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatedByInput
    assignedContact?: ContactCreateNestedManyWithoutAssignToInput
  }

  export type AdminUncheckedCreateWithoutAssignedCustomersInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.Role
    city?: string | null
    phone?: string | null
    status?: $Enums.AdminStatus
    AddressLine1?: string | null
    AddressLine2?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdAdmins?: AdminUncheckedCreateNestedManyWithoutCreatedByRefInput
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatedByInput
    assignedContact?: ContactUncheckedCreateNestedManyWithoutAssignToInput
  }

  export type AdminCreateOrConnectWithoutAssignedCustomersInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutAssignedCustomersInput, AdminUncheckedCreateWithoutAssignedCustomersInput>
  }

  export type AdminCreateWithoutCreatedCustomersInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.Role
    city?: string | null
    phone?: string | null
    status?: $Enums.AdminStatus
    AddressLine1?: string | null
    AddressLine2?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByRef?: AdminCreateNestedOneWithoutCreatedAdminsInput
    createdAdmins?: AdminCreateNestedManyWithoutCreatedByRefInput
    assignedCustomers?: CustomerCreateNestedManyWithoutAssignToInput
    assignedContact?: ContactCreateNestedManyWithoutAssignToInput
  }

  export type AdminUncheckedCreateWithoutCreatedCustomersInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.Role
    city?: string | null
    phone?: string | null
    status?: $Enums.AdminStatus
    AddressLine1?: string | null
    AddressLine2?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdAdmins?: AdminUncheckedCreateNestedManyWithoutCreatedByRefInput
    assignedCustomers?: CustomerUncheckedCreateNestedManyWithoutAssignToInput
    assignedContact?: ContactUncheckedCreateNestedManyWithoutAssignToInput
  }

  export type AdminCreateOrConnectWithoutCreatedCustomersInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutCreatedCustomersInput, AdminUncheckedCreateWithoutCreatedCustomersInput>
  }

  export type FollowupCreateWithoutCustomerInput = {
    id?: string
    StartDate?: string | null
    StatusType?: string | null
    FollowupNextDate?: string | null
    Description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contact?: ContactCreateNestedOneWithoutFollowupsInput
  }

  export type FollowupUncheckedCreateWithoutCustomerInput = {
    id?: string
    StartDate?: string | null
    StatusType?: string | null
    FollowupNextDate?: string | null
    Description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contactId?: string | null
  }

  export type FollowupCreateOrConnectWithoutCustomerInput = {
    where: FollowupWhereUniqueInput
    create: XOR<FollowupCreateWithoutCustomerInput, FollowupUncheckedCreateWithoutCustomerInput>
  }

  export type FollowupCreateManyCustomerInputEnvelope = {
    data: FollowupCreateManyCustomerInput | FollowupCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type AdminUpsertWithoutAssignedCustomersInput = {
    update: XOR<AdminUpdateWithoutAssignedCustomersInput, AdminUncheckedUpdateWithoutAssignedCustomersInput>
    create: XOR<AdminCreateWithoutAssignedCustomersInput, AdminUncheckedCreateWithoutAssignedCustomersInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutAssignedCustomersInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutAssignedCustomersInput, AdminUncheckedUpdateWithoutAssignedCustomersInput>
  }

  export type AdminUpdateWithoutAssignedCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    AddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    AddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByRef?: AdminUpdateOneWithoutCreatedAdminsNestedInput
    createdAdmins?: AdminUpdateManyWithoutCreatedByRefNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatedByNestedInput
    assignedContact?: ContactUpdateManyWithoutAssignToNestedInput
  }

  export type AdminUncheckedUpdateWithoutAssignedCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    AddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    AddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAdmins?: AdminUncheckedUpdateManyWithoutCreatedByRefNestedInput
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedContact?: ContactUncheckedUpdateManyWithoutAssignToNestedInput
  }

  export type AdminUpsertWithoutCreatedCustomersInput = {
    update: XOR<AdminUpdateWithoutCreatedCustomersInput, AdminUncheckedUpdateWithoutCreatedCustomersInput>
    create: XOR<AdminCreateWithoutCreatedCustomersInput, AdminUncheckedCreateWithoutCreatedCustomersInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutCreatedCustomersInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutCreatedCustomersInput, AdminUncheckedUpdateWithoutCreatedCustomersInput>
  }

  export type AdminUpdateWithoutCreatedCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    AddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    AddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByRef?: AdminUpdateOneWithoutCreatedAdminsNestedInput
    createdAdmins?: AdminUpdateManyWithoutCreatedByRefNestedInput
    assignedCustomers?: CustomerUpdateManyWithoutAssignToNestedInput
    assignedContact?: ContactUpdateManyWithoutAssignToNestedInput
  }

  export type AdminUncheckedUpdateWithoutCreatedCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    AddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    AddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAdmins?: AdminUncheckedUpdateManyWithoutCreatedByRefNestedInput
    assignedCustomers?: CustomerUncheckedUpdateManyWithoutAssignToNestedInput
    assignedContact?: ContactUncheckedUpdateManyWithoutAssignToNestedInput
  }

  export type FollowupUpsertWithWhereUniqueWithoutCustomerInput = {
    where: FollowupWhereUniqueInput
    update: XOR<FollowupUpdateWithoutCustomerInput, FollowupUncheckedUpdateWithoutCustomerInput>
    create: XOR<FollowupCreateWithoutCustomerInput, FollowupUncheckedCreateWithoutCustomerInput>
  }

  export type FollowupUpdateWithWhereUniqueWithoutCustomerInput = {
    where: FollowupWhereUniqueInput
    data: XOR<FollowupUpdateWithoutCustomerInput, FollowupUncheckedUpdateWithoutCustomerInput>
  }

  export type FollowupUpdateManyWithWhereWithoutCustomerInput = {
    where: FollowupScalarWhereInput
    data: XOR<FollowupUpdateManyMutationInput, FollowupUncheckedUpdateManyWithoutCustomerInput>
  }

  export type FollowupScalarWhereInput = {
    AND?: FollowupScalarWhereInput | FollowupScalarWhereInput[]
    OR?: FollowupScalarWhereInput[]
    NOT?: FollowupScalarWhereInput | FollowupScalarWhereInput[]
    id?: StringFilter<"Followup"> | string
    customerId?: StringFilter<"Followup"> | string
    StartDate?: StringNullableFilter<"Followup"> | string | null
    StatusType?: StringNullableFilter<"Followup"> | string | null
    FollowupNextDate?: StringNullableFilter<"Followup"> | string | null
    Description?: StringNullableFilter<"Followup"> | string | null
    createdAt?: DateTimeFilter<"Followup"> | Date | string
    updatedAt?: DateTimeFilter<"Followup"> | Date | string
    contactId?: StringNullableFilter<"Followup"> | string | null
  }

  export type CustomerCreateWithoutFollowupsInput = {
    id?: string
    Campaign?: string | null
    CustomerType?: string | null
    CustomerSubType?: string | null
    customerName: string
    ContactNumber: string
    City?: string | null
    Location?: string | null
    Area?: string | null
    Adderess?: string | null
    Email?: string | null
    Facillities?: string | null
    ReferenceId?: string | null
    CustomerId?: string | null
    CustomerDate?: string | null
    CustomerYear?: string | null
    Other?: string | null
    Description?: string | null
    Video?: string | null
    Verified?: string | null
    GoogleMap?: string | null
    CustomerImage?: NullableJsonNullValueInput | InputJsonValue
    SitePlan?: NullableJsonNullValueInput | InputJsonValue
    isFavourite?: boolean
    isImported?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    AssignTo?: AdminCreateNestedOneWithoutAssignedCustomersInput
    CreatedBy?: AdminCreateNestedOneWithoutCreatedCustomersInput
  }

  export type CustomerUncheckedCreateWithoutFollowupsInput = {
    id?: string
    Campaign?: string | null
    CustomerType?: string | null
    CustomerSubType?: string | null
    customerName: string
    ContactNumber: string
    City?: string | null
    Location?: string | null
    Area?: string | null
    Adderess?: string | null
    Email?: string | null
    Facillities?: string | null
    ReferenceId?: string | null
    CustomerId?: string | null
    CustomerDate?: string | null
    CustomerYear?: string | null
    Other?: string | null
    Description?: string | null
    Video?: string | null
    Verified?: string | null
    GoogleMap?: string | null
    CustomerImage?: NullableJsonNullValueInput | InputJsonValue
    SitePlan?: NullableJsonNullValueInput | InputJsonValue
    isFavourite?: boolean
    AssignToId?: string | null
    CreatedById?: string | null
    isImported?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerCreateOrConnectWithoutFollowupsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutFollowupsInput, CustomerUncheckedCreateWithoutFollowupsInput>
  }

  export type ContactCreateWithoutFollowupsInput = {
    id?: string
    Campaign?: string | null
    Range?: string | null
    ContactNo?: string | null
    Location?: string | null
    ContactType?: string | null
    Name?: string
    City?: string | null
    Address?: string | null
    ContactIndustry?: string | null
    ContactFunctionalArea?: string | null
    ReferenceId?: string | null
    Notes?: string | null
    Facilities?: string | null
    date?: string | null
    Email?: string | null
    CompanyName?: string | null
    Website?: string | null
    Status?: string | null
    Qualifications?: string | null
    isFavourite?: boolean
    isImported?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    AssignTo?: AdminCreateNestedOneWithoutAssignedContactInput
    contactFollowups?: ContactFollowupCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutFollowupsInput = {
    id?: string
    Campaign?: string | null
    Range?: string | null
    ContactNo?: string | null
    Location?: string | null
    ContactType?: string | null
    Name?: string
    City?: string | null
    Address?: string | null
    ContactIndustry?: string | null
    ContactFunctionalArea?: string | null
    ReferenceId?: string | null
    Notes?: string | null
    Facilities?: string | null
    date?: string | null
    Email?: string | null
    CompanyName?: string | null
    Website?: string | null
    Status?: string | null
    Qualifications?: string | null
    isFavourite?: boolean
    isImported?: boolean
    AssignToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contactFollowups?: ContactFollowupUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutFollowupsInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutFollowupsInput, ContactUncheckedCreateWithoutFollowupsInput>
  }

  export type CustomerUpsertWithoutFollowupsInput = {
    update: XOR<CustomerUpdateWithoutFollowupsInput, CustomerUncheckedUpdateWithoutFollowupsInput>
    create: XOR<CustomerCreateWithoutFollowupsInput, CustomerUncheckedCreateWithoutFollowupsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutFollowupsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutFollowupsInput, CustomerUncheckedUpdateWithoutFollowupsInput>
  }

  export type CustomerUpdateWithoutFollowupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    Campaign?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerType?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerSubType?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    ContactNumber?: StringFieldUpdateOperationsInput | string
    City?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    Area?: NullableStringFieldUpdateOperationsInput | string | null
    Adderess?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Facillities?: NullableStringFieldUpdateOperationsInput | string | null
    ReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerDate?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerYear?: NullableStringFieldUpdateOperationsInput | string | null
    Other?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Video?: NullableStringFieldUpdateOperationsInput | string | null
    Verified?: NullableStringFieldUpdateOperationsInput | string | null
    GoogleMap?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerImage?: NullableJsonNullValueInput | InputJsonValue
    SitePlan?: NullableJsonNullValueInput | InputJsonValue
    isFavourite?: BoolFieldUpdateOperationsInput | boolean
    isImported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AssignTo?: AdminUpdateOneWithoutAssignedCustomersNestedInput
    CreatedBy?: AdminUpdateOneWithoutCreatedCustomersNestedInput
  }

  export type CustomerUncheckedUpdateWithoutFollowupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    Campaign?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerType?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerSubType?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    ContactNumber?: StringFieldUpdateOperationsInput | string
    City?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    Area?: NullableStringFieldUpdateOperationsInput | string | null
    Adderess?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Facillities?: NullableStringFieldUpdateOperationsInput | string | null
    ReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerDate?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerYear?: NullableStringFieldUpdateOperationsInput | string | null
    Other?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Video?: NullableStringFieldUpdateOperationsInput | string | null
    Verified?: NullableStringFieldUpdateOperationsInput | string | null
    GoogleMap?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerImage?: NullableJsonNullValueInput | InputJsonValue
    SitePlan?: NullableJsonNullValueInput | InputJsonValue
    isFavourite?: BoolFieldUpdateOperationsInput | boolean
    AssignToId?: NullableStringFieldUpdateOperationsInput | string | null
    CreatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isImported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUpsertWithoutFollowupsInput = {
    update: XOR<ContactUpdateWithoutFollowupsInput, ContactUncheckedUpdateWithoutFollowupsInput>
    create: XOR<ContactCreateWithoutFollowupsInput, ContactUncheckedCreateWithoutFollowupsInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutFollowupsInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutFollowupsInput, ContactUncheckedUpdateWithoutFollowupsInput>
  }

  export type ContactUpdateWithoutFollowupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    Campaign?: NullableStringFieldUpdateOperationsInput | string | null
    Range?: NullableStringFieldUpdateOperationsInput | string | null
    ContactNo?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    ContactType?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: StringFieldUpdateOperationsInput | string
    City?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    ContactIndustry?: NullableStringFieldUpdateOperationsInput | string | null
    ContactFunctionalArea?: NullableStringFieldUpdateOperationsInput | string | null
    ReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Facilities?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyName?: NullableStringFieldUpdateOperationsInput | string | null
    Website?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    isFavourite?: BoolFieldUpdateOperationsInput | boolean
    isImported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AssignTo?: AdminUpdateOneWithoutAssignedContactNestedInput
    contactFollowups?: ContactFollowupUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutFollowupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    Campaign?: NullableStringFieldUpdateOperationsInput | string | null
    Range?: NullableStringFieldUpdateOperationsInput | string | null
    ContactNo?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    ContactType?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: StringFieldUpdateOperationsInput | string
    City?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    ContactIndustry?: NullableStringFieldUpdateOperationsInput | string | null
    ContactFunctionalArea?: NullableStringFieldUpdateOperationsInput | string | null
    ReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Facilities?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyName?: NullableStringFieldUpdateOperationsInput | string | null
    Website?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    isFavourite?: BoolFieldUpdateOperationsInput | boolean
    isImported?: BoolFieldUpdateOperationsInput | boolean
    AssignToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactFollowups?: ContactFollowupUncheckedUpdateManyWithoutContactNestedInput
  }

  export type AdminCreateWithoutAssignedContactInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.Role
    city?: string | null
    phone?: string | null
    status?: $Enums.AdminStatus
    AddressLine1?: string | null
    AddressLine2?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByRef?: AdminCreateNestedOneWithoutCreatedAdminsInput
    createdAdmins?: AdminCreateNestedManyWithoutCreatedByRefInput
    assignedCustomers?: CustomerCreateNestedManyWithoutAssignToInput
    createdCustomers?: CustomerCreateNestedManyWithoutCreatedByInput
  }

  export type AdminUncheckedCreateWithoutAssignedContactInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.Role
    city?: string | null
    phone?: string | null
    status?: $Enums.AdminStatus
    AddressLine1?: string | null
    AddressLine2?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdAdmins?: AdminUncheckedCreateNestedManyWithoutCreatedByRefInput
    assignedCustomers?: CustomerUncheckedCreateNestedManyWithoutAssignToInput
    createdCustomers?: CustomerUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type AdminCreateOrConnectWithoutAssignedContactInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutAssignedContactInput, AdminUncheckedCreateWithoutAssignedContactInput>
  }

  export type FollowupCreateWithoutContactInput = {
    id?: string
    StartDate?: string | null
    StatusType?: string | null
    FollowupNextDate?: string | null
    Description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutFollowupsInput
  }

  export type FollowupUncheckedCreateWithoutContactInput = {
    id?: string
    customerId: string
    StartDate?: string | null
    StatusType?: string | null
    FollowupNextDate?: string | null
    Description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FollowupCreateOrConnectWithoutContactInput = {
    where: FollowupWhereUniqueInput
    create: XOR<FollowupCreateWithoutContactInput, FollowupUncheckedCreateWithoutContactInput>
  }

  export type FollowupCreateManyContactInputEnvelope = {
    data: FollowupCreateManyContactInput | FollowupCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type ContactFollowupCreateWithoutContactInput = {
    id?: string
    StartDate?: string | null
    StatusType?: string | null
    FollowupNextDate?: string | null
    Description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactFollowupUncheckedCreateWithoutContactInput = {
    id?: string
    StartDate?: string | null
    StatusType?: string | null
    FollowupNextDate?: string | null
    Description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactFollowupCreateOrConnectWithoutContactInput = {
    where: ContactFollowupWhereUniqueInput
    create: XOR<ContactFollowupCreateWithoutContactInput, ContactFollowupUncheckedCreateWithoutContactInput>
  }

  export type ContactFollowupCreateManyContactInputEnvelope = {
    data: ContactFollowupCreateManyContactInput | ContactFollowupCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type AdminUpsertWithoutAssignedContactInput = {
    update: XOR<AdminUpdateWithoutAssignedContactInput, AdminUncheckedUpdateWithoutAssignedContactInput>
    create: XOR<AdminCreateWithoutAssignedContactInput, AdminUncheckedCreateWithoutAssignedContactInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutAssignedContactInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutAssignedContactInput, AdminUncheckedUpdateWithoutAssignedContactInput>
  }

  export type AdminUpdateWithoutAssignedContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    AddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    AddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByRef?: AdminUpdateOneWithoutCreatedAdminsNestedInput
    createdAdmins?: AdminUpdateManyWithoutCreatedByRefNestedInput
    assignedCustomers?: CustomerUpdateManyWithoutAssignToNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatedByNestedInput
  }

  export type AdminUncheckedUpdateWithoutAssignedContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    AddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    AddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAdmins?: AdminUncheckedUpdateManyWithoutCreatedByRefNestedInput
    assignedCustomers?: CustomerUncheckedUpdateManyWithoutAssignToNestedInput
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type FollowupUpsertWithWhereUniqueWithoutContactInput = {
    where: FollowupWhereUniqueInput
    update: XOR<FollowupUpdateWithoutContactInput, FollowupUncheckedUpdateWithoutContactInput>
    create: XOR<FollowupCreateWithoutContactInput, FollowupUncheckedCreateWithoutContactInput>
  }

  export type FollowupUpdateWithWhereUniqueWithoutContactInput = {
    where: FollowupWhereUniqueInput
    data: XOR<FollowupUpdateWithoutContactInput, FollowupUncheckedUpdateWithoutContactInput>
  }

  export type FollowupUpdateManyWithWhereWithoutContactInput = {
    where: FollowupScalarWhereInput
    data: XOR<FollowupUpdateManyMutationInput, FollowupUncheckedUpdateManyWithoutContactInput>
  }

  export type ContactFollowupUpsertWithWhereUniqueWithoutContactInput = {
    where: ContactFollowupWhereUniqueInput
    update: XOR<ContactFollowupUpdateWithoutContactInput, ContactFollowupUncheckedUpdateWithoutContactInput>
    create: XOR<ContactFollowupCreateWithoutContactInput, ContactFollowupUncheckedCreateWithoutContactInput>
  }

  export type ContactFollowupUpdateWithWhereUniqueWithoutContactInput = {
    where: ContactFollowupWhereUniqueInput
    data: XOR<ContactFollowupUpdateWithoutContactInput, ContactFollowupUncheckedUpdateWithoutContactInput>
  }

  export type ContactFollowupUpdateManyWithWhereWithoutContactInput = {
    where: ContactFollowupScalarWhereInput
    data: XOR<ContactFollowupUpdateManyMutationInput, ContactFollowupUncheckedUpdateManyWithoutContactInput>
  }

  export type ContactFollowupScalarWhereInput = {
    AND?: ContactFollowupScalarWhereInput | ContactFollowupScalarWhereInput[]
    OR?: ContactFollowupScalarWhereInput[]
    NOT?: ContactFollowupScalarWhereInput | ContactFollowupScalarWhereInput[]
    id?: StringFilter<"ContactFollowup"> | string
    contactId?: StringFilter<"ContactFollowup"> | string
    StartDate?: StringNullableFilter<"ContactFollowup"> | string | null
    StatusType?: StringNullableFilter<"ContactFollowup"> | string | null
    FollowupNextDate?: StringNullableFilter<"ContactFollowup"> | string | null
    Description?: StringNullableFilter<"ContactFollowup"> | string | null
    createdAt?: DateTimeFilter<"ContactFollowup"> | Date | string
    updatedAt?: DateTimeFilter<"ContactFollowup"> | Date | string
  }

  export type ContactCreateWithoutContactFollowupsInput = {
    id?: string
    Campaign?: string | null
    Range?: string | null
    ContactNo?: string | null
    Location?: string | null
    ContactType?: string | null
    Name?: string
    City?: string | null
    Address?: string | null
    ContactIndustry?: string | null
    ContactFunctionalArea?: string | null
    ReferenceId?: string | null
    Notes?: string | null
    Facilities?: string | null
    date?: string | null
    Email?: string | null
    CompanyName?: string | null
    Website?: string | null
    Status?: string | null
    Qualifications?: string | null
    isFavourite?: boolean
    isImported?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    AssignTo?: AdminCreateNestedOneWithoutAssignedContactInput
    followups?: FollowupCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutContactFollowupsInput = {
    id?: string
    Campaign?: string | null
    Range?: string | null
    ContactNo?: string | null
    Location?: string | null
    ContactType?: string | null
    Name?: string
    City?: string | null
    Address?: string | null
    ContactIndustry?: string | null
    ContactFunctionalArea?: string | null
    ReferenceId?: string | null
    Notes?: string | null
    Facilities?: string | null
    date?: string | null
    Email?: string | null
    CompanyName?: string | null
    Website?: string | null
    Status?: string | null
    Qualifications?: string | null
    isFavourite?: boolean
    isImported?: boolean
    AssignToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    followups?: FollowupUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutContactFollowupsInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutContactFollowupsInput, ContactUncheckedCreateWithoutContactFollowupsInput>
  }

  export type ContactUpsertWithoutContactFollowupsInput = {
    update: XOR<ContactUpdateWithoutContactFollowupsInput, ContactUncheckedUpdateWithoutContactFollowupsInput>
    create: XOR<ContactCreateWithoutContactFollowupsInput, ContactUncheckedCreateWithoutContactFollowupsInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutContactFollowupsInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutContactFollowupsInput, ContactUncheckedUpdateWithoutContactFollowupsInput>
  }

  export type ContactUpdateWithoutContactFollowupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    Campaign?: NullableStringFieldUpdateOperationsInput | string | null
    Range?: NullableStringFieldUpdateOperationsInput | string | null
    ContactNo?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    ContactType?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: StringFieldUpdateOperationsInput | string
    City?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    ContactIndustry?: NullableStringFieldUpdateOperationsInput | string | null
    ContactFunctionalArea?: NullableStringFieldUpdateOperationsInput | string | null
    ReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Facilities?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyName?: NullableStringFieldUpdateOperationsInput | string | null
    Website?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    isFavourite?: BoolFieldUpdateOperationsInput | boolean
    isImported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AssignTo?: AdminUpdateOneWithoutAssignedContactNestedInput
    followups?: FollowupUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutContactFollowupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    Campaign?: NullableStringFieldUpdateOperationsInput | string | null
    Range?: NullableStringFieldUpdateOperationsInput | string | null
    ContactNo?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    ContactType?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: StringFieldUpdateOperationsInput | string
    City?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    ContactIndustry?: NullableStringFieldUpdateOperationsInput | string | null
    ContactFunctionalArea?: NullableStringFieldUpdateOperationsInput | string | null
    ReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Facilities?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyName?: NullableStringFieldUpdateOperationsInput | string | null
    Website?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    isFavourite?: BoolFieldUpdateOperationsInput | boolean
    isImported?: BoolFieldUpdateOperationsInput | boolean
    AssignToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followups?: FollowupUncheckedUpdateManyWithoutContactNestedInput
  }

  export type AdminCreateManyCreatedByRefInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.Role
    city?: string | null
    phone?: string | null
    status?: $Enums.AdminStatus
    AddressLine1?: string | null
    AddressLine2?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerCreateManyAssignToInput = {
    id?: string
    Campaign?: string | null
    CustomerType?: string | null
    CustomerSubType?: string | null
    customerName: string
    ContactNumber: string
    City?: string | null
    Location?: string | null
    Area?: string | null
    Adderess?: string | null
    Email?: string | null
    Facillities?: string | null
    ReferenceId?: string | null
    CustomerId?: string | null
    CustomerDate?: string | null
    CustomerYear?: string | null
    Other?: string | null
    Description?: string | null
    Video?: string | null
    Verified?: string | null
    GoogleMap?: string | null
    CustomerImage?: NullableJsonNullValueInput | InputJsonValue
    SitePlan?: NullableJsonNullValueInput | InputJsonValue
    isFavourite?: boolean
    CreatedById?: string | null
    isImported?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerCreateManyCreatedByInput = {
    id?: string
    Campaign?: string | null
    CustomerType?: string | null
    CustomerSubType?: string | null
    customerName: string
    ContactNumber: string
    City?: string | null
    Location?: string | null
    Area?: string | null
    Adderess?: string | null
    Email?: string | null
    Facillities?: string | null
    ReferenceId?: string | null
    CustomerId?: string | null
    CustomerDate?: string | null
    CustomerYear?: string | null
    Other?: string | null
    Description?: string | null
    Video?: string | null
    Verified?: string | null
    GoogleMap?: string | null
    CustomerImage?: NullableJsonNullValueInput | InputJsonValue
    SitePlan?: NullableJsonNullValueInput | InputJsonValue
    isFavourite?: boolean
    AssignToId?: string | null
    isImported?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactCreateManyAssignToInput = {
    id?: string
    Campaign?: string | null
    Range?: string | null
    ContactNo?: string | null
    Location?: string | null
    ContactType?: string | null
    Name?: string
    City?: string | null
    Address?: string | null
    ContactIndustry?: string | null
    ContactFunctionalArea?: string | null
    ReferenceId?: string | null
    Notes?: string | null
    Facilities?: string | null
    date?: string | null
    Email?: string | null
    CompanyName?: string | null
    Website?: string | null
    Status?: string | null
    Qualifications?: string | null
    isFavourite?: boolean
    isImported?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUpdateWithoutCreatedByRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    AddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    AddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAdmins?: AdminUpdateManyWithoutCreatedByRefNestedInput
    assignedCustomers?: CustomerUpdateManyWithoutAssignToNestedInput
    createdCustomers?: CustomerUpdateManyWithoutCreatedByNestedInput
    assignedContact?: ContactUpdateManyWithoutAssignToNestedInput
  }

  export type AdminUncheckedUpdateWithoutCreatedByRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    AddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    AddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAdmins?: AdminUncheckedUpdateManyWithoutCreatedByRefNestedInput
    assignedCustomers?: CustomerUncheckedUpdateManyWithoutAssignToNestedInput
    createdCustomers?: CustomerUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedContact?: ContactUncheckedUpdateManyWithoutAssignToNestedInput
  }

  export type AdminUncheckedUpdateManyWithoutCreatedByRefInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAdminStatusFieldUpdateOperationsInput | $Enums.AdminStatus
    AddressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    AddressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUpdateWithoutAssignToInput = {
    id?: StringFieldUpdateOperationsInput | string
    Campaign?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerType?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerSubType?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    ContactNumber?: StringFieldUpdateOperationsInput | string
    City?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    Area?: NullableStringFieldUpdateOperationsInput | string | null
    Adderess?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Facillities?: NullableStringFieldUpdateOperationsInput | string | null
    ReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerDate?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerYear?: NullableStringFieldUpdateOperationsInput | string | null
    Other?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Video?: NullableStringFieldUpdateOperationsInput | string | null
    Verified?: NullableStringFieldUpdateOperationsInput | string | null
    GoogleMap?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerImage?: NullableJsonNullValueInput | InputJsonValue
    SitePlan?: NullableJsonNullValueInput | InputJsonValue
    isFavourite?: BoolFieldUpdateOperationsInput | boolean
    isImported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedBy?: AdminUpdateOneWithoutCreatedCustomersNestedInput
    followups?: FollowupUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutAssignToInput = {
    id?: StringFieldUpdateOperationsInput | string
    Campaign?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerType?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerSubType?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    ContactNumber?: StringFieldUpdateOperationsInput | string
    City?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    Area?: NullableStringFieldUpdateOperationsInput | string | null
    Adderess?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Facillities?: NullableStringFieldUpdateOperationsInput | string | null
    ReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerDate?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerYear?: NullableStringFieldUpdateOperationsInput | string | null
    Other?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Video?: NullableStringFieldUpdateOperationsInput | string | null
    Verified?: NullableStringFieldUpdateOperationsInput | string | null
    GoogleMap?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerImage?: NullableJsonNullValueInput | InputJsonValue
    SitePlan?: NullableJsonNullValueInput | InputJsonValue
    isFavourite?: BoolFieldUpdateOperationsInput | boolean
    CreatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isImported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followups?: FollowupUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateManyWithoutAssignToInput = {
    id?: StringFieldUpdateOperationsInput | string
    Campaign?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerType?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerSubType?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    ContactNumber?: StringFieldUpdateOperationsInput | string
    City?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    Area?: NullableStringFieldUpdateOperationsInput | string | null
    Adderess?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Facillities?: NullableStringFieldUpdateOperationsInput | string | null
    ReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerDate?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerYear?: NullableStringFieldUpdateOperationsInput | string | null
    Other?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Video?: NullableStringFieldUpdateOperationsInput | string | null
    Verified?: NullableStringFieldUpdateOperationsInput | string | null
    GoogleMap?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerImage?: NullableJsonNullValueInput | InputJsonValue
    SitePlan?: NullableJsonNullValueInput | InputJsonValue
    isFavourite?: BoolFieldUpdateOperationsInput | boolean
    CreatedById?: NullableStringFieldUpdateOperationsInput | string | null
    isImported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    Campaign?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerType?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerSubType?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    ContactNumber?: StringFieldUpdateOperationsInput | string
    City?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    Area?: NullableStringFieldUpdateOperationsInput | string | null
    Adderess?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Facillities?: NullableStringFieldUpdateOperationsInput | string | null
    ReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerDate?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerYear?: NullableStringFieldUpdateOperationsInput | string | null
    Other?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Video?: NullableStringFieldUpdateOperationsInput | string | null
    Verified?: NullableStringFieldUpdateOperationsInput | string | null
    GoogleMap?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerImage?: NullableJsonNullValueInput | InputJsonValue
    SitePlan?: NullableJsonNullValueInput | InputJsonValue
    isFavourite?: BoolFieldUpdateOperationsInput | boolean
    isImported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AssignTo?: AdminUpdateOneWithoutAssignedCustomersNestedInput
    followups?: FollowupUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    Campaign?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerType?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerSubType?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    ContactNumber?: StringFieldUpdateOperationsInput | string
    City?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    Area?: NullableStringFieldUpdateOperationsInput | string | null
    Adderess?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Facillities?: NullableStringFieldUpdateOperationsInput | string | null
    ReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerDate?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerYear?: NullableStringFieldUpdateOperationsInput | string | null
    Other?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Video?: NullableStringFieldUpdateOperationsInput | string | null
    Verified?: NullableStringFieldUpdateOperationsInput | string | null
    GoogleMap?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerImage?: NullableJsonNullValueInput | InputJsonValue
    SitePlan?: NullableJsonNullValueInput | InputJsonValue
    isFavourite?: BoolFieldUpdateOperationsInput | boolean
    AssignToId?: NullableStringFieldUpdateOperationsInput | string | null
    isImported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followups?: FollowupUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    Campaign?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerType?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerSubType?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: StringFieldUpdateOperationsInput | string
    ContactNumber?: StringFieldUpdateOperationsInput | string
    City?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    Area?: NullableStringFieldUpdateOperationsInput | string | null
    Adderess?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Facillities?: NullableStringFieldUpdateOperationsInput | string | null
    ReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerDate?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerYear?: NullableStringFieldUpdateOperationsInput | string | null
    Other?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Video?: NullableStringFieldUpdateOperationsInput | string | null
    Verified?: NullableStringFieldUpdateOperationsInput | string | null
    GoogleMap?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerImage?: NullableJsonNullValueInput | InputJsonValue
    SitePlan?: NullableJsonNullValueInput | InputJsonValue
    isFavourite?: BoolFieldUpdateOperationsInput | boolean
    AssignToId?: NullableStringFieldUpdateOperationsInput | string | null
    isImported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUpdateWithoutAssignToInput = {
    id?: StringFieldUpdateOperationsInput | string
    Campaign?: NullableStringFieldUpdateOperationsInput | string | null
    Range?: NullableStringFieldUpdateOperationsInput | string | null
    ContactNo?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    ContactType?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: StringFieldUpdateOperationsInput | string
    City?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    ContactIndustry?: NullableStringFieldUpdateOperationsInput | string | null
    ContactFunctionalArea?: NullableStringFieldUpdateOperationsInput | string | null
    ReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Facilities?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyName?: NullableStringFieldUpdateOperationsInput | string | null
    Website?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    isFavourite?: BoolFieldUpdateOperationsInput | boolean
    isImported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followups?: FollowupUpdateManyWithoutContactNestedInput
    contactFollowups?: ContactFollowupUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutAssignToInput = {
    id?: StringFieldUpdateOperationsInput | string
    Campaign?: NullableStringFieldUpdateOperationsInput | string | null
    Range?: NullableStringFieldUpdateOperationsInput | string | null
    ContactNo?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    ContactType?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: StringFieldUpdateOperationsInput | string
    City?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    ContactIndustry?: NullableStringFieldUpdateOperationsInput | string | null
    ContactFunctionalArea?: NullableStringFieldUpdateOperationsInput | string | null
    ReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Facilities?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyName?: NullableStringFieldUpdateOperationsInput | string | null
    Website?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    isFavourite?: BoolFieldUpdateOperationsInput | boolean
    isImported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followups?: FollowupUncheckedUpdateManyWithoutContactNestedInput
    contactFollowups?: ContactFollowupUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateManyWithoutAssignToInput = {
    id?: StringFieldUpdateOperationsInput | string
    Campaign?: NullableStringFieldUpdateOperationsInput | string | null
    Range?: NullableStringFieldUpdateOperationsInput | string | null
    ContactNo?: NullableStringFieldUpdateOperationsInput | string | null
    Location?: NullableStringFieldUpdateOperationsInput | string | null
    ContactType?: NullableStringFieldUpdateOperationsInput | string | null
    Name?: StringFieldUpdateOperationsInput | string
    City?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    ContactIndustry?: NullableStringFieldUpdateOperationsInput | string | null
    ContactFunctionalArea?: NullableStringFieldUpdateOperationsInput | string | null
    ReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    Notes?: NullableStringFieldUpdateOperationsInput | string | null
    Facilities?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyName?: NullableStringFieldUpdateOperationsInput | string | null
    Website?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: NullableStringFieldUpdateOperationsInput | string | null
    Qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    isFavourite?: BoolFieldUpdateOperationsInput | boolean
    isImported?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TypeCreateManyCampaignInput = {
    id?: string
    Name?: string
    Status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubTypeCreateManyCampaignInput = {
    id?: string
    Name: string
    Status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customerTypeId: string
  }

  export type TypeUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subTypes?: SubTypeUpdateManyWithoutCustomerTypeNestedInput
  }

  export type TypeUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subTypes?: SubTypeUncheckedUpdateManyWithoutCustomerTypeNestedInput
  }

  export type TypeUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubTypeUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CustomerType?: TypeUpdateOneRequiredWithoutSubTypesNestedInput
  }

  export type SubTypeUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerTypeId?: StringFieldUpdateOperationsInput | string
  }

  export type SubTypeUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerTypeId?: StringFieldUpdateOperationsInput | string
  }

  export type SubTypeCreateManyCustomerTypeInput = {
    id?: string
    Name: string
    Status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    campaignId: string
  }

  export type SubTypeUpdateWithoutCustomerTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Campaign?: CampaignUpdateOneRequiredWithoutSubTypesNestedInput
  }

  export type SubTypeUncheckedUpdateWithoutCustomerTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaignId?: StringFieldUpdateOperationsInput | string
  }

  export type SubTypeUncheckedUpdateManyWithoutCustomerTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaignId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactTypeCreateManyCampaignInput = {
    id?: string
    Name?: string
    Status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactTypeUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactTypeUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactTypeUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationCreateManyCityInput = {
    id?: string
    Name?: string
    Status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUncheckedUpdateWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUncheckedUpdateManyWithoutCityInput = {
    id?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowupCreateManyCustomerInput = {
    id?: string
    StartDate?: string | null
    StatusType?: string | null
    FollowupNextDate?: string | null
    Description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contactId?: string | null
  }

  export type FollowupUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    StartDate?: NullableStringFieldUpdateOperationsInput | string | null
    StatusType?: NullableStringFieldUpdateOperationsInput | string | null
    FollowupNextDate?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneWithoutFollowupsNestedInput
  }

  export type FollowupUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    StartDate?: NullableStringFieldUpdateOperationsInput | string | null
    StatusType?: NullableStringFieldUpdateOperationsInput | string | null
    FollowupNextDate?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FollowupUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    StartDate?: NullableStringFieldUpdateOperationsInput | string | null
    StatusType?: NullableStringFieldUpdateOperationsInput | string | null
    FollowupNextDate?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FollowupCreateManyContactInput = {
    id?: string
    customerId: string
    StartDate?: string | null
    StatusType?: string | null
    FollowupNextDate?: string | null
    Description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactFollowupCreateManyContactInput = {
    id?: string
    StartDate?: string | null
    StatusType?: string | null
    FollowupNextDate?: string | null
    Description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FollowupUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    StartDate?: NullableStringFieldUpdateOperationsInput | string | null
    StatusType?: NullableStringFieldUpdateOperationsInput | string | null
    FollowupNextDate?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutFollowupsNestedInput
  }

  export type FollowupUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    StartDate?: NullableStringFieldUpdateOperationsInput | string | null
    StatusType?: NullableStringFieldUpdateOperationsInput | string | null
    FollowupNextDate?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowupUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    StartDate?: NullableStringFieldUpdateOperationsInput | string | null
    StatusType?: NullableStringFieldUpdateOperationsInput | string | null
    FollowupNextDate?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactFollowupUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    StartDate?: NullableStringFieldUpdateOperationsInput | string | null
    StatusType?: NullableStringFieldUpdateOperationsInput | string | null
    FollowupNextDate?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactFollowupUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    StartDate?: NullableStringFieldUpdateOperationsInput | string | null
    StatusType?: NullableStringFieldUpdateOperationsInput | string | null
    FollowupNextDate?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactFollowupUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    StartDate?: NullableStringFieldUpdateOperationsInput | string | null
    StatusType?: NullableStringFieldUpdateOperationsInput | string | null
    FollowupNextDate?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}